schema {
    query: Query
    mutation: Mutation
}

"Marks the field, argument, input field or enum value as deprecated"
directive @deprecated(
    "The reason for the deprecation"
    reason: String = "No longer supported"
) on FIELD_DEFINITION | ARGUMENT_DEFINITION | ENUM_VALUE | INPUT_FIELD_DEFINITION

"Directs the executor to include this field or fragment only when the `if` argument is true"
directive @include(
    "Included when true."
    if: Boolean!
) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT

"Directs the executor to skip this field or fragment when the `if` argument is true."
directive @skip(
    "Skipped when true."
    if: Boolean!
) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT

"Exposes a URL that specifies the behaviour of this scalar."
directive @specifiedBy(
    "The URL that specifies the behaviour of this scalar."
    url: String!
) on SCALAR

interface AbstractTypeChangedEvent implements AuditedNode & BaseNode & Node & TimelineItem {
    "The DateTime this entity was created at."
    createdAt: DateTime!
    "The User who created this entity."
    createdBy: User!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "The Issue this TimelineItem is part of."
    issue: Issue
    "The DateTime this entity was last modified at."
    lastModifiedAt: DateTime!
    "The User who last modified this entity."
    lastModifiedBy: User!
    "If existing, the parent TimelineItem"
    parentItem: ParentTimelineItem
}

"""
Entities that can be affected by an Issue, meaning that this entity is in some regard
impacted by e.g. a bug described by an issue, or the non-present of a feature described by an issue.

"""
interface AffectedByIssue implements BaseNode & Named & NamedNode & Node {
    "The issues which affect this entity"
    affectingIssues(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: IssueFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: IssueOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): IssueConnection!
    "The description of this entity."
    description: String!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "The name of this entity."
    name: String!
}

"""
Node which provides auditing information, which can e.g. be used for the sync.
When it was created and last modified, if the it is already deleted, and by who it was created and last modified.
A modification is any change of a field on the node itself and a change of a relation (add or removed).
A change on a related related node is not a modification.

"""
interface AuditedNode implements BaseNode & Node {
    "The DateTime this entity was created at."
    createdAt: DateTime!
    "The User who created this entity."
    createdBy: User!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "The DateTime this entity was last modified at."
    lastModifiedAt: DateTime!
    "The User who last modified this entity."
    lastModifiedBy: User!
}

"Shared extensions to the node type."
interface BaseNode implements Node {
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
}

interface BasePermission implements BaseNode & Named & NamedNode & Node {
    "If, the permission is granted to all users. Use with caution."
    allUsers: Boolean!
    "The description of this entity."
    description: String!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "The name of this entity."
    name: String!
    "GropiusUsers granted this Permission"
    users(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: GropiusUserFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: GropiusUserOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): GropiusUserConnection!
}

"""
Base type for both Template and SubTemplate.
Defines templated fields with specific types (defined using JSON schema).
READ is always granted.

"""
interface BaseTemplate implements BaseNode & Named & NamedNode & Node {
    "The description of this entity."
    description: String!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "The name of this entity."
    name: String!
    "All template field specifications, if a `namePrefix` is provided, only those matching it"
    templateFieldSpecifications(
        "Name of the extension field."
        namePrefix: String
    ): [JSONField!]!
}

"""
Supertype for IssueComment and Body.
Represents a text block in the Timeline.
Keeps track when it was last edited and by who, but does not keep track of the change history.
READ is granted if READ is granted on `issue`.

"""
interface Comment implements AuditedNode & BaseNode & Node & TimelineItem {
    "IssueComments which answer this Comment."
    answeredBy(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: IssueCommentFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: IssueCommentOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): IssueCommentConnection!
    """
    The text of the Comment.
    Supports GFM (GitHub Flavored Markdown).
    Updates cause lastEditedAt and lastEditedBy to change.
    Empty String if IssueComment is deleted.

    """
    body: String!
    """
    Keep track when the body of the Comment was last updated.
    If not updated yet, the DateTime of creation.

    """
    bodyLastEditedAt: DateTime!
    """
    The User who last edited the body of this Comment.
    If not edited yet, the creator of the Comment.

    """
    bodyLastEditedBy: User!
    "The DateTime this entity was created at."
    createdAt: DateTime!
    "The User who created this entity."
    createdBy: User!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "The Issue this TimelineItem is part of."
    issue: Issue
    "The DateTime this entity was last modified at."
    lastModifiedAt: DateTime!
    "The User who last modified this entity."
    lastModifiedBy: User!
    "If existing, the parent TimelineItem"
    parentItem: ParentTimelineItem
}

"Interface for all types which support templates describing user writeable fields."
interface MutableTemplatedNode implements TemplatedNode {
    "Value of a field defined by the template. Error if such a field is not defined."
    templatedField(
        "Name of the extension field"
        name: String!
    ): JSON
    """
    All templatedFields
    If `names` is provided, only those matching the name. If `prefixMatching` is true, matching is done by
    prefix, otherwise by full name.

    """
    templatedFields(
        "Names of the templated fields. If not provided, all templatedFields."
        names: [String!],
        """
        If true, name matching is performed as prefix matching, otherwise as absolute match.
        Defaults to absolute matching

        """
        prefixMatching: Boolean
    ): [JSONField!]!
}

"Entity with a name and a description."
interface Named {
    "The description of this entity."
    description: String!
    "The name of this entity."
    name: String!
}

"AuditedNode with a name and description"
interface NamedAuditedNode implements AuditedNode & BaseNode & Named & Node {
    "The DateTime this entity was created at."
    createdAt: DateTime!
    "The User who created this entity."
    createdBy: User!
    "The description of this entity."
    description: String!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "The DateTime this entity was last modified at."
    lastModifiedAt: DateTime!
    "The User who last modified this entity."
    lastModifiedBy: User!
    "The name of this entity."
    name: String!
}

"Node with a name and description"
interface NamedNode implements BaseNode & Named & Node {
    "The description of this entity."
    description: String!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "The name of this entity."
    name: String!
}

"Base class of all nodes"
interface Node {
    "The unique id of this node"
    id: ID!
}

interface NodePermission implements BaseNode & BasePermission & Named & NamedNode & Node {
    "If, the permission is granted to all users. Use with caution."
    allUsers: Boolean!
    "The description of this entity."
    description: String!
    entries: [String!]!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "The name of this entity."
    name: String!
    "GropiusUsers granted this Permission"
    users(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: GropiusUserFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: GropiusUserOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): GropiusUserConnection!
}

"""
TimelineItem which can aggregate other TimelineItems.
READ is granted if READ is granted on `issue`.

"""
interface ParentTimelineItem implements AuditedNode & BaseNode & Node & TimelineItem {
    "Child TimelineItems. These are still part of the main timeline."
    childItems(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: TimelineItemFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: TimelineItemOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): TimelineItemConnection!
    "The DateTime this entity was created at."
    createdAt: DateTime!
    "The User who created this entity."
    createdBy: User!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "The Issue this TimelineItem is part of."
    issue: Issue
    "The DateTime this entity was last modified at."
    lastModifiedAt: DateTime!
    "The User who last modified this entity."
    lastModifiedBy: User!
    "If existing, the parent TimelineItem"
    parentItem: ParentTimelineItem
}

"Entity which can be used as start / end of Relations. Can be affected by Issues."
interface RelationPartner implements AffectedByIssue & BaseNode & Named & NamedNode & Node & TemplatedNode {
    "The issues which affect this entity"
    affectingIssues(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: IssueFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: IssueOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): IssueConnection!
    "AggregatedIssues on this RelationPartner."
    aggregatedIssues(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: AggregatedIssueFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: AggregatedIssueOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): AggregatedIssueConnection!
    "The description of this entity."
    description: String!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "Relations which use this as the end of the Relation."
    incomingRelations(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: RelationFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: RelationOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): RelationConnection!
    "The name of this entity."
    name: String!
    "Relations which use this as the start of the Relation."
    outgoingRelations(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: RelationFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: RelationOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): RelationConnection!
    "Value of a field defined by the template. Error if such a field is not defined."
    templatedField(
        "Name of the extension field"
        name: String!
    ): JSON
    """
    All templatedFields
    If `names` is provided, only those matching the name. If `prefixMatching` is true, matching is done by
    prefix, otherwise by full name.

    """
    templatedFields(
        "Names of the templated fields. If not provided, all templatedFields."
        names: [String!],
        """
        If true, name matching is performed as prefix matching, otherwise as absolute match.
        Defaults to absolute matching

        """
        prefixMatching: Boolean
    ): [JSONField!]!
}

"Template for RelationPartners."
interface RelationPartnerTemplate implements BaseNode & BaseTemplate & Named & NamedNode & Node & Template {
    "The description of this entity."
    description: String!
    "Style of the fill"
    fill: FillStyle
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "If true, this template is deprecated and cannot be used for new entities any more."
    isDeprecated: Boolean!
    "The name of this entity."
    name: String!
    "RelationConditions which allow this template for the end of the relation."
    possibleEndOfRelations(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: RelationConditionFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: RelationConditionOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): RelationConditionConnection!
    "RelationConditions which allow this template for the start of the relation."
    possibleStartOfRelations(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: RelationConditionFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: RelationConditionOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): RelationConditionConnection!
    "The corner radius of the shape, ignored for circle/ellipse."
    shapeRadius: Float
    "The type of the shape."
    shapeType: ShapeType!
    "Style of the stroke"
    stroke: StrokeStyle
    "All template field specifications, if a `namePrefix` is provided, only those matching it"
    templateFieldSpecifications(
        "Name of the extension field."
        namePrefix: String
    ): [JSONField!]!
}

"Event representing that the type of an IssueRelation changed."
interface RelationTypeChangedEvent implements AuditedNode & BaseNode & Node & TimelineItem {
    "The DateTime this entity was created at."
    createdAt: DateTime!
    "The User who created this entity."
    createdBy: User!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "The Issue this TimelineItem is part of."
    issue: Issue
    "The IssueRelation of which the type was changed"
    issueRelation: IssueRelation!
    "The DateTime this entity was last modified at."
    lastModifiedAt: DateTime!
    "The User who last modified this entity."
    lastModifiedBy: User!
    "The new type."
    newType: IssueRelationType
    "The old type."
    oldType: IssueRelationType
    "If existing, the parent TimelineItem"
    parentItem: ParentTimelineItem
}

"""
Event representing that an outgoing IssueRelation was removed.

"""
interface RemovedRelationEvent implements AuditedNode & BaseNode & Node & TimelineItem {
    "The DateTime this entity was created at."
    createdAt: DateTime!
    "The User who created this entity."
    createdBy: User!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "The Issue this TimelineItem is part of."
    issue: Issue
    "The DateTime this entity was last modified at."
    lastModifiedAt: DateTime!
    "The User who last modified this entity."
    lastModifiedBy: User!
    "If existing, the parent TimelineItem"
    parentItem: ParentTimelineItem
    "The removed IssueRelation, null if deleted."
    removedRelation: IssueRelation
}

"""
BaseTemplate which is part of a Template.
Defines templated fields with specific types (defined using JSON schema).
Does not provide any composition features, as composition is handled by the Template it is part of.

"""
interface SubTemplate implements BaseNode & BaseTemplate & Named & NamedNode & Node {
    "The description of this entity."
    description: String!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "The name of this entity."
    name: String!
    "All template field specifications, if a `namePrefix` is provided, only those matching it"
    templateFieldSpecifications(
        "Name of the extension field."
        namePrefix: String
    ): [JSONField!]!
}

"A target where users can configure how the sync should behave."
interface SyncPermissionTarget implements BaseNode & Named & NamedNode & Node {
    "The description of this entity."
    description: String!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "The name of this entity."
    name: String!
    "The users which allow to sync the data of other users to this target."
    syncOthersAllowedBy(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: GropiusUserFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: GropiusUserOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): GropiusUserConnection!
    "The users which allow to sync their data to this target."
    syncSelfAllowedBy(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: GropiusUserFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: GropiusUserOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): GropiusUserConnection!
}

"""
BaseTemplate with composition features.
Can have SubTemplates.
Defines templated fields with specific types (defined using JSON schema).

"""
interface Template implements BaseNode & BaseTemplate & Named & NamedNode & Node {
    "The description of this entity."
    description: String!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "If true, this template is deprecated and cannot be used for new entities any more."
    isDeprecated: Boolean!
    "The name of this entity."
    name: String!
    "All template field specifications, if a `namePrefix` is provided, only those matching it"
    templateFieldSpecifications(
        "Name of the extension field."
        namePrefix: String
    ): [JSONField!]!
}

"Interface for all types which support templates."
interface TemplatedNode {
    "Value of a field defined by the template. Error if such a field is not defined."
    templatedField(
        "Name of the extension field"
        name: String!
    ): JSON
    """
    All templatedFields
    If `names` is provided, only those matching the name. If `prefixMatching` is true, matching is done by
    prefix, otherwise by full name.

    """
    templatedFields(
        "Names of the templated fields. If not provided, all templatedFields."
        names: [String!],
        """
        If true, name matching is performed as prefix matching, otherwise as absolute match.
        Defaults to absolute matching

        """
        prefixMatching: Boolean
    ): [JSONField!]!
}

"Supertype of all timeline items. Always part of an Issue."
interface TimelineItem implements AuditedNode & BaseNode & Node {
    "The DateTime this entity was created at."
    createdAt: DateTime!
    "The User who created this entity."
    createdBy: User!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "The Issue this TimelineItem is part of."
    issue: Issue
    "The DateTime this entity was last modified at."
    lastModifiedAt: DateTime!
    "The User who last modified this entity."
    lastModifiedBy: User!
    "If existing, the parent TimelineItem"
    parentItem: ParentTimelineItem
}

"""
An entity which can have Issues, Labels and Artefacts.
Has pinned issues.
Can be synced to an IMS by creating an IMSProject.
Can be affected by Issues.

"""
interface Trackable implements AffectedByIssue & BaseNode & Named & NamedNode & Node {
    "The issues which affect this entity"
    affectingIssues(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: IssueFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: IssueOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): IssueConnection!
    "Artefacts of this trackable, typically some kind of file."
    artefacts(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: ArtefactFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: ArtefactOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): ArtefactConnection!
    "The description of this entity."
    description: String!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    """
    The set of Issues which are part of this Trackable.
    An Issue has to be part of a Trackable to use the Labels and Artefacts defined by the Trackable.

    """
    issues(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: IssueFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: IssueOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): IssueConnection!
    "The set of Labels which can be added to issues of this trackable."
    labels(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: LabelFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: LabelOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): LabelConnection!
    "The name of this entity."
    name: String!
    "Issues which are pinned to this trackable, subset of `issues`."
    pinnedIssues(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: IssueFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: IssueOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): IssueConnection!
    "If existing, the URL of the repository (e.g. a GitHub repository)."
    repositoryURL: URL
    "IMSProjects this Trackable is synced to and from."
    syncsTo(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: IMSProjectFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: IMSProjectOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): IMSProjectConnection!
}

"""
A user known to the Gropius System.
This might be a user that registered directly, or a user the systems know via a sync adapter.
A user can create AuditedNodes, participate in Issues and be assigned to Issues.
READ is always granted.

"""
interface User implements BaseNode & Node {
    "Assignments the user is part of, this includes assignments which aren't active."
    assignments(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: AssignmentFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: AssignmentOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): AssignmentConnection!
    "The avatar of the user."
    avatar: URL!
    "AuditedNodes the user created."
    createdNodes(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: AuditedNodeFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: AuditedNodeOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): AuditedNodeConnection!
    "The name which should be displayed for the user."
    displayName: String!
    "The email address of the user."
    email: String
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "Issues the user participated in."
    participatedIssues(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: IssueFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: IssueOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): IssueConnection!
    """
    The identifier of the user.
    This is only unique for GropiusUsers, for IMSUsers, no constrains v  are guaranteed.

    """
    username: String
}

"Entity with a version"
interface Versioned {
    "The version of this entity"
    version: String!
}

union BaseStyle = FillStyle | StrokeStyle

union PublicTimelineItem = AddedAffectedEntityEvent | AddedArtefactEvent | AddedLabelEvent | AddedToPinnedIssuesEvent | AddedToTrackableEvent | Assignment | AssignmentTypeChangedEvent | Body | DueDateChangedEvent | EstimatedTimeChangedEvent | IncomingRelationTypeChangedEvent | IssueComment | IssueRelation | OutgoingRelationTypeChangedEvent | PriorityChangedEvent | RemovedAffectedEntityEvent | RemovedArtefactEvent | RemovedAssignmentEvent | RemovedFromPinnedIssuesEvent | RemovedLabelEvent | RemovedTemplatedFieldEvent | SpentTimeChangedEvent | StartDateChangedEvent | StateChangedEvent | TemplatedFieldChangedEvent | TitleChangedEvent | TypeChangedEvent

union TrackablePermission = ComponentPermission | ProjectPermission

type AddAffectedEntityToIssuePayload {
    "The created event, if present"
    addedAffectedEntityEvent: AddedAffectedEntityEvent
}

type AddArtefactToIssuePayload {
    "The created event, if present"
    addedArtefactEvent: AddedArtefactEvent
}

"Payload type for the addComponentVersionToProject mutation"
type AddComponentVersionToProjectPayload {
    "The added component version"
    componentVersion: ComponentVersion!
    "The updated project"
    project: Project!
}

type AddInterfaceSpecificationVersionToComponentVersionPayload {
    "The updated ComponentVersion"
    componentVersion: ComponentVersion!
}

type AddIssueToPinnedIssuesPayload {
    "The created event, if present"
    addedToPinnedIssuesEvent: AddedToPinnedIssuesEvent
}

type AddIssueToTrackablePayload {
    "The created event, if present"
    addedToTrackableEvent: AddedToTrackableEvent
}

type AddLabelToIssuePayload {
    "The created event, if present"
    addedLabelEvent: AddedLabelEvent
}

type AddLabelToTrackablePayload {
    "The Trackable to which the Label was added"
    trackable: Trackable!
}

"""
Event representing that an entity is affected by an Issue.
READ is granted if READ is granted on `issue`.

"""
type AddedAffectedEntityEvent implements AuditedNode & BaseNode & Node & TimelineItem {
    "The entity affected by the Issue, null if deleted."
    addedAffectedEntity: AffectedByIssue
    "The DateTime this entity was created at."
    createdAt: DateTime!
    "The User who created this entity."
    createdBy: User!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "The Issue this TimelineItem is part of."
    issue: Issue
    "The DateTime this entity was last modified at."
    lastModifiedAt: DateTime!
    "The User who last modified this entity."
    lastModifiedBy: User!
    "If existing, the parent TimelineItem"
    parentItem: ParentTimelineItem
}

"""
Event representing that an Artefact was added to an Issue.
READ is granted if READ is granted on `issue`.

"""
type AddedArtefactEvent implements AuditedNode & BaseNode & Node & TimelineItem {
    "The Artefact added to the Issue, null if deleted."
    addedArtefact: Artefact
    "The DateTime this entity was created at."
    createdAt: DateTime!
    "The User who created this entity."
    createdBy: User!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "The Issue this TimelineItem is part of."
    issue: Issue
    "The DateTime this entity was last modified at."
    lastModifiedAt: DateTime!
    "The User who last modified this entity."
    lastModifiedBy: User!
    "If existing, the parent TimelineItem"
    parentItem: ParentTimelineItem
}

"""
Event representing that a Label was added to an Issue.
READ is granted if READ is granted on `issue`.

"""
type AddedLabelEvent implements AuditedNode & BaseNode & Node & TimelineItem {
    "The Label added to the Issue, null if deleted."
    addedLabel: Label
    "The DateTime this entity was created at."
    createdAt: DateTime!
    "The User who created this entity."
    createdBy: User!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "The Issue this TimelineItem is part of."
    issue: Issue
    "The DateTime this entity was last modified at."
    lastModifiedAt: DateTime!
    "The User who last modified this entity."
    lastModifiedBy: User!
    "If existing, the parent TimelineItem"
    parentItem: ParentTimelineItem
}

"""
Event representing that an Issue was pinned on a Trackable.
READ is granted if READ is granted on `issue`.

"""
type AddedToPinnedIssuesEvent implements AuditedNode & BaseNode & Node & TimelineItem {
    "The DateTime this entity was created at."
    createdAt: DateTime!
    "The User who created this entity."
    createdBy: User!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "The Issue this TimelineItem is part of."
    issue: Issue
    "The DateTime this entity was last modified at."
    lastModifiedAt: DateTime!
    "The User who last modified this entity."
    lastModifiedBy: User!
    "If existing, the parent TimelineItem"
    parentItem: ParentTimelineItem
    "The Trackable the Issue is now pinned on, null if deleted."
    pinnedOn: Trackable
}

"""
Event representing that the Issue was added to a Trackable.
READ is granted if READ is granted on `issue`.

"""
type AddedToTrackableEvent implements AuditedNode & BaseNode & Node & TimelineItem {
    "The Trackable the Issue was added to, null if deleted."
    addedToTrackable: Trackable
    "The DateTime this entity was created at."
    createdAt: DateTime!
    "The User who created this entity."
    createdBy: User!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "The Issue this TimelineItem is part of."
    issue: Issue
    "The DateTime this entity was last modified at."
    lastModifiedAt: DateTime!
    "The User who last modified this entity."
    lastModifiedBy: User!
    "If existing, the parent TimelineItem"
    parentItem: ParentTimelineItem
}

"The connection type for AffectedByIssue."
type AffectedByIssueConnection {
    "A list of all edges of the current page."
    edges: [AffectedByIssueEdge!]!
    "A list of all nodes of the current page."
    nodes: [AffectedByIssue!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "Identifies the total count of items in the connection."
    totalCount: Int!
}

"An edge in a connection."
type AffectedByIssueEdge {
    "A cursor used in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: AffectedByIssue!
}

"""
An aggregated Issue on a RelationPartner.
READ is granted if READ is granted on `relationPartner`.
An Issue is aggregated on a ComponentVersion if
- it affects the ComponentVersion
- it affects the associated Component
- it is on the Component, and does not affect anything
An Issue is aggregated on a Interface if
- it affects the associated InterfaceSpecificationVersion
- it affects the associated InterfaceSpecification
- it affects any InterfacePart of the associated InterfaceSpecificationVersion

"""
type AggregatedIssue implements BaseNode & Node {
    "The amount of Issues of this type on this location."
    count: Int!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "IssueRelations from this aggregated issue to other aggregated issues."
    incomingRelations(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: AggregatedIssueRelationFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: AggregatedIssueRelationOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): AggregatedIssueRelationConnection!
    "If aggregated issues are open or closed."
    isOpen: Boolean!
    "The Issues aggregated by this AggregatedIssue."
    issues(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: IssueFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: IssueOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): IssueConnection!
    "IssueRelations from other aggregated issues to this aggregated issue."
    outgoingRelations(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: AggregatedIssueRelationFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: AggregatedIssueRelationOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): AggregatedIssueRelationConnection!
    "The RelationPartner this AggregatedIssue is on."
    relationPartner: RelationPartner!
    "The IssueType of this AggregatedIssue."
    type: IssueType!
}

"The connection type for AggregatedIssue."
type AggregatedIssueConnection {
    "A list of all edges of the current page."
    edges: [AggregatedIssueEdge!]!
    "A list of all nodes of the current page."
    nodes: [AggregatedIssue!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "Identifies the total count of items in the connection."
    totalCount: Int!
}

"An edge in a connection."
type AggregatedIssueEdge {
    "A cursor used in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: AggregatedIssue!
}

"""
An aggregated IssueRelation.
IssueRelations are aggregated by both start and end Issue.

"""
type AggregatedIssueRelation implements BaseNode & Node {
    count: Int!
    "The end of this AggregatedIssueRelation."
    end: AggregatedIssue!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "The IssueRelations aggregated by this AggregatedIssueRelation."
    issueRelations(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: IssueRelationFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: IssueRelationOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): IssueRelationConnection!
    "The start of this AggregatedIssueRelation."
    start: AggregatedIssue!
    "The IssueType of this AggregatedIssue."
    type: IssueRelationType
}

"The connection type for AggregatedIssueRelation."
type AggregatedIssueRelationConnection {
    "A list of all edges of the current page."
    edges: [AggregatedIssueRelationEdge!]!
    "A list of all nodes of the current page."
    nodes: [AggregatedIssueRelation!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "Identifies the total count of items in the connection."
    totalCount: Int!
}

"An edge in a connection."
type AggregatedIssueRelationEdge {
    "A cursor used in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: AggregatedIssueRelation!
}

"""
An Artefact referencing a file defined via a URL.
Can optionally specify a line range (from - to), and a version.
Is part of exactly one Trackable.
Can be referenced by Comments and Issues.
Artefacts are synced to all IMSProjects of the Trackable they are part of.
READ is granted if READ is granted on `trackable`.

"""
type Artefact implements AuditedNode & BaseNode & MutableTemplatedNode & Node & TemplatedNode {
    "The DateTime this entity was created at."
    createdAt: DateTime!
    "The User who created this entity."
    createdBy: User!
    "A URL to the file this Artefact references"
    file: URL!
    "If present, the first line of the file this Artefact references, inclusive"
    from: Int
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "Issues which currently have this Artefact."
    issues(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: IssueFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: IssueOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): IssueConnection!
    "The DateTime this entity was last modified at."
    lastModifiedAt: DateTime!
    "The User who last modified this entity."
    lastModifiedBy: User!
    "IssueComments which currently reference this Artefact."
    referencingComments(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: IssueCommentFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: IssueCommentOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): IssueCommentConnection!
    "The Template of this Artefact."
    template: ArtefactTemplate!
    "Value of a field defined by the template. Error if such a field is not defined."
    templatedField(
        "Name of the extension field"
        name: String!
    ): JSON
    """
    All templatedFields
    If `names` is provided, only those matching the name. If `prefixMatching` is true, matching is done by
    prefix, otherwise by full name.

    """
    templatedFields(
        "Names of the templated fields. If not provided, all templatedFields."
        names: [String!],
        """
        If true, name matching is performed as prefix matching, otherwise as absolute match.
        Defaults to absolute matching

        """
        prefixMatching: Boolean
    ): [JSONField!]!
    "If present, the last line of the file this Artefact references, inclusive"
    to: Int
    "The Trackable this Artefact is part of."
    trackable: Trackable!
    "If present, the current version of this Artefact"
    version: String
}

"The connection type for Artefact."
type ArtefactConnection {
    "A list of all edges of the current page."
    edges: [ArtefactEdge!]!
    "A list of all nodes of the current page."
    nodes: [Artefact!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "Identifies the total count of items in the connection."
    totalCount: Int!
}

"An edge in a connection."
type ArtefactEdge {
    "A cursor used in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Artefact!
}

"""
Template for Artefacts
Defines templated fields with specific types (defined using JSON schema).

"""
type ArtefactTemplate implements BaseNode & BaseTemplate & Named & NamedNode & Node & Template {
    "The description of this entity."
    description: String!
    "Templates that extend this template."
    extendedBy(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: ArtefactTemplateFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: ArtefactTemplateOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): ArtefactTemplateConnection!
    "Template this template extends."
    extends(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: ArtefactTemplateFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: ArtefactTemplateOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): ArtefactTemplateConnection!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "If true, this template is deprecated and cannot be used for new entities any more."
    isDeprecated: Boolean!
    "The name of this entity."
    name: String!
    "All template field specifications, if a `namePrefix` is provided, only those matching it"
    templateFieldSpecifications(
        "Name of the extension field."
        namePrefix: String
    ): [JSONField!]!
    "Entities which use this template."
    usedIn(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: ArtefactFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: ArtefactOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): ArtefactConnection!
}

"The connection type for ArtefactTemplate."
type ArtefactTemplateConnection {
    "A list of all edges of the current page."
    edges: [ArtefactTemplateEdge!]!
    "A list of all nodes of the current page."
    nodes: [ArtefactTemplate!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "Identifies the total count of items in the connection."
    totalCount: Int!
}

"An edge in a connection."
type ArtefactTemplateEdge {
    "A cursor used in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: ArtefactTemplate!
}

"""
Event representing that a User is assigned to an Issue.
An Assignment is only active if it is still in `assignments` on Issue.
READ is granted if READ is granted on `issue`.

"""
type Assignment implements AuditedNode & BaseNode & Node & TimelineItem {
    "The DateTime this entity was created at."
    createdAt: DateTime!
    "The User who created this entity."
    createdBy: User!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "The Issue this TimelineItem is part of."
    issue: Issue
    "The DateTime this entity was last modified at."
    lastModifiedAt: DateTime!
    "The User who last modified this entity."
    lastModifiedBy: User!
    "If existing, the parent TimelineItem"
    parentItem: ParentTimelineItem
    "The type of Assignment, e.g. REVIEWER. Allowed types are defined by the IssueTemplate."
    type: AssignmentType
    "The User assigned to the Issue."
    user: User!
}

"The connection type for Assignment."
type AssignmentConnection {
    "A list of all edges of the current page."
    edges: [AssignmentEdge!]!
    "A list of all nodes of the current page."
    nodes: [Assignment!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "Identifies the total count of items in the connection."
    totalCount: Int!
}

"An edge in a connection."
type AssignmentEdge {
    "A cursor used in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Assignment!
}

"""
Type for an Assignment, like REVIEWER. Part of an IssueTemplate.
READ is always granted.

"""
type AssignmentType implements BaseNode & Named & NamedNode & Node {
    "Assignments which use this type."
    assignmentsWithType(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: AssignmentFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: AssignmentOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): AssignmentConnection!
    "The description of this entity."
    description: String!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "The name of this entity."
    name: String!
    "IssueTemplates this is part of."
    partOf(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: IssueTemplateFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: IssueTemplateOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): IssueTemplateConnection!
}

"""
Event representing that the type of an Assignment changed.
READ is granted if READ is granted on `issue`.

"""
type AssignmentTypeChangedEvent implements AuditedNode & BaseNode & Node & TimelineItem {
    "The Assignment of which the type was changed"
    assignment: Assignment!
    "The DateTime this entity was created at."
    createdAt: DateTime!
    "The User who created this entity."
    createdBy: User!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "The Issue this TimelineItem is part of."
    issue: Issue
    "The DateTime this entity was last modified at."
    lastModifiedAt: DateTime!
    "The User who last modified this entity."
    lastModifiedBy: User!
    "The new type."
    newType: AssignmentType
    "The old type."
    oldType: AssignmentType
    "If existing, the parent TimelineItem"
    parentItem: ParentTimelineItem
}

"The connection type for AssignmentType."
type AssignmentTypeConnection {
    "A list of all edges of the current page."
    edges: [AssignmentTypeEdge!]!
    "A list of all nodes of the current page."
    nodes: [AssignmentType!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "Identifies the total count of items in the connection."
    totalCount: Int!
}

"An edge in a connection."
type AssignmentTypeEdge {
    "A cursor used in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: AssignmentType!
}

"The connection type for AuditedNode."
type AuditedNodeConnection {
    "A list of all edges of the current page."
    edges: [AuditedNodeEdge!]!
    "A list of all nodes of the current page."
    nodes: [AuditedNode!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "Identifies the total count of items in the connection."
    totalCount: Int!
}

"An edge in a connection."
type AuditedNodeEdge {
    "A cursor used in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: AuditedNode!
}

"The connection type for BasePermission."
type BasePermissionConnection {
    "A list of all edges of the current page."
    edges: [BasePermissionEdge!]!
    "A list of all nodes of the current page."
    nodes: [BasePermission!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "Identifies the total count of items in the connection."
    totalCount: Int!
}

"An edge in a connection."
type BasePermissionEdge {
    "A cursor used in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: BasePermission!
}

"""
Main Body of an Issue.
Each Issue has exactly one Body. Keeps track when it was last edited and by who, but does not keep track of the change history.
READ is granted if READ is granted on `issue`.

"""
type Body implements AuditedNode & BaseNode & Comment & Node & TimelineItem {
    "IssueComments which answer this Comment."
    answeredBy(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: IssueCommentFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: IssueCommentOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): IssueCommentConnection!
    """
    The text of the Comment.
    Supports GFM (GitHub Flavored Markdown).
    Updates cause lastEditedAt and lastEditedBy to change.
    Empty String if IssueComment is deleted.

    """
    body: String!
    """
    Keep track when the body of the Comment was last updated.
    If not updated yet, the DateTime of creation.

    """
    bodyLastEditedAt: DateTime!
    """
    The User who last edited the body of this Comment.
    If not edited yet, the creator of the Comment.

    """
    bodyLastEditedBy: User!
    "The DateTime this entity was created at."
    createdAt: DateTime!
    "The User who created this entity."
    createdBy: User!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "The Issue this TimelineItem is part of."
    issue: Issue
    "The DateTime this entity was last modified at."
    lastModifiedAt: DateTime!
    "The User who last modified this entity."
    lastModifiedBy: User!
    "If existing, the parent TimelineItem"
    parentItem: ParentTimelineItem
}

type ChangeAssignmentTypePayload {
    "The created event, if present"
    assignmentTypeChangedEvent: AssignmentTypeChangedEvent
}

type ChangeIssueDueDatePayload {
    "The created event, if present"
    dueDateChangedEvent: DueDateChangedEvent
}

type ChangeIssueEstimatedTimePayload {
    "The created event, if present"
    estimatedTimeChangedEvent: EstimatedTimeChangedEvent
}

type ChangeIssuePriorityPayload {
    "The created event, if present"
    priorityChangedEvent: PriorityChangedEvent
}

type ChangeIssueRelationTypePayload {
    "The created event, if present"
    outgoingRelationTypeChangedEvent: OutgoingRelationTypeChangedEvent
}

type ChangeIssueSpentTimePayload {
    "The created event, if present"
    spentTimeChangedEvent: SpentTimeChangedEvent
}

type ChangeIssueStartDatePayload {
    "The created event, if present"
    startDateChangedEvent: StartDateChangedEvent
}

type ChangeIssueStatePayload {
    "The created event, if present"
    stateChangedEvent: StateChangedEvent
}

type ChangeIssueTemplatePayload {
    "The created event, if present"
    templateChangedEvent: TemplateChangedEvent
}

type ChangeIssueTemplatedFieldPayload {
    "The created event, if present"
    templatedFieldChangedEvent: TemplatedFieldChangedEvent
}

type ChangeIssueTitlePayload {
    "The created event, if present"
    titleChangedEvent: TitleChangedEvent
}

type ChangeIssueTypePayload {
    "The created event, if present"
    typeChangedEvent: TypeChangedEvent
}

"""
Entity which represents a software component, e.g. a library, a microservice, or a deployment platform, ....
The type of software component is defined by the template.
Can have issues, labels and artefacts as this is a Trackable.
Defines InterfaceSpecifications, but visible/invisible InterfaceSpecificationVersions depend on the ComponentVersion.
Can be affected by Issues.
READ is granted via an associated ComponentPermission or if READ is granted on any Project including any
ComponentVersion in `versions` of this Component.

"""
type Component implements AffectedByIssue & BaseNode & MutableTemplatedNode & Named & NamedNode & Node & TemplatedNode & Trackable {
    "The issues which affect this entity"
    affectingIssues(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: IssueFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: IssueOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): IssueConnection!
    "Artefacts of this trackable, typically some kind of file."
    artefacts(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: ArtefactFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: ArtefactOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): ArtefactConnection!
    "The description of this entity."
    description: String!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    """
    List of interfaces this component specifies.
    Note that visible/invisible InterfaceSpecifications are defined by a specific version of this component

    """
    interfaceSpecifications(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: InterfaceSpecificationFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: InterfaceSpecificationOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): InterfaceSpecificationConnection!
    """
    The set of Issues which are part of this Trackable.
    An Issue has to be part of a Trackable to use the Labels and Artefacts defined by the Trackable.

    """
    issues(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: IssueFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: IssueOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): IssueConnection!
    "The set of Labels which can be added to issues of this trackable."
    labels(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: LabelFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: LabelOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): LabelConnection!
    "The name of this entity."
    name: String!
    "Permissions for this Component."
    permissions(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: ComponentPermissionFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: ComponentPermissionOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): ComponentPermissionConnection!
    "Issues which are pinned to this trackable, subset of `issues`."
    pinnedIssues(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: IssueFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: IssueOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): IssueConnection!
    "If existing, the URL of the repository (e.g. a GitHub repository)."
    repositoryURL: URL
    "IMSProjects this Trackable is synced to and from."
    syncsTo(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: IMSProjectFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: IMSProjectOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): IMSProjectConnection!
    "The Template of this Component."
    template: ComponentTemplate!
    "Value of a field defined by the template. Error if such a field is not defined."
    templatedField(
        "Name of the extension field"
        name: String!
    ): JSON
    """
    All templatedFields
    If `names` is provided, only those matching the name. If `prefixMatching` is true, matching is done by
    prefix, otherwise by full name.

    """
    templatedFields(
        "Names of the templated fields. If not provided, all templatedFields."
        names: [String!],
        """
        If true, name matching is performed as prefix matching, otherwise as absolute match.
        Defaults to absolute matching

        """
        prefixMatching: Boolean
    ): [JSONField!]!
    "Versions of this components."
    versions(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: ComponentVersionFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: ComponentVersionOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): ComponentVersionConnection!
}

"The connection type for Component."
type ComponentConnection {
    "A list of all edges of the current page."
    edges: [ComponentEdge!]!
    "A list of all nodes of the current page."
    nodes: [Component!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "Identifies the total count of items in the connection."
    totalCount: Int!
}

"An edge in a connection."
type ComponentEdge {
    "A cursor used in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Component!
}

"NodePermission to grant specific permissions to a set of Components."
type ComponentPermission implements BaseNode & BasePermission & Named & NamedNode & Node {
    "If, the permission is granted to all users. Use with caution."
    allUsers: Boolean!
    "The description of this entity."
    description: String!
    "All permissions this Permission grants"
    entries: [ComponentPermissionEntry!]!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "The name of this entity."
    name: String!
    "Nodes on which the Permission is granted."
    nodesWithPermission(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: ComponentFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: ComponentOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): ComponentConnection!
    "GropiusUsers granted this Permission"
    users(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: GropiusUserFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: GropiusUserOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): GropiusUserConnection!
}

"The connection type for ComponentPermission."
type ComponentPermissionConnection {
    "A list of all edges of the current page."
    edges: [ComponentPermissionEdge!]!
    "A list of all nodes of the current page."
    nodes: [ComponentPermission!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "Identifies the total count of items in the connection."
    totalCount: Int!
}

"An edge in a connection."
type ComponentPermissionEdge {
    "A cursor used in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: ComponentPermission!
}

"""
Template for Components.
Defines templated fields with specific types (defined using JSON schema).
Defines SubTemplate for ComponentVersions.

"""
type ComponentTemplate implements BaseNode & BaseTemplate & Named & NamedNode & Node & RelationPartnerTemplate & Template {
    "SubTemplate applied to all ComponentVersions of Components with this Template"
    componentVersionTemplate: ComponentVersionTemplate!
    "The description of this entity."
    description: String!
    "Templates that extend this template."
    extendedBy(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: ComponentTemplateFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: ComponentTemplateOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): ComponentTemplateConnection!
    "Template this template extends."
    extends(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: ComponentTemplateFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: ComponentTemplateOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): ComponentTemplateConnection!
    "Style of the fill"
    fill: FillStyle
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "If true, this template is deprecated and cannot be used for new entities any more."
    isDeprecated: Boolean!
    "The name of this entity."
    name: String!
    "RelationConditions which allow this template for the end of the relation."
    possibleEndOfRelations(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: RelationConditionFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: RelationConditionOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): RelationConditionConnection!
    "Templates of InterfaceSpecifications which can be invisible on Components with this Template."
    possibleInvisibleInterfaceSpecifications(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: InterfaceSpecificationTemplateFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: InterfaceSpecificationTemplateOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): InterfaceSpecificationTemplateConnection!
    "RelationConditions which allow this template for the start of the relation."
    possibleStartOfRelations(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: RelationConditionFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: RelationConditionOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): RelationConditionConnection!
    "Templates of InterfaceSpecifications which can be visible on Components with this Template."
    possibleVisibleInterfaceSpecifications(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: InterfaceSpecificationTemplateFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: InterfaceSpecificationTemplateOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): InterfaceSpecificationTemplateConnection!
    shapeRadius: Float
    shapeType: ShapeType!
    "Style of the stroke"
    stroke: StrokeStyle
    "All template field specifications, if a `namePrefix` is provided, only those matching it"
    templateFieldSpecifications(
        "Name of the extension field."
        namePrefix: String
    ): [JSONField!]!
    "Entities which use this template."
    usedIn(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: ComponentFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: ComponentOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): ComponentConnection!
}

"The connection type for ComponentTemplate."
type ComponentTemplateConnection {
    "A list of all edges of the current page."
    edges: [ComponentTemplateEdge!]!
    "A list of all nodes of the current page."
    nodes: [ComponentTemplate!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "Identifies the total count of items in the connection."
    totalCount: Int!
}

"An edge in a connection."
type ComponentTemplateEdge {
    "A cursor used in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: ComponentTemplate!
}

"""
Version of a component.
Can specifies visible/invisible InterfaceSpecifications.
Can be used in Relations, affected by issues and included by Projects.
READ is granted if READ is granted on `component`.

"""
type ComponentVersion implements AffectedByIssue & BaseNode & MutableTemplatedNode & Named & NamedNode & Node & RelationPartner & TemplatedNode & Versioned {
    "The issues which affect this entity"
    affectingIssues(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: IssueFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: IssueOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): IssueConnection!
    "AggregatedIssues on this RelationPartner."
    aggregatedIssues(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: AggregatedIssueFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: AggregatedIssueOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): AggregatedIssueConnection!
    "The Component which defines this ComponentVersions"
    component: Component!
    "The description of this entity."
    description: String!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "Projects which include this ComponentVersion"
    includingProjects(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: ProjectFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: ProjectOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): ProjectConnection!
    "Relations which use this as the end of the Relation."
    incomingRelations(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: RelationFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: RelationOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): RelationConnection!
    "InterfaceDefinitions on this ComponentVersion."
    interfaceDefinitions(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: InterfaceDefinitionFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: InterfaceDefinitionOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): InterfaceDefinitionConnection!
    "IntraComponentDependencySpecifications associated with this ComponentVersion"
    intraComponentDependencySpecifications(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: IntraComponentDependencySpecificationFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: IntraComponentDependencySpecificationOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): IntraComponentDependencySpecificationConnection!
    "The name of this entity."
    name: String!
    "Relations which use this as the start of the Relation."
    outgoingRelations(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: RelationFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: RelationOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): RelationConnection!
    "The Template of this ComponentVersion"
    template: ComponentVersionTemplate!
    "Value of a field defined by the template. Error if such a field is not defined."
    templatedField(
        "Name of the extension field"
        name: String!
    ): JSON
    """
    All templatedFields
    If `names` is provided, only those matching the name. If `prefixMatching` is true, matching is done by
    prefix, otherwise by full name.

    """
    templatedFields(
        "Names of the templated fields. If not provided, all templatedFields."
        names: [String!],
        """
        If true, name matching is performed as prefix matching, otherwise as absolute match.
        Defaults to absolute matching

        """
        prefixMatching: Boolean
    ): [JSONField!]!
    "The version of this ComponentVersion"
    version: String!
}

"The connection type for ComponentVersion."
type ComponentVersionConnection {
    "A list of all edges of the current page."
    edges: [ComponentVersionEdge!]!
    "A list of all nodes of the current page."
    nodes: [ComponentVersion!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "Identifies the total count of items in the connection."
    totalCount: Int!
}

"An edge in a connection."
type ComponentVersionEdge {
    "A cursor used in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: ComponentVersion!
}

"""
SubTemplate for ComponentVersion.
Part of a ComponentTemplate.
Defines templated fields with specific types (defined using JSON schema).

"""
type ComponentVersionTemplate implements BaseNode & BaseTemplate & Named & NamedNode & Node & SubTemplate {
    "The description of this entity."
    description: String!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "The name of this entity."
    name: String!
    "The Template this SubTemplate is part of"
    partOf: ComponentTemplate!
    "All template field specifications, if a `namePrefix` is provided, only those matching it"
    templateFieldSpecifications(
        "Name of the extension field."
        namePrefix: String
    ): [JSONField!]!
    "Entities which use this template."
    usedIn(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: ComponentVersionFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: ComponentVersionOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): ComponentVersionConnection!
}

type CreateArtefactPayload {
    "The created Artefact"
    artefact: Artefact!
}

type CreateArtefactTemplatePayload {
    "The created ArtefactTemplate"
    artefactTemplate: ArtefactTemplate!
}

type CreateAssignmentPayload {
    "The created Assignment"
    assignment: Assignment!
}

type CreateComponentPayload {
    "The created Component"
    component: Component!
}

type CreateComponentPermissionPayload {
    "The created ComponentPermission"
    componentPermission: ComponentPermission!
}

type CreateComponentTemplatePayload {
    "The created ComponentTemplate"
    componentTemplate: ComponentTemplate!
}

type CreateComponentVersionPayload {
    "The created ComponentVersion"
    componentVersion: ComponentVersion!
}

type CreateGlobalPermissionPayload {
    "The created GlobalPermission"
    globalPermission: GlobalPermission!
}

type CreateIMSPayload {
    "The created IMS"
    ims: IMS!
}

type CreateIMSPermissionPayload {
    "The created IMSPermission"
    imsPermission: IMSPermission!
}

type CreateIMSProjectPayload {
    "The created IMSProject"
    imsProject: IMSProject!
}

type CreateInterfacePartPayload {
    "The created InterfacePart"
    interfacePart: InterfacePart!
}

type CreateInterfaceSpecificationPayload {
    "The created InterfaceSpecification"
    interfaceSpecification: InterfaceSpecification!
}

type CreateInterfaceSpecificationTemplatePayload {
    "The created InterfaceTemplate"
    interfaceSpecificationTemplate: InterfaceSpecificationTemplate!
}

type CreateInterfaceSpecificationVersionPayload {
    "The created InterfaceSpecificationVersion"
    interfaceSpecificationVersion: InterfaceSpecificationVersion!
}

type CreateIntraComponentDependencySpecificationPayload {
    "The created IntraComponentDependencySpecification"
    intraComponentDependencySpecification: IntraComponentDependencySpecification!
}

type CreateIssueCommentPayload {
    "The created IssueComment"
    issueComment: IssueComment!
}

type CreateIssuePayload {
    "The created Issue"
    issue: Issue!
}

type CreateIssueRelationPayload {
    "The created IssueRelation"
    issueRelation: IssueRelation!
}

type CreateIssueTemplatePayload {
    "The created IssueTemplate"
    issueTemplate: IssueTemplate!
}

type CreateLabelPayload {
    "The created Label"
    label: Label!
}

type CreateProjectPayload {
    "The created Project"
    project: Project!
}

type CreateProjectPermissionPayload {
    "The created ProjectPermission"
    projectPermission: ProjectPermission!
}

type CreateRelationPayload {
    "The created Relation"
    relation: Relation!
}

type CreateRelationTemplatePayload {
    "The created RelationTemplate"
    relationTemplate: RelationTemplate!
}

type DeleteIssueCommentPayload {
    "The updated IssueComment"
    issueComment: IssueComment!
}

"Payload type for delete node mutations"
type DeleteNodePayload {
    "The id of the deleted Node"
    id: ID!
}

"""
Event representing that the due date of an Issue changed.
READ is granted if READ is granted on `issue`.

"""
type DueDateChangedEvent implements AuditedNode & BaseNode & Node & TimelineItem {
    "The DateTime this entity was created at."
    createdAt: DateTime!
    "The User who created this entity."
    createdBy: User!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "The Issue this TimelineItem is part of."
    issue: Issue
    "The DateTime this entity was last modified at."
    lastModifiedAt: DateTime!
    "The User who last modified this entity."
    lastModifiedBy: User!
    "The new due date."
    newDueDate: DateTime
    "The old due date."
    oldDueDate: DateTime
    "If existing, the parent TimelineItem"
    parentItem: ParentTimelineItem
}

"""
Event representing that the estimated time of an Issue changed.
READ is granted if READ is granted on `issue`.

"""
type EstimatedTimeChangedEvent implements AuditedNode & BaseNode & Node & TimelineItem {
    "The DateTime this entity was created at."
    createdAt: DateTime!
    "The User who created this entity."
    createdBy: User!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "The Issue this TimelineItem is part of."
    issue: Issue
    "The DateTime this entity was last modified at."
    lastModifiedAt: DateTime!
    "The User who last modified this entity."
    lastModifiedBy: User!
    "The new estimated time of the Issue."
    newEstimatedTime: Duration
    "The old estimated time of the Issue."
    oldEstimatedTime: Duration
    "If existing, the parent TimelineItem"
    parentItem: ParentTimelineItem
}

"Fill style of a shape"
type FillStyle implements BaseNode & Node {
    "The color of the fill"
    color: String!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
}

"""
Permission associated with a set of users.
Can have NodePermissions to grant permissions on specific Nodes.
READ is granted if the global admin is granted.

"""
type GlobalPermission implements BaseNode & BasePermission & Named & NamedNode & Node {
    "If, the permission is granted to all users. Use with caution."
    allUsers: Boolean!
    "The description of this entity."
    description: String!
    "All permissions this Permission grants"
    entries: [PermissionEntry!]!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "The name of this entity."
    name: String!
    "GropiusUsers granted this Permission"
    users(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: GropiusUserFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: GropiusUserOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): GropiusUserConnection!
}

"""
A user of the Gropius System.
The username can be used as unique identifier for GropiusUsers.
IMSUsers can be linked to a GropiusUser.
Note however that this link does not affect relationships, e.g. if an IMSUser is part of an Assignment,
after the IMSUser was linked to a GropiusUser, the GropiusUser does not link directly to the Assignment.
Therefore, to collect all Assignments, Issue participations etc. it is necessary to also request all
linked IMSUsers and their Assignments etc.

"""
type GropiusUser implements BaseNode & Node & User {
    "Assignments the user is part of, this includes assignments which aren't active."
    assignments(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: AssignmentFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: AssignmentOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): AssignmentConnection!
    "The avatar of the user."
    avatar: URL!
    "The IMSSyncPermissionTarget this users allow to sync content of other users."
    canSyncOthers(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: SyncPermissionTargetFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: SyncPermissionTargetOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): SyncPermissionTargetConnection!
    "The UserSyncPermissionTarget this users allow to sync content of this user."
    canSyncSelf(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: SyncPermissionTargetFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: SyncPermissionTargetOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): SyncPermissionTargetConnection!
    "AuditedNodes the user created."
    createdNodes(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: AuditedNodeFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: AuditedNodeOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): AuditedNodeConnection!
    "The name which should be displayed for the user."
    displayName: String!
    "The email address of the user."
    email: String
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "The IMSUsers linked to this GropiusUser."
    imsUsers(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: IMSUserFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: IMSUserOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): IMSUserConnection!
    "True if the user is an admin"
    isAdmin: Boolean!
    "Issues the user participated in."
    participatedIssues(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: IssueFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: IssueOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): IssueConnection!
    "Permissions the user has."
    permissions(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: BasePermissionFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: BasePermissionOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): BasePermissionConnection!
    "A unique identifier for the GropiusUser. Note that this might not be unique across all Users."
    username: String!
}

"The connection type for GropiusUser."
type GropiusUserConnection {
    "A list of all edges of the current page."
    edges: [GropiusUserEdge!]!
    "A list of all nodes of the current page."
    nodes: [GropiusUser!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "Identifies the total count of items in the connection."
    totalCount: Int!
}

"An edge in a connection."
type GropiusUserEdge {
    "A cursor used in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: GropiusUser!
}

"""
Entity which represents an issue management system (like GitHub, Jira, Redmine, ...).
Trackables can be added to this via an IMSProject, so that their issues are synced to this IMS.
READ is granted via an associated IMSPermission.

"""
type IMS implements BaseNode & MutableTemplatedNode & Named & NamedNode & Node & SyncPermissionTarget & TemplatedNode {
    "The description of this entity."
    description: String!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "The name of this entity."
    name: String!
    "Permissions for this IMS."
    permissions(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: IMSPermissionFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: IMSPermissionOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): IMSPermissionConnection!
    "Projects which are synced to this IMS."
    projects(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: IMSProjectFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: IMSProjectOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): IMSProjectConnection!
    "The users which allow to sync the data of other users to this target."
    syncOthersAllowedBy(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: GropiusUserFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: GropiusUserOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): GropiusUserConnection!
    "The users which allow to sync their data to this target."
    syncSelfAllowedBy(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: GropiusUserFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: GropiusUserOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): GropiusUserConnection!
    "The Template of this Component."
    template: IMSTemplate!
    "Value of a field defined by the template. Error if such a field is not defined."
    templatedField(
        "Name of the extension field"
        name: String!
    ): JSON
    """
    All templatedFields
    If `names` is provided, only those matching the name. If `prefixMatching` is true, matching is done by
    prefix, otherwise by full name.

    """
    templatedFields(
        "Names of the templated fields. If not provided, all templatedFields."
        names: [String!],
        """
        If true, name matching is performed as prefix matching, otherwise as absolute match.
        Defaults to absolute matching

        """
        prefixMatching: Boolean
    ): [JSONField!]!
    "Users of this IMS."
    users(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: IMSUserFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: IMSUserOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): IMSUserConnection!
}

"The connection type for IMS."
type IMSConnection {
    "A list of all edges of the current page."
    edges: [IMSEdge!]!
    "A list of all nodes of the current page."
    nodes: [IMS!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "Identifies the total count of items in the connection."
    totalCount: Int!
}

"An edge in a connection."
type IMSEdge {
    "A cursor used in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: IMS!
}

"""
Issue on an IMS, represents an Issue synced to an IMS.
The representation of the Issue on the IMS depends on the type of IMS.
READ is granted if read is granted on `issue`.

"""
type IMSIssue implements BaseNode & Node & TemplatedNode {
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "The IMSProject the issue is synced with."
    imsProject: IMSProject!
    "The Issue that is synced by the IMSProject"
    issue: Issue!
    "The Template of this Component."
    template: IMSIssueTemplate!
    "Value of a field defined by the template. Error if such a field is not defined."
    templatedField(
        "Name of the extension field"
        name: String!
    ): JSON
    """
    All templatedFields
    If `names` is provided, only those matching the name. If `prefixMatching` is true, matching is done by
    prefix, otherwise by full name.

    """
    templatedFields(
        "Names of the templated fields. If not provided, all templatedFields."
        names: [String!],
        """
        If true, name matching is performed as prefix matching, otherwise as absolute match.
        Defaults to absolute matching

        """
        prefixMatching: Boolean
    ): [JSONField!]!
}

"The connection type for IMSIssue."
type IMSIssueConnection {
    "A list of all edges of the current page."
    edges: [IMSIssueEdge!]!
    "A list of all nodes of the current page."
    nodes: [IMSIssue!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "Identifies the total count of items in the connection."
    totalCount: Int!
}

"An edge in a connection."
type IMSIssueEdge {
    "A cursor used in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: IMSIssue!
}

"""
SubTemplate for IMSIssue.
Part of a IMSTemplate.
Defines templated fields with specific types (defined using JSON schema).

"""
type IMSIssueTemplate implements BaseNode & BaseTemplate & Named & NamedNode & Node & SubTemplate {
    "The description of this entity."
    description: String!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "The name of this entity."
    name: String!
    "The Template this SubTemplate is part of"
    partOf: IMSTemplate!
    "All template field specifications, if a `namePrefix` is provided, only those matching it"
    templateFieldSpecifications(
        "Name of the extension field."
        namePrefix: String
    ): [JSONField!]!
    "Entities which use this template."
    usedIn(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: IMSIssueFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: IMSIssueOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): IMSIssueConnection!
}

"NodePermission to grant specific permissions to a set of IMSs."
type IMSPermission implements BaseNode & BasePermission & Named & NamedNode & Node {
    "If, the permission is granted to all users. Use with caution."
    allUsers: Boolean!
    "The description of this entity."
    description: String!
    "All permissions this Permission grants"
    entries: [IMSPermissionEntry!]!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "The name of this entity."
    name: String!
    "Nodes on which the Permission is granted."
    nodesWithPermission(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: IMSFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: IMSOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): IMSConnection!
    "GropiusUsers granted this Permission"
    users(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: GropiusUserFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: GropiusUserOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): GropiusUserConnection!
}

"The connection type for IMSPermission."
type IMSPermissionConnection {
    "A list of all edges of the current page."
    edges: [IMSPermissionEdge!]!
    "A list of all nodes of the current page."
    nodes: [IMSPermission!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "Identifies the total count of items in the connection."
    totalCount: Int!
}

"An edge in a connection."
type IMSPermissionEdge {
    "A cursor used in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: IMSPermission!
}

"""
Project on an IMS, represents a Trackable synced to an IMS.
The representation on the IMS depends on the type of IMS, e.g. for GitHub, a project is a repository.
READ is granted if READ is granted on `trackable` or `ims`.

"""
type IMSProject implements BaseNode & MutableTemplatedNode & Named & NamedNode & Node & SyncPermissionTarget & TemplatedNode {
    "The description of this entity."
    description: String!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "The IMS this project is a part of."
    ims: IMS
    "The IMSIssues synced to by this project."
    imsIssues(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: IMSIssueFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: IMSIssueOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): IMSIssueConnection!
    "The name of this entity."
    name: String!
    "The users which allow to sync the data of other users to this target."
    syncOthersAllowedBy(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: GropiusUserFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: GropiusUserOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): GropiusUserConnection!
    "The users which allow to sync their data to this target."
    syncSelfAllowedBy(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: GropiusUserFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: GropiusUserOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): GropiusUserConnection!
    "The Template of this Component."
    template: IMSProjectTemplate!
    "Value of a field defined by the template. Error if such a field is not defined."
    templatedField(
        "Name of the extension field"
        name: String!
    ): JSON
    """
    All templatedFields
    If `names` is provided, only those matching the name. If `prefixMatching` is true, matching is done by
    prefix, otherwise by full name.

    """
    templatedFields(
        "Names of the templated fields. If not provided, all templatedFields."
        names: [String!],
        """
        If true, name matching is performed as prefix matching, otherwise as absolute match.
        Defaults to absolute matching

        """
        prefixMatching: Boolean
    ): [JSONField!]!
    "The trackable which is synced."
    trackable: Trackable!
}

"The connection type for IMSProject."
type IMSProjectConnection {
    "A list of all edges of the current page."
    edges: [IMSProjectEdge!]!
    "A list of all nodes of the current page."
    nodes: [IMSProject!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "Identifies the total count of items in the connection."
    totalCount: Int!
}

"An edge in a connection."
type IMSProjectEdge {
    "A cursor used in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: IMSProject!
}

"""
SubTemplate for IMSProject.
Part of a IMSTemplate.
Defines templated fields with specific types (defined using JSON schema).

"""
type IMSProjectTemplate implements BaseNode & BaseTemplate & Named & NamedNode & Node & SubTemplate {
    "The description of this entity."
    description: String!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "The name of this entity."
    name: String!
    "The Template this SubTemplate is part of"
    partOf: IMSTemplate!
    "All template field specifications, if a `namePrefix` is provided, only those matching it"
    templateFieldSpecifications(
        "Name of the extension field."
        namePrefix: String
    ): [JSONField!]!
    "Entities which use this template."
    usedIn(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: IMSProjectFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: IMSProjectOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): IMSProjectConnection!
}

"""
Template for imss
Defines templated fields with specific types (defined using JSON schema).

"""
type IMSTemplate implements BaseNode & BaseTemplate & Named & NamedNode & Node & Template {
    "The description of this entity."
    description: String!
    "Templates that extend this template."
    extendedBy(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: IMSTemplateFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: IMSTemplateOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): IMSTemplateConnection!
    "Template this template extends."
    extends(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: IMSTemplateFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: IMSTemplateOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): IMSTemplateConnection!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "SubTemplate applied to all IMSIssues with this Template"
    imsIssueTemplate: IMSIssueTemplate!
    "SubTemplate applied to all IMSProjects with this Template"
    imsProjectTemplate: IMSProjectTemplate!
    "SubTemplate applied to all IMSUsers with this Template"
    imsUserTemplate: IMSUserTemplate!
    "If true, this template is deprecated and cannot be used for new entities any more."
    isDeprecated: Boolean!
    "The name of this entity."
    name: String!
    "All template field specifications, if a `namePrefix` is provided, only those matching it"
    templateFieldSpecifications(
        "Name of the extension field."
        namePrefix: String
    ): [JSONField!]!
    "Entities which use this template."
    usedIn(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: IMSFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: IMSOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): IMSConnection!
}

"The connection type for IMSTemplate."
type IMSTemplateConnection {
    "A list of all edges of the current page."
    edges: [IMSTemplateEdge!]!
    "A list of all nodes of the current page."
    nodes: [IMSTemplate!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "Identifies the total count of items in the connection."
    totalCount: Int!
}

"An edge in a connection."
type IMSTemplateEdge {
    "A cursor used in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: IMSTemplate!
}

"""
A user an IMS.
This user might be linked to a GropiusUser.
Note that this link can change at any time.
The username might not be unique.
It is possible that this user never heard of Gropius, and is only known to the system due to sync adapters.

"""
type IMSUser implements BaseNode & Node & TemplatedNode & User {
    "Assignments the user is part of, this includes assignments which aren't active."
    assignments(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: AssignmentFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: AssignmentOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): AssignmentConnection!
    "The avatar of the user."
    avatar: URL!
    "AuditedNodes the user created."
    createdNodes(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: AuditedNodeFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: AuditedNodeOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): AuditedNodeConnection!
    "The name which should be displayed for the user."
    displayName: String!
    "The email address of the user."
    email: String
    "The GropiusUser this IMSUser is linked to. An IMSUser might be linked to no GropiusUser."
    gropiusUser: GropiusUser
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "The IMS this user is part of."
    ims: IMS!
    "Issues the user participated in."
    participatedIssues(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: IssueFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: IssueOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): IssueConnection!
    "The Template of this IMSUser"
    template: IMSUserTemplate!
    "Value of a field defined by the template. Error if such a field is not defined."
    templatedField(
        "Name of the extension field"
        name: String!
    ): JSON
    """
    All templatedFields
    If `names` is provided, only those matching the name. If `prefixMatching` is true, matching is done by
    prefix, otherwise by full name.

    """
    templatedFields(
        "Names of the templated fields. If not provided, all templatedFields."
        names: [String!],
        """
        If true, name matching is performed as prefix matching, otherwise as absolute match.
        Defaults to absolute matching

        """
        prefixMatching: Boolean
    ): [JSONField!]!
    "The username of the IMSUser. Synced from the IMS this user is part of. Might not be unique."
    username: String
}

"The connection type for IMSUser."
type IMSUserConnection {
    "A list of all edges of the current page."
    edges: [IMSUserEdge!]!
    "A list of all nodes of the current page."
    nodes: [IMSUser!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "Identifies the total count of items in the connection."
    totalCount: Int!
}

"An edge in a connection."
type IMSUserEdge {
    "A cursor used in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: IMSUser!
}

"""
SubTemplate for IMSUser.
Part of an IMSTemplate.
Defines templated fields with specific types (defined using JSON schema).

"""
type IMSUserTemplate implements BaseNode & BaseTemplate & Named & NamedNode & Node & SubTemplate {
    "The description of this entity."
    description: String!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "The name of this entity."
    name: String!
    "The Template this SubTemplate is part of"
    partOf: IMSTemplate!
    "All template field specifications, if a `namePrefix` is provided, only those matching it"
    templateFieldSpecifications(
        "Name of the extension field."
        namePrefix: String
    ): [JSONField!]!
    "Entities which use this template."
    usedIn(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: IMSUserFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: IMSUserOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): IMSUserConnection!
}

"""
Event representing that the type of an incoming IssueRelation changed.
READ is granted if READ is granted on `issueRelation`.

"""
type IncomingRelationTypeChangedEvent implements AuditedNode & BaseNode & Node & RelationTypeChangedEvent & TimelineItem {
    "The DateTime this entity was created at."
    createdAt: DateTime!
    "The User who created this entity."
    createdBy: User!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "The Issue this TimelineItem is part of."
    issue: Issue
    "The IssueRelation of which the type was changed"
    issueRelation: IssueRelation!
    "The DateTime this entity was last modified at."
    lastModifiedAt: DateTime!
    "The User who last modified this entity."
    lastModifiedBy: User!
    "The new type."
    newType: IssueRelationType
    "The old type."
    oldType: IssueRelationType
    "If existing, the parent TimelineItem"
    parentItem: ParentTimelineItem
}

"""
An interface which is part of a specific ComponentVersion.
Its semantics depend on the InterfaceSpecification it is specified by, e.g. an Interface can represent a REST API.
Can be used in Relations and affected by Issues.
READ is granted if READ is granted on `interfaceDefinition`.

"""
type Interface implements AffectedByIssue & BaseNode & MutableTemplatedNode & Named & NamedNode & Node & RelationPartner & TemplatedNode {
    "The issues which affect this entity"
    affectingIssues(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: IssueFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: IssueOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): IssueConnection!
    "AggregatedIssues on this RelationPartner."
    aggregatedIssues(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: AggregatedIssueFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: AggregatedIssueOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): AggregatedIssueConnection!
    "The description of this entity."
    description: String!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "Relations which use this as the end of the Relation."
    incomingRelations(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: RelationFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: RelationOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): RelationConnection!
    "The definition of this interface."
    interfaceDefinition: InterfaceDefinition!
    "Participants of IntraComponentDependencySpecifications where this is used."
    intraComponentDependencyParticipants(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: IntraComponentDependencyParticipantFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: IntraComponentDependencyParticipantOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): IntraComponentDependencyParticipantConnection!
    "The name of this entity."
    name: String!
    "Relations which use this as the start of the Relation."
    outgoingRelations(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: RelationFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: RelationOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): RelationConnection!
    "The Template of this Interface."
    template: InterfaceTemplate!
    "Value of a field defined by the template. Error if such a field is not defined."
    templatedField(
        "Name of the extension field"
        name: String!
    ): JSON
    """
    All templatedFields
    If `names` is provided, only those matching the name. If `prefixMatching` is true, matching is done by
    prefix, otherwise by full name.

    """
    templatedFields(
        "Names of the templated fields. If not provided, all templatedFields."
        names: [String!],
        """
        If true, name matching is performed as prefix matching, otherwise as absolute match.
        Defaults to absolute matching

        """
        prefixMatching: Boolean
    ): [JSONField!]!
}

"The connection type for Interface."
type InterfaceConnection {
    "A list of all edges of the current page."
    edges: [InterfaceEdge!]!
    "A list of all nodes of the current page."
    nodes: [Interface!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "Identifies the total count of items in the connection."
    totalCount: Int!
}

"""
InterfaceDefinition on a ComponentVersion
Specifies if it is visible/invisible self-defined.
Specifies if it is visible/invisible derived (and by which Relations)
READ is granted if READ is granted on `componentVersion`

"""
type InterfaceDefinition implements BaseNode & MutableTemplatedNode & Node & TemplatedNode {
    "The ComponentVersion using the InterfaceSpecificationVersion"
    componentVersion: ComponentVersion!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "The InterfaceSpecificationVersion present on the ComponentVersion"
    interfaceSpecificationVersion: InterfaceSpecificationVersion!
    "Relations because of which `interfaceSpecificationVersion` is invisible derived on `componentVersion`"
    invisibleDerivedBy(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: RelationFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: RelationOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): RelationConnection!
    "If true, `interfaceSpecificationVersion`is self-defined invisible on the `componentVersion`"
    invisibleSelfDefined: Boolean!
    "The Template of this InterfaceDefinition."
    template: InterfaceDefinitionTemplate!
    "Value of a field defined by the template. Error if such a field is not defined."
    templatedField(
        "Name of the extension field"
        name: String!
    ): JSON
    """
    All templatedFields
    If `names` is provided, only those matching the name. If `prefixMatching` is true, matching is done by
    prefix, otherwise by full name.

    """
    templatedFields(
        "Names of the templated fields. If not provided, all templatedFields."
        names: [String!],
        """
        If true, name matching is performed as prefix matching, otherwise as absolute match.
        Defaults to absolute matching

        """
        prefixMatching: Boolean
    ): [JSONField!]!
    "Relations because of which `interfaceSpecificationVersion` is visible derived on `componentVersion`"
    visibleDerivedBy(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: RelationFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: RelationOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): RelationConnection!
    "If visible, the created Interface"
    visibleInterface: Interface
    "If true, `interfaceSpecificationVersion`is self-defined visible on the `componentVersion`"
    visibleSelfDefined: Boolean!
}

"The connection type for InterfaceDefinition."
type InterfaceDefinitionConnection {
    "A list of all edges of the current page."
    edges: [InterfaceDefinitionEdge!]!
    "A list of all nodes of the current page."
    nodes: [InterfaceDefinition!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "Identifies the total count of items in the connection."
    totalCount: Int!
}

"An edge in a connection."
type InterfaceDefinitionEdge {
    "A cursor used in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: InterfaceDefinition!
}

"""
SubTemplate for InterfaceDefinition.
Part of a InterfaceSpecificationTemplate.
Defines templated fields with specific types (defined using JSON schema).
All templatedFieldSpecifications must allow `null` as value.

"""
type InterfaceDefinitionTemplate implements BaseNode & BaseTemplate & Named & NamedNode & Node & SubTemplate {
    "The description of this entity."
    description: String!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "The name of this entity."
    name: String!
    "The Template this SubTemplate is part of"
    partOf: InterfaceSpecificationTemplate!
    "All template field specifications, if a `namePrefix` is provided, only those matching it"
    templateFieldSpecifications(
        "Name of the extension field."
        namePrefix: String
    ): [JSONField!]!
    "Entities which use this template."
    usedIn(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: InterfaceDefinitionFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: InterfaceDefinitionOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): InterfaceDefinitionConnection!
}

"An edge in a connection."
type InterfaceEdge {
    "A cursor used in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Interface!
}

"""
Part of an Interface(Specification).
Its semantics depend on the InterfaceSpecification, e.g. for a REST API interface,
this could represent a single endpoint of the API.
Relations can specify for both start and end included InterfaceParts.
Can be affected by Issues, and be used as start / end of ServiceEffectSpecifications.
READ is granted if READ is granted on `definedOn`.

"""
type InterfacePart implements AffectedByIssue & BaseNode & MutableTemplatedNode & Named & NamedNode & Node & TemplatedNode {
    "The issues which affect this entity"
    affectingIssues(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: IssueFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: IssueOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): IssueConnection!
    "The description of this entity."
    description: String!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "Relations which include this InterfacePart at the end of the Relation"
    includingIncomingRelations(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: RelationFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: RelationOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): RelationConnection!
    "Participants of IntraComponentDependencySpecifications where this is used as included part."
    includingIntraComponentDependencyParticipants(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: IntraComponentDependencyParticipantFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: IntraComponentDependencyParticipantOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): IntraComponentDependencyParticipantConnection!
    "Relations which include this InterfacePart at the start of the Relation"
    includingOutgoingRelations(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: RelationFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: RelationOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): RelationConnection!
    "The name of this entity."
    name: String!
    "InterfaceSpecificationVersions where this InterfacePart is active."
    partOf: InterfaceSpecificationVersion!
    "The Template of this InterfacePart"
    template: InterfacePartTemplate!
    "Value of a field defined by the template. Error if such a field is not defined."
    templatedField(
        "Name of the extension field"
        name: String!
    ): JSON
    """
    All templatedFields
    If `names` is provided, only those matching the name. If `prefixMatching` is true, matching is done by
    prefix, otherwise by full name.

    """
    templatedFields(
        "Names of the templated fields. If not provided, all templatedFields."
        names: [String!],
        """
        If true, name matching is performed as prefix matching, otherwise as absolute match.
        Defaults to absolute matching

        """
        prefixMatching: Boolean
    ): [JSONField!]!
}

"The connection type for InterfacePart."
type InterfacePartConnection {
    "A list of all edges of the current page."
    edges: [InterfacePartEdge!]!
    "A list of all nodes of the current page."
    nodes: [InterfacePart!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "Identifies the total count of items in the connection."
    totalCount: Int!
}

"An edge in a connection."
type InterfacePartEdge {
    "A cursor used in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: InterfacePart!
}

"""
SubTemplate for InterfacePart.
Part of a InterfaceSpecificationTemplate.
Defines templated fields with specific types (defined using JSON schema).

"""
type InterfacePartTemplate implements BaseNode & BaseTemplate & Named & NamedNode & Node & SubTemplate {
    "The description of this entity."
    description: String!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "The name of this entity."
    name: String!
    "The Template this SubTemplate is part of"
    partOf: InterfaceSpecificationTemplate!
    "All template field specifications, if a `namePrefix` is provided, only those matching it"
    templateFieldSpecifications(
        "Name of the extension field."
        namePrefix: String
    ): [JSONField!]!
    "Entities which use this template."
    usedIn(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: InterfacePartFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: InterfacePartOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): InterfacePartConnection!
}

"""
Specification of an Interface.
Defined on a Component, but can be visible and invisible on different ComponentVersions.
Can be affected by Issues, and be used as start / end of ServiceEffectSpecifications.
Defines InterfaceParts, but active parts depend on the InterfaceSpecificationVersion.
READ is granted if READ is granted on `component`, or any InterfaceSpecificationVersion in `versions`.

"""
type InterfaceSpecification implements AffectedByIssue & BaseNode & MutableTemplatedNode & Named & NamedNode & Node & TemplatedNode {
    "The issues which affect this entity"
    affectingIssues(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: IssueFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: IssueOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): IssueConnection!
    "The Component this InterfaceSpecification is part of."
    component: Component!
    "The description of this entity."
    description: String!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "The name of this entity."
    name: String!
    "The Template of this InterfaceSpecification."
    template: InterfaceSpecificationTemplate!
    "Value of a field defined by the template. Error if such a field is not defined."
    templatedField(
        "Name of the extension field"
        name: String!
    ): JSON
    """
    All templatedFields
    If `names` is provided, only those matching the name. If `prefixMatching` is true, matching is done by
    prefix, otherwise by full name.

    """
    templatedFields(
        "Names of the templated fields. If not provided, all templatedFields."
        names: [String!],
        """
        If true, name matching is performed as prefix matching, otherwise as absolute match.
        Defaults to absolute matching

        """
        prefixMatching: Boolean
    ): [JSONField!]!
    "Versions of this InterfaceSpecification."
    versions(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: InterfaceSpecificationVersionFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: InterfaceSpecificationVersionOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): InterfaceSpecificationVersionConnection!
}

"The connection type for InterfaceSpecification."
type InterfaceSpecificationConnection {
    "A list of all edges of the current page."
    edges: [InterfaceSpecificationEdge!]!
    "A list of all nodes of the current page."
    nodes: [InterfaceSpecification!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "Identifies the total count of items in the connection."
    totalCount: Int!
}

"""
Defines which InterfaceSpecifications are derived under which conditions by a Relation.
Part of a RelationCondition, which is part of RelationTemplates.
READ is always granted.

"""
type InterfaceSpecificationDerivationCondition implements BaseNode & Node {
    "Templates of InterfaceSpecifications which are derived."
    derivableInterfaceSpecifications(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: InterfaceSpecificationTemplateFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: InterfaceSpecificationTemplateOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): InterfaceSpecificationTemplateConnection!
    "If true, invisible derived InterfaceSpecifications are derived"
    derivesInvisibleDerived: Boolean!
    "If true, invisible self-defined InterfaceSpecifications are derived"
    derivesInvisibleSelfDefined: Boolean!
    "If true, visible derived InterfaceSpecifications are derived"
    derivesVisibleDerived: Boolean!
    "If true, visible self-defined InterfaceSpecifications are derived"
    derivesVisibleSelfDefined: Boolean!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "If true InterfaceSpecifications are invisible derived"
    isInvisibleDerived: Boolean!
    "If true InterfaceSpecifications are visible derived"
    isVisibleDerived: Boolean!
    "The RelationCondition this is part of."
    partOf: RelationCondition!
}

"The connection type for InterfaceSpecificationDerivationCondition."
type InterfaceSpecificationDerivationConditionConnection {
    "A list of all edges of the current page."
    edges: [InterfaceSpecificationDerivationConditionEdge!]!
    "A list of all nodes of the current page."
    nodes: [InterfaceSpecificationDerivationCondition!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "Identifies the total count of items in the connection."
    totalCount: Int!
}

"An edge in a connection."
type InterfaceSpecificationDerivationConditionEdge {
    "A cursor used in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: InterfaceSpecificationDerivationCondition!
}

"An edge in a connection."
type InterfaceSpecificationEdge {
    "A cursor used in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: InterfaceSpecification!
}

"""
Template for InterfaceSpecifications.
Defines templated fields with specific types (defined using JSON schema).
Defines on which Components InterfaceSpecifications with this Template can be (in)visible on.
Defines SubTemplates for Interfaces and InterfaceSpecificationVersions.

"""
type InterfaceSpecificationTemplate implements BaseNode & BaseTemplate & Named & NamedNode & Node & RelationPartnerTemplate & Template {
    "Templates of Components InterfaceSpecifications with this template can be invisible on."
    canBeInvisibleOnComponents(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: ComponentTemplateFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: ComponentTemplateOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): ComponentTemplateConnection!
    "Templates of Components InterfaceSpecifications with this template can be visible on."
    canBeVisibleOnComponents(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: ComponentTemplateFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: ComponentTemplateOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): ComponentTemplateConnection!
    """
    InterfaceSpecificationDerivationConditions which allow to derive InterfaceSpecification with this template.

    """
    derivableBy(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: InterfaceSpecificationDerivationConditionFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: InterfaceSpecificationDerivationConditionOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): InterfaceSpecificationDerivationConditionConnection!
    "The description of this entity."
    description: String!
    "Templates that extend this template."
    extendedBy(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: InterfaceSpecificationTemplateFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: InterfaceSpecificationTemplateOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): InterfaceSpecificationTemplateConnection!
    "Template this template extends."
    extends(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: InterfaceSpecificationTemplateFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: InterfaceSpecificationTemplateOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): InterfaceSpecificationTemplateConnection!
    "Style of the fill"
    fill: FillStyle
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    """
    SubTemplate applied to all InterfaceDefinitions of InterfaceSpecifications with this Template.

    """
    interfaceDefinitionTemplate: InterfaceDefinitionTemplate!
    """
    SubTemplate applied to all InterfaceParts of InterfaceSpecifications with this Template.

    """
    interfacePartTemplate: InterfacePartTemplate!
    """
    SubTemplate applied to all InterfaceSpecificationVersions of InterfaceSpecifications with this Template.

    """
    interfaceSpecificationVersionTemplate: InterfaceSpecificationVersionTemplate!
    """
    SubTemplate applied to all Interfaces of InterfaceSpecifications with this Template.

    """
    interfaceTemplate: InterfaceTemplate!
    "If true, this template is deprecated and cannot be used for new entities any more."
    isDeprecated: Boolean!
    "The name of this entity."
    name: String!
    "RelationConditions which allow this template for the end of the relation."
    possibleEndOfRelations(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: RelationConditionFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: RelationConditionOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): RelationConditionConnection!
    "RelationConditions which allow this template for the start of the relation."
    possibleStartOfRelations(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: RelationConditionFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: RelationConditionOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): RelationConditionConnection!
    shapeRadius: Float
    shapeType: ShapeType!
    "Style of the stroke"
    stroke: StrokeStyle
    "All template field specifications, if a `namePrefix` is provided, only those matching it"
    templateFieldSpecifications(
        "Name of the extension field."
        namePrefix: String
    ): [JSONField!]!
    "Entities which use this template."
    usedIn(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: InterfaceSpecificationFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: InterfaceSpecificationOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): InterfaceSpecificationConnection!
}

"The connection type for InterfaceSpecificationTemplate."
type InterfaceSpecificationTemplateConnection {
    "A list of all edges of the current page."
    edges: [InterfaceSpecificationTemplateEdge!]!
    "A list of all nodes of the current page."
    nodes: [InterfaceSpecificationTemplate!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "Identifies the total count of items in the connection."
    totalCount: Int!
}

"An edge in a connection."
type InterfaceSpecificationTemplateEdge {
    "A cursor used in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: InterfaceSpecificationTemplate!
}

"""
A specific version of an InterfaceSpecification.
Defines which InterfaceParts are active.
Can be both visible (generates an Interface) and invisible (does not generate an Interface)
on different Components.
Can be derived by Relations, and affected by Issues.
READ is granted if READ is granted on `interfaceSpecification`,
or any InterfaceDefinition in `definitions`

"""
type InterfaceSpecificationVersion implements AffectedByIssue & BaseNode & MutableTemplatedNode & Named & NamedNode & Node & TemplatedNode & Versioned {
    "The issues which affect this entity"
    affectingIssues(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: IssueFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: IssueOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): IssueConnection!
    "The description of this entity."
    description: String!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "Defines on which ComponentVersions this InterfaceSpecificationVersion is used"
    interfaceDefinitions(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: InterfaceDefinitionFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: InterfaceDefinitionOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): InterfaceDefinitionConnection!
    "The InterfaceSpecification this is part of."
    interfaceSpecification: InterfaceSpecification!
    "The name of this entity."
    name: String!
    """
    InterfaceParts which are part of this InterfaceSpecificationVersion

    """
    parts(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: InterfacePartFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: InterfacePartOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): InterfacePartConnection!
    "The Template of this InterfaceSpecificationVersion"
    template: InterfaceSpecificationVersionTemplate!
    "Value of a field defined by the template. Error if such a field is not defined."
    templatedField(
        "Name of the extension field"
        name: String!
    ): JSON
    """
    All templatedFields
    If `names` is provided, only those matching the name. If `prefixMatching` is true, matching is done by
    prefix, otherwise by full name.

    """
    templatedFields(
        "Names of the templated fields. If not provided, all templatedFields."
        names: [String!],
        """
        If true, name matching is performed as prefix matching, otherwise as absolute match.
        Defaults to absolute matching

        """
        prefixMatching: Boolean
    ): [JSONField!]!
    "The version of this InterfaceSpecificationVersion."
    version: String!
}

"The connection type for InterfaceSpecificationVersion."
type InterfaceSpecificationVersionConnection {
    "A list of all edges of the current page."
    edges: [InterfaceSpecificationVersionEdge!]!
    "A list of all nodes of the current page."
    nodes: [InterfaceSpecificationVersion!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "Identifies the total count of items in the connection."
    totalCount: Int!
}

"An edge in a connection."
type InterfaceSpecificationVersionEdge {
    "A cursor used in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: InterfaceSpecificationVersion!
}

"""
SubTemplate for InterfaceSpecificationVersion.
Part of a InterfaceSpecificationTemplate.
Defines templated fields with specific types (defined using JSON schema).

"""
type InterfaceSpecificationVersionTemplate implements BaseNode & BaseTemplate & Named & NamedNode & Node & SubTemplate {
    "The description of this entity."
    description: String!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "The name of this entity."
    name: String!
    "The Template this SubTemplate is part of"
    partOf: InterfaceSpecificationTemplate!
    "All template field specifications, if a `namePrefix` is provided, only those matching it"
    templateFieldSpecifications(
        "Name of the extension field."
        namePrefix: String
    ): [JSONField!]!
    "Entities which use this template."
    usedIn(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: InterfaceSpecificationVersionFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: InterfaceSpecificationVersionOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): InterfaceSpecificationVersionConnection!
}

"""
SubTemplate for Interface.
Part of a InterfaceSpecificationTemplate.
Defines templated fields with specific types (defined using JSON schema).
All templatedFieldSpecifications must allow `null` as value.

"""
type InterfaceTemplate implements BaseNode & BaseTemplate & Named & NamedNode & Node & SubTemplate {
    "The description of this entity."
    description: String!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "The name of this entity."
    name: String!
    "The Template this SubTemplate is part of"
    partOf: InterfaceSpecificationTemplate!
    "All template field specifications, if a `namePrefix` is provided, only those matching it"
    templateFieldSpecifications(
        "Name of the extension field."
        namePrefix: String
    ): [JSONField!]!
    "Entities which use this template."
    usedIn(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: InterfaceFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: InterfaceOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): InterfaceConnection!
}

"""
Participant of a a IntraComponentDependencySpecification
Consists of an Interface it refers to, and optionally a subset of its active InterfaceParts.
READ is granted if READ is granted on the associated ComponentVersion

"""
type IntraComponentDependencyParticipant implements BaseNode & Node {
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    """
    If not empty, the InterfaceParts this IntraComponentDependencyParticipant refers to
    Otherwise, it refers to the referenced `interface` in general.
    Must all be active on `interface`.

    """
    includedParts(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: InterfacePartFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: InterfacePartOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): InterfacePartConnection!
    "The Interface this IntraComponentDependencyParticipant refers to"
    interface: Interface!
    "If this is used as incoming, the IntraComponentDependencySpecification where it is used"
    usedAsIncomingAt: IntraComponentDependencySpecification
    "If this is used as outgoing, the IntraComponentDependencySpecification where it is used"
    usedAsOutgoingAt: IntraComponentDependencySpecification
}

"The connection type for IntraComponentDependencyParticipant."
type IntraComponentDependencyParticipantConnection {
    "A list of all edges of the current page."
    edges: [IntraComponentDependencyParticipantEdge!]!
    "A list of all nodes of the current page."
    nodes: [IntraComponentDependencyParticipant!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "Identifies the total count of items in the connection."
    totalCount: Int!
}

"An edge in a connection."
type IntraComponentDependencyParticipantEdge {
    "A cursor used in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: IntraComponentDependencyParticipant!
}

"""
Describes a dependency between Interfaces of a Component.
Both ends can optionally affected InterfaceParts.
Semantically, any InterfaceSpecification(Version) in `outgoing` depends on any InterfaceSpecification(Version) in
`incoming`.
This can result in a propagation of Issues, if any location in `in` is in some regard affected by an Issue,
all locations in `out` are affected by this Issue, too.

"""
type IntraComponentDependencySpecification implements BaseNode & Named & NamedNode & Node {
    "The ComponentVersion this is part of"
    componentVersion: ComponentVersion!
    "The description of this entity."
    description: String!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "The incoming Interfaces of this ServiceEffectSpecification."
    incomingParticipants(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: IntraComponentDependencyParticipantFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: IntraComponentDependencyParticipantOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): IntraComponentDependencyParticipantConnection!
    "The name of this entity."
    name: String!
    "The outgoing Interfaces of this ServiceEffectSpecification."
    outgoingParticipants(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: IntraComponentDependencyParticipantFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: IntraComponentDependencyParticipantOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): IntraComponentDependencyParticipantConnection!
}

"The connection type for IntraComponentDependencySpecification."
type IntraComponentDependencySpecificationConnection {
    "A list of all edges of the current page."
    edges: [IntraComponentDependencySpecificationEdge!]!
    "A list of all nodes of the current page."
    nodes: [IntraComponentDependencySpecification!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "Identifies the total count of items in the connection."
    totalCount: Int!
}

"An edge in a connection."
type IntraComponentDependencySpecificationEdge {
    "A cursor used in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: IntraComponentDependencySpecification!
}

"""
An Issue in the Gropius system.
Issues can be used to report bugs, request features, ask questions, ...
Issues are synced to all IMSProjects of Trackables they are part of.
All changes to the Issue are reflected by the timeline.
READ is granted if READ is granted on any Trackable in `trackables`.
Caution: due to confidentiality reasons, updates to `incomingRelations` do not cause updates on `lastModifiedBy`
and `participants`, however, `lastModifiedAt` and `lastUpdatedAt` is still changed.
The same applies to RelatedByIssueEvent, RemovedIncomingRelationEvent and IncomingRelationTypeChangedEvent.

"""
type Issue implements AuditedNode & BaseNode & MutableTemplatedNode & Node & TemplatedNode {
    "Entities which are in some regard affected by this Issue."
    affects(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: AffectedByIssueFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: AffectedByIssueOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): AffectedByIssueConnection!
    "AggregatedIssues which aggregate this Issue."
    aggregatedBy(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: AggregatedIssueFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: AggregatedIssueOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): AggregatedIssueConnection!
    "Artefacts currently assigned to the Issue. For the history, see timelineItems."
    artefacts(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: ArtefactFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: ArtefactOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): ArtefactConnection!
    "Current Assignments to this Issue. For the history, see timelineItems."
    assignments(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: AssignmentFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: AssignmentOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): AssignmentConnection!
    "The Body of the Issue, a Comment directly associated with the Issue."
    body: Body!
    "The DateTime this entity was created at."
    createdAt: DateTime!
    "The User who created this entity."
    createdBy: User!
    "DateTime when working on this Issue should be finished."
    dueDate: DateTime
    "Estimated amount of time necessary for this Issue."
    estimatedTime: Duration
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    """
    Descriptions of each IMSProject this issue is synced to containing information specified by the sync

    """
    imsIssues(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: IMSIssueFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: IMSIssueOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): IMSIssueConnection!
    "Current IssueRelations which have this Issue as end point."
    incomingRelations(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: IssueRelationFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: IssueRelationOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): IssueRelationConnection!
    "Comments on the Issue, subset of the timeline."
    issueComments(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: IssueCommentFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: IssueCommentOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): IssueCommentConnection!
    "Labels currently assigned to the Issue. For the history, see timelineItems."
    labels(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: LabelFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: LabelOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): LabelConnection!
    "The DateTime this entity was last modified at."
    lastModifiedAt: DateTime!
    "The User who last modified this entity."
    lastModifiedBy: User!
    "The DateTime when the Issue was last updated, this includes a changed timeline."
    lastUpdatedAt: DateTime!
    "Current IssueRelations which have this Issue as start point."
    outgoingRelations(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: IssueRelationFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: IssueRelationOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): IssueRelationConnection!
    "Users who participated on the Issue, e.g. commented, added Labels, ..."
    participants(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: UserFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: UserOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): UserConnection!
    "Trackables this Issue is currently pinned on. For the history, see timelineItems."
    pinnedOn(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: TrackableFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: TrackableOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): TrackableConnection!
    "The priority of the Issue, e.g. HIGH. Allowed IssuePriorities are defined by the template."
    priority: IssuePriority
    "Time spent working on this Issue."
    spentTime: Duration
    "DateTime when working on this Issue started / will start."
    startDate: DateTime
    """
    The state of the Issue, e.g. OPEN. Allowed IssueStates are defined by the template.
    The state also defines if this Issue is considered open or closed.

    """
    state: IssueState!
    "The Template of this Issue."
    template: IssueTemplate!
    "Value of a field defined by the template. Error if such a field is not defined."
    templatedField(
        "Name of the extension field"
        name: String!
    ): JSON
    """
    All templatedFields
    If `names` is provided, only those matching the name. If `prefixMatching` is true, matching is done by
    prefix, otherwise by full name.

    """
    templatedFields(
        "Names of the templated fields. If not provided, all templatedFields."
        names: [String!],
        """
        If true, name matching is performed as prefix matching, otherwise as absolute match.
        Defaults to absolute matching

        """
        prefixMatching: Boolean
    ): [JSONField!]!
    "Timeline of the Issue, shows how the Issue changed over time."
    timelineItems(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: TimelineItemFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: TimelineItemOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): TimelineItemConnection!
    "Title of the Issue, usually a short description of the Issue."
    title: String!
    "Trackables this Issue is part of."
    trackables(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: TrackableFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: TrackableOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): TrackableConnection!
    "The type of the Issue, e.g. BUG. Allowed IssueTypes are defined by the template."
    type: IssueType!
}

"""
Comment on an Issue.
Can reference Artefacts.
Can be deleted, if deleted, the body is set to an empty String and the referencedComments are cleared.
Keeps track when it was last edited and by who, but does not keep track of the change history.
READ is granted if READ is granted on `issue`.

"""
type IssueComment implements AuditedNode & BaseNode & Comment & Node & TimelineItem {
    "IssueComments which answer this Comment."
    answeredBy(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: IssueCommentFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: IssueCommentOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): IssueCommentConnection!
    "The Comment this IssueComment is an answers to."
    answers: Comment
    """
    The text of the Comment.
    Supports GFM (GitHub Flavored Markdown).
    Updates cause lastEditedAt and lastEditedBy to change.
    Empty String if IssueComment is deleted.

    """
    body: String!
    """
    Keep track when the body of the Comment was last updated.
    If not updated yet, the DateTime of creation.

    """
    bodyLastEditedAt: DateTime!
    """
    The User who last edited the body of this Comment.
    If not edited yet, the creator of the Comment.

    """
    bodyLastEditedBy: User!
    "The DateTime this entity was created at."
    createdAt: DateTime!
    "The User who created this entity."
    createdBy: User!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "If true, the IssueComment was deleted and the body is no longer visible."
    isDeleted: Boolean!
    "The Issue this TimelineItem is part of."
    issue: Issue
    "The DateTime this entity was last modified at."
    lastModifiedAt: DateTime!
    "The User who last modified this entity."
    lastModifiedBy: User!
    "If existing, the parent TimelineItem"
    parentItem: ParentTimelineItem
    "Referenced Artefacts. Changes to not cause lastEditedAt/lastEditedBy to change."
    referencedArtefacts(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: ArtefactFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: ArtefactOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): ArtefactConnection!
}

"The connection type for IssueComment."
type IssueCommentConnection {
    "A list of all edges of the current page."
    edges: [IssueCommentEdge!]!
    "A list of all nodes of the current page."
    nodes: [IssueComment!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "Identifies the total count of items in the connection."
    totalCount: Int!
}

"An edge in a connection."
type IssueCommentEdge {
    "A cursor used in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: IssueComment!
}

"The connection type for Issue."
type IssueConnection {
    "A list of all edges of the current page."
    edges: [IssueEdge!]!
    "A list of all nodes of the current page."
    nodes: [Issue!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "Identifies the total count of items in the connection."
    totalCount: Int!
}

"An edge in a connection."
type IssueEdge {
    "A cursor used in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Issue!
}

"""
Priority of an Issue like HIGH or LOW. Part of an IssueTemplate.
READ is always granted.

"""
type IssuePriority implements BaseNode & Named & NamedNode & Node {
    "The description of this entity."
    description: String!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "The name of this entity."
    name: String!
    partOf(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: IssueTemplateFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: IssueTemplateOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): IssueTemplateConnection!
    prioritizedIssues(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: IssueFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: IssueOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): IssueConnection!
    "The value of the IssuePriority, used to compare/order different IssuePriorities."
    value: Float!
}

"The connection type for IssuePriority."
type IssuePriorityConnection {
    "A list of all edges of the current page."
    edges: [IssuePriorityEdge!]!
    "A list of all nodes of the current page."
    nodes: [IssuePriority!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "Identifies the total count of items in the connection."
    totalCount: Int!
}

"An edge in a connection."
type IssuePriorityEdge {
    "A cursor used in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: IssuePriority!
}

"""
Event representing that a relation between two Issues has been created.
An IssueRelation is only active if it is still in `outgoingRelations` on the `issue`,
respectively in incomingRelations on the `relatedIssue`.
Caution: This is **not** a subtype of Relation.
READ is granted if READ is granted on `issue`.

"""
type IssueRelation implements AuditedNode & BaseNode & Node & TimelineItem {
    "The AggregatedIssueRelations this IssueRelation is aggregated by."
    aggregatedBy(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: AggregatedIssueRelationFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: AggregatedIssueRelationOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): AggregatedIssueRelationConnection!
    "The DateTime this entity was created at."
    createdAt: DateTime!
    "The User who created this entity."
    createdBy: User!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "The Issue this TimelineItem is part of."
    issue: Issue
    "The DateTime this entity was last modified at."
    lastModifiedAt: DateTime!
    "The User who last modified this entity."
    lastModifiedBy: User!
    "If existing, the parent TimelineItem"
    parentItem: ParentTimelineItem
    "The end of the relation, null if deleted."
    relatedIssue: Issue
    "The type of the relation, e.g. DUPLICATES. Allowed types are defined by the IssueTemplate."
    type: IssueRelationType
}

"The connection type for IssueRelation."
type IssueRelationConnection {
    "A list of all edges of the current page."
    edges: [IssueRelationEdge!]!
    "A list of all nodes of the current page."
    nodes: [IssueRelation!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "Identifies the total count of items in the connection."
    totalCount: Int!
}

"An edge in a connection."
type IssueRelationEdge {
    "A cursor used in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: IssueRelation!
}

"""
Type for an IssueRelation, like DUPLICATES or DEPENDS_ON. Part of an IssueTemplate.
READ is always granted.

"""
type IssueRelationType implements BaseNode & Named & NamedNode & Node {
    "The description of this entity."
    description: String!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "The name of the relation from the inverse (incoming) perspective"
    inverseName: String!
    "The name of this entity."
    name: String!
    "IssueTemplates this is part of."
    partOf(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: IssueTemplateFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: IssueTemplateOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): IssueTemplateConnection!
    "Relations which use this type."
    relationsWithType(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: IssueRelationFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: IssueRelationOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): IssueRelationConnection!
}

"The connection type for IssueRelationType."
type IssueRelationTypeConnection {
    "A list of all edges of the current page."
    edges: [IssueRelationTypeEdge!]!
    "A list of all nodes of the current page."
    nodes: [IssueRelationType!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "Identifies the total count of items in the connection."
    totalCount: Int!
}

"An edge in a connection."
type IssueRelationTypeEdge {
    "A cursor used in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: IssueRelationType!
}

"""
State of an Issue like BUG or FEATURE_REQUEST. Part of an IssueTemplate.
READ is always granted.

"""
type IssueState implements BaseNode & Named & NamedNode & Node {
    "The description of this entity."
    description: String!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "If true and the issue has this state, the issue is considered open, otherwise closed"
    isOpen: Boolean!
    "Issues with this state."
    issuesWithState(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: IssueFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: IssueOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): IssueConnection!
    "The name of this entity."
    name: String!
    "IssueTemplates this is a part of."
    partOf(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: IssueTemplateFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: IssueTemplateOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): IssueTemplateConnection!
}

"The connection type for IssueState."
type IssueStateConnection {
    "A list of all edges of the current page."
    edges: [IssueStateEdge!]!
    "A list of all nodes of the current page."
    nodes: [IssueState!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "Identifies the total count of items in the connection."
    totalCount: Int!
}

"An edge in a connection."
type IssueStateEdge {
    "A cursor used in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: IssueState!
}

"""
Template for Issues.
Defines templated fields with specific types (defined using JSON schema).
Defines possible IssueTypes, IssueStates and IssuePriorities for Issues with this Template,
possible AssignmentTypes for Assignments to Issues with this template, and possible
RelationTypes for outgoing IssueRelations for Issues with this template.
All those are derived, if this Template extends another IssueTemplate.

"""
type IssueTemplate implements BaseNode & BaseTemplate & Named & NamedNode & Node & Template {
    "Set of all types Assignments to Issues with this Template can have."
    assignmentTypes(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: AssignmentTypeFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: AssignmentTypeOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): AssignmentTypeConnection!
    "The description of this entity."
    description: String!
    "Templates that extend this template."
    extendedBy(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: IssueTemplateFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: IssueTemplateOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): IssueTemplateConnection!
    "Template this template extends."
    extends(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: IssueTemplateFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: IssueTemplateOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): IssueTemplateConnection!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "If true, this template is deprecated and cannot be used for new entities any more."
    isDeprecated: Boolean!
    "Set of all priorities Issues with this Template can have."
    issuePriorities(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: IssuePriorityFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: IssuePriorityOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): IssuePriorityConnection!
    "Set of all states Issues with this Template can have."
    issueStates(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: IssueStateFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: IssueStateOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): IssueStateConnection!
    "Set of all types Issues with this Template can have."
    issueTypes(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: IssueTypeFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: IssueTypeOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): IssueTypeConnection!
    "The name of this entity."
    name: String!
    "Set of all types outgoing IssueRelations of Issues with this Template can have"
    relationTypes(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: IssueRelationTypeFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: IssueRelationTypeOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): IssueRelationTypeConnection!
    "All template field specifications, if a `namePrefix` is provided, only those matching it"
    templateFieldSpecifications(
        "Name of the extension field."
        namePrefix: String
    ): [JSONField!]!
    "Entities which use this template."
    usedIn(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: IssueFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: IssueOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): IssueConnection!
}

"The connection type for IssueTemplate."
type IssueTemplateConnection {
    "A list of all edges of the current page."
    edges: [IssueTemplateEdge!]!
    "A list of all nodes of the current page."
    nodes: [IssueTemplate!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "Identifies the total count of items in the connection."
    totalCount: Int!
}

"An edge in a connection."
type IssueTemplateEdge {
    "A cursor used in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: IssueTemplate!
}

"""
Type of an Issue like BUG or FEATURE_REQUEST. Part of an IssueTemplate.
READ is always granted.

"""
type IssueType implements BaseNode & Named & NamedNode & Node {
    "The description of this entity."
    description: String!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "A path that is used as the icon for issues. Used with a 0 0 100 100 viewBox. No stroke, only fill."
    iconPath: String!
    "The unique id of this node"
    id: ID!
    "Issues with this type."
    issuesWithType(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: IssueFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: IssueOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): IssueConnection!
    "The name of this entity."
    name: String!
    "IssueTemplates this is a part of."
    partOf(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: IssueTemplateFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: IssueTemplateOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): IssueTemplateConnection!
}

"The connection type for IssueType."
type IssueTypeConnection {
    "A list of all edges of the current page."
    edges: [IssueTypeEdge!]!
    "A list of all nodes of the current page."
    nodes: [IssueType!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "Identifies the total count of items in the connection."
    totalCount: Int!
}

"An edge in a connection."
type IssueTypeEdge {
    "A cursor used in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: IssueType!
}

"A JSON extension field, consisting of a name and a value."
type JSONField {
    "The name of the field, used as unique identifier."
    name: String!
    "The value of the JSON field, might be null."
    value: JSON
}

"""
Label used to mark Issues with.
A Label consists of a name, a description and a color.
Issues may be synced to all IMSProjects of Trackables they are part of.
READ is granted if READ is granted on any Trackable in `trackables`.

"""
type Label implements AuditedNode & BaseNode & Named & NamedAuditedNode & Node {
    "The color of the Label, used to display the Label."
    color: String!
    "The DateTime this entity was created at."
    createdAt: DateTime!
    "The User who created this entity."
    createdBy: User!
    "The description of this entity."
    description: String!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "Issues which currently have this Label."
    issues(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: IssueFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: IssueOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): IssueConnection!
    "The DateTime this entity was last modified at."
    lastModifiedAt: DateTime!
    "The User who last modified this entity."
    lastModifiedBy: User!
    "The name of this entity."
    name: String!
    "Trackables this Label is part of."
    trackables(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: TrackableFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: TrackableOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): TrackableConnection!
}

"The connection type for Label."
type LabelConnection {
    "A list of all edges of the current page."
    edges: [LabelEdge!]!
    "A list of all nodes of the current page."
    nodes: [Label!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "Identifies the total count of items in the connection."
    totalCount: Int!
}

"An edge in a connection."
type LabelEdge {
    "A cursor used in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Label!
}

type Mutation {
    """
    Adds an AffectedByIssue to an Issue, requires MANAGE_ISSUES on any of the Trackables the Issue is on,
    and AFFECT_ENTITIES_WITH_ISSUES on the Trackable associated with the AffectedByIssue.
    If the Issue already affects the AffectedByIssue, no event is created.

    """
    addAffectedEntityToIssue(
        "Defines the Issue and Trackable"
        input: AddAffectedEntityToIssueInput!
    ): AddAffectedEntityToIssuePayload!
    """
    Adds a Artefact to an Issue, requires MANAGE_ISSUES on any Trackable the issue is on and READ on the Artefact.
    Additionally, the Artefact must be part of a Trackable the Issue is on.
    If the Artefact is already on the Issue, no event is created.

    """
    addArtefactToIssue(
        "Defines the Artefact and Issue"
        input: AddArtefactToIssueInput!
    ): AddArtefactToIssuePayload!
    """
    Adds a ComponentVersion to a Project,
    requires MANAGE_COMPONENTS on the Project and ADD_TO_PROJECTS on the Component associated
    with the ComponentVersion

    """
    addComponentVersionToProject(
        "Defines which ComponentVersion to add to which Project"
        input: AddComponentVersionToProjectInput!
    ): AddComponentVersionToProjectPayload!
    """
    Adds an InterfaceSpecificationVersion (in)visible to ComponentVersions,
    requires ADMIN on the Component of the ComponentVersion to update

    """
    addInterfaceSpecificationVersionToComponentVersion(
        "Defines the InterfaceSpecificationVersion and ComponentVersion"
        input: AddInterfaceSpecificationVersionToComponentVersionInput!
    ): AddInterfaceSpecificationVersionToComponentVersionPayload!
    """
    Pins an Issue on a Trackable, requires MANAGE_ISSUES on the Trackable the Issue should be pinned on.
    Additionally, the Issue must already be on the Trackable.
    If the Issue is already pinned on the Trackable, no event is created.

    """
    addIssueToPinnedIssues(
        "Defines the Issue and Trackable"
        input: AddIssueToPinnedIssuesInput!
    ): AddIssueToPinnedIssuesPayload!
    """
    Adds an Issue to a Trackable, requires MANAGE_ISSUES on the Trackable the Issue should be added to,
    and EXPORT_ISSUES on any Trackable the Issue currently is on.
    If the Issue is already on the Trackable, no event is created.

    """
    addIssueToTrackable(
        "Defines the Issue and Trackable"
        input: AddIssueToTrackableInput!
    ): AddIssueToTrackablePayload!
    """
    Adds a Label to an Issue, requires MANAGE_ISSUES on any Trackable the issue is on and READ on the Label.
    Additionally, the Label must be on at least on Trackable the Issue is on.
    If the Label is already on the Issue, no event is created.

    """
    addLabelToIssue(
        "Defines the Label and Issue"
        input: AddLabelToIssueInput!
    ): AddLabelToIssuePayload!
    """
    Adds a Label to a Trackable, requires MANAGE_LABELS on the Trackable and EXPORT_LABEL on any Trackable
    the Label is on

    """
    addLabelToTrackable(
        "Defines the Label and Trackable"
        input: AddLabelToTrackableInput!
    ): AddLabelToTrackablePayload!
    """
    Changes the type of an Assignment, requires MANAGE_ISSUES on any of the Trackables the Issue the Assignment
    is part of is on.
    Additionally, if present, the new type must be compatible with the template of the Issue.
    If the current type of the Assignment is equal to the new one, no event is created.

    """
    changeAssignmentType(
        "Defines the Assignment to update and its new AssignmentType"
        input: ChangeAssignmentTypeInput!
    ): ChangeAssignmentTypePayload!
    """
    Changes the `dueDate` of an Issue requires MANAGE_ISSUES on any of the Trackables the Issue is on.
    If the `dueDate` is equal to the already existing `dueDate`, no event is created.

    """
    changeIssueDueDate(
        "Defines the Issue and new `dueDate`"
        input: ChangeIssueDueDateInput!
    ): ChangeIssueDueDatePayload!
    """
    Changes the `estimatedTime` of an Issue requires MANAGE_ISSUES on any of the Trackables the Issue is on.
    If the `estimatedTime` is equal to the already existing `estimatedTime`, no event is created.

    """
    changeIssueEstimatedTime(
        "Defines the Issue and new `estimatedTime`"
        input: ChangeIssueEstimatedTimeInput!
    ): ChangeIssueEstimatedTimePayload!
    """
    Changes the `priority` of an Issue requires MANAGE_ISSUES on any of the Trackables the Issue is on.
    Additionally, the IssuePriority must be defined by the Template of the Issue.
    If the `priority` is equal to the already existing `priority`, no event is created.

    """
    changeIssuePriority(
        "Defines the Issue and new `priority`"
        input: ChangeIssuePriorityInput!
    ): ChangeIssuePriorityPayload!
    """
    Changes the type of an IssueRelation, requires MANAGE_ISSUES on any of the Trackables the Issue the
    IssueRelation is part of is on.
    Additionally, if present, the new type must be compatible with the template of the Issue.
    If the current type of the IssueRelation is equal to the new one, no event is created.

    """
    changeIssueRelationType(
        "Defines the IssueRelation to update and its new IssueRelationType"
        input: ChangeIssueRelationTypeInput!
    ): ChangeIssueRelationTypePayload!
    """
    Changes the `spentTime` of an Issue requires MANAGE_ISSUES on any of the Trackables the Issue is on.
    If the `spentTime` is equal to the already existing `spentTime`, no event is created.

    """
    changeIssueSpentTime(
        "Defines the Issue and new `spentTime`"
        input: ChangeIssueSpentTimeInput!
    ): ChangeIssueSpentTimePayload!
    """
    Changes the `startDate` of an Issue requires MANAGE_ISSUES on any of the Trackables the Issue is on.
    If the `startDate` is equal to the already existing `startDate`, no event is created.

    """
    changeIssueStartDate(
        "Defines the Issue and new `startDate`"
        input: ChangeIssueStartDateInput!
    ): ChangeIssueStartDatePayload!
    """
    Changes the `state` of an Issue requires MANAGE_ISSUES on any of the Trackables the Issue is on.
    Additionally, the IssueState must be defined by the Template of the Issue.
    If the `state` is equal to the already existing `state`, no event is created.

    """
    changeIssueState(
        "Defines the Issue and new `state`"
        input: ChangeIssueStateInput!
    ): ChangeIssueStatePayload!
    """
    Changes the Template of an Issue. Requires MANAGE_ISSUES on any of the Trackables the Issue is on.
    Incompatible old values of type, state, priority, templated fields, and priorities of Assignments and outgoing
    IssueRelations are updated with provided new values, requires that those new values are compatible with the new
    template. If the old value already is compatible with the new template, fields are not changed!
    In case of priority and types of Assignments and outgoing IssueRelations, if the old value is incompatible and
    no new value was provided, the old value is removed.
    Only creates an event if the new template is not equal to the current template.
    Events for other changes can be found in the childItems of the returned event.

    """
    changeIssueTemplate(
        "Defines the new IssueTemplate, the Issue and other fields to update"
        input: ChangeIssueTemplateInput!
    ): ChangeIssueTemplatePayload!
    """
    Changes the value of a templated field on an Issue, requires MANAGE_ISSUES on any of the Trackables
    the Issue is on.
    Additionally, the field with the name must be defined by the template of the Issue, and the provided new value
    must be compatible.
    If the new value is equal to the current value of the templated field, no event is created.

    """
    changeIssueTemplatedField(
        "Defines the Issue, the templated field and its new value"
        input: ChangeIssueTemplatedFieldInput!
    ): ChangeIssueTemplatedFieldPayload!
    """
    Changes the `title` of an Issue requires MANAGE_ISSUES on any of the Trackables the Issue is on.
    If the `title` is equal to the already existing `title`, no event is created.

    """
    changeIssueTitle(
        "Defines the Issue and new `title`"
        input: ChangeIssueTitleInput!
    ): ChangeIssueTitlePayload!
    """
    Changes the `type` of an Issue requires MANAGE_ISSUES on any of the Trackables the Issue is on.
    Additionally, the IssueType must be defined by the Template of the Issue.
    If the `type` is equal to the already existing `type`, no event is created.

    """
    changeIssueType(
        "Defines the Issue and new `type`"
        input: ChangeIssueTypeInput!
    ): ChangeIssueTypePayload!
    "Creates a new Artefact on a Trackable. Requires MANAGE_ARTEFACTS on the provided Trackable."
    createArtefact(
        "Defines the created Artefact"
        input: CreateArtefactInput!
    ): CreateArtefactPayload!
    "Creates a new ArtefactTemplate, requires CAN_CREATE_TEMPLATES"
    createArtefactTemplate(
        "Defines the created ArtefactTemplate"
        input: CreateArtefactTemplateInput!
    ): CreateArtefactTemplatePayload!
    """
    Assigns a User to an Issue by creating an Assignment, requires MANAGE_ISSUES on any of the Trackables the
    Issue is on.
    Additionally, if present, the type must be compatible with the template of the Issue.

    """
    createAssignment(
        "Defines the Issue, User, and optional AssignmentType"
        input: CreateAssignmentInput!
    ): CreateAssignmentPayload!
    """
    Creates a new Component, requires CAN_CREATE_COMPONENTS.
    Automatically generates a default ComponentPermission which grants the authenticated user READ and ADMIN

    """
    createComponent(
        "Defines the created Component"
        input: CreateComponentInput!
    ): CreateComponentPayload!
    """
    Creates a new ComponentPermission, requires ADMIN on all Components which should be added to the created
    permission.

    """
    createComponentPermission(
        "Defines the created ComponentPermission"
        input: CreateComponentPermissionInput!
    ): CreateComponentPermissionPayload!
    "Creates a new ComponentTemplate, requires CAN_CREATE_TEMPLATES"
    createComponentTemplate(
        "Defines the created ComponentTemplate"
        input: CreateComponentTemplateInput!
    ): CreateComponentTemplatePayload!
    "Creates a new ComponentVersion, requires ADMIN on the Component."
    createComponentVersion(
        "Defines the created ComponentVersion"
        input: CreateComponentVersionInput!
    ): CreateComponentVersionPayload!
    "Creates a new GlobalPermission, requires that the user is an admin"
    createGlobalPermission(
        "Defines the created GlobalPermission"
        input: CreateGlobalPermissionInput!
    ): CreateGlobalPermissionPayload!
    """
    Creates a new IMS, requires CAN_CREATE_IMSS.
    Automatically generates a default IMSPermission which grants the authorized user READ and ADMIN

    """
    createIMS(
        "Defines the created IMS"
        input: CreateIMSInput!
    ): CreateIMSPayload!
    """
    Creates a new IMSPermission, requires ADMIN on all IMSs which should be added to the created
    permission.

    """
    createIMSPermission(
        "Defines the created IMSPermission"
        input: CreateIMSPermissionInput!
    ): CreateIMSPermissionPayload!
    """
    Creates a new IMSProject, requirse SYNC_TRACKABLES on the specified IMS
    AND MANAGE_IMS on the specified Trackable

    """
    createIMSProject(
        "Defines the created IMSProject"
        input: CreateIMSProjectInput!
    ): CreateIMSProjectPayload!
    "Creates a new InterfacePart, requires ADMIN on the Component of the InterfaceSpecification."
    createInterfacePart(
        "Defines the created InterfacePart"
        input: CreateInterfacePartInput!
    ): CreateInterfacePartPayload!
    "Creates a new InterfaceSpecification, requires ADMIN on the Component."
    createInterfaceSpecification(
        "Defines the created InterfaceSpecification"
        input: CreateInterfaceSpecificationInput!
    ): CreateInterfaceSpecificationPayload!
    "Creates a new InterfaceSpecificationTemplate, requires CAN_CREATE_TEMPLATES"
    createInterfaceSpecificationTemplate(
        "Defines the created InterfaceSpecificationTemplate"
        input: CreateInterfaceSpecificationTemplateInput!
    ): CreateInterfaceSpecificationTemplatePayload!
    "Creates a new InterfaceSpecificationVersion, requires ADMIN on the Component of the InterfaceSpecification."
    createInterfaceSpecificationVersion(
        "Defines the created InterfaceSpecificationVersion"
        input: CreateInterfaceSpecificationVersionInput!
    ): CreateInterfaceSpecificationVersionPayload!
    """
    Creates a new IntraComponentDependencySpecification, requires ADMIN on the Component associated with the
    specified ComponentVersion.

    """
    createIntraComponentDependencySpecification(
        "Defines the created IntraComponentDependencySpecification"
        input: CreateIntraComponentDependencySpecificationInput!
    ): CreateIntraComponentDependencySpecificationPayload!
    """
    Creates a new Issue on at least one Trackable, requires CREATE_ISSUES on all Trackables it should be created on.
    Additionally, checks that the `type`, `state` and `templatedFields` are compatible with the `template`.

    """
    createIssue(
        "Defines the created Issue"
        input: CreateIssueInput!
    ): CreateIssuePayload!
    """
    Creates an IssueComment, requires COMMENT on any of the Trackables the Issue is on.
    Requires READ on referenced Artefacts, additionally, those must be part of a Trackable the Issue is on.
    If present, the Comment it answers must be on the same Issue.

    """
    createIssueComment(
        "Defines the IssueComment"
        input: CreateIssueCommentInput!
    ): CreateIssueCommentPayload!
    """
    Creates an IssueRelation, requires MANAGE_ISSUES on any of the Trackables the Issue is on.
    Additionally, if present, the type must be compatible with the template of the Issue.

    """
    createIssueRelation(
        "Defines the Issue, related Issue, and optional IssueRelationType"
        input: CreateIssueRelationInput!
    ): CreateIssueRelationPayload!
    "Creates a new IssueTemplate, requires CAN_CREATE_TEMPLATES"
    createIssueTemplate(
        "Defines the created IssueTemplate"
        input: CreateIssueTemplateInput!
    ): CreateIssueTemplatePayload!
    """
    Creates a new Label on at least one Trackable. Requires MANAGE_LABELS on all provided Trackables.

    """
    createLabel(
        "Defines the created Label"
        input: CreateLabelInput!
    ): CreateLabelPayload!
    """
    Creates a new Project, requires CAN_CREATE_PROJECTS.
    Automatically generates a default ProjectPermission which grants the authorized user READ and ADMIN

    """
    createProject(
        "Defines the created Project"
        input: CreateProjectInput!
    ): CreateProjectPayload!
    """
    Creates a new ProjectPermission, requires ADMIN on all Projects which should be added to the created
    permission.

    """
    createProjectPermission(
        "Defines the created ProjectPermission"
        input: CreateProjectPermissionInput!
    ): CreateProjectPermissionPayload!
    """
    Creates a new Relation, requires RELATE_FROM_COMPONENT on the Component associated with start.

    """
    createRelation(
        "Defines the created Relation"
        input: CreateRelationInput!
    ): CreateRelationPayload!
    "Creates a new RelationTemplate, requires CAN_CREATE_TEMPLATES"
    createRelationTemplate(
        "Defines the created RelationTemplate"
        input: CreateRelationTemplateInput!
    ): CreateRelationTemplatePayload!
    """
    Deletes the Artefact, requires MANAGE_ARTEFACTS on the Trackable it is part of. Removes it from all Issues.

    """
    deleteArtefact(
        "Defines which Artefact to delete"
        input: DeleteNodeInput!
    ): DeleteNodePayload!
    "Deletes the specified Component, requires ADMIN on the component to delete"
    deleteComponent(
        "Defines which Component to delete"
        input: DeleteNodeInput!
    ): DeleteNodePayload!
    """
    Deletes a ComponentPermission, requires ADMIN on all Components the permission currently affects.
    Ensures that after the permission is deleted, all previously affected Components still have a permission which
    grants ADMIN to at least one user.

    """
    deleteComponentPermission(
        "Defines which ComponentPermission to delete"
        input: DeleteNodeInput!
    ): DeleteNodePayload!
    "Deletes the specified ComponentVersion, requires ADMIN on the Component of the ComponentVersion to delete"
    deleteComponentVersion(
        "Defines which ComponentVersion to delete"
        input: DeleteNodeInput!
    ): DeleteNodePayload!
    "Deletes a GlobalPermission, requires that the user is an admin"
    deleteGlobalPermission(
        "Defines which GlobalPermission to delete"
        input: DeleteNodeInput!
    ): DeleteNodePayload!
    """
    Deletes the specified IMS, requires ADMIN on the IMS to delete.
    Also deletes all associated IMSProjects

    """
    deleteIMS(
        "Defines which IMS to delete"
        input: DeleteNodeInput!
    ): DeleteNodePayload!
    """
    Deletes a IMSPermission, requires ADMIN on all IMSs the permission currently affects.
    Ensures that after the permission is deleted, all previously affected IMSs still have a permission which
    grants ADMIN to at least one user.

    """
    deleteIMSPermission(
        "Defines which IMSPermission to delete"
        input: DeleteNodeInput!
    ): DeleteNodePayload!
    """
    Deletes the specified IMSProject, requirse ADMIN on the IMS associted with the
    specified IMSProject OR MANAGE_IMS on the Trackable associated with the specified
    IMSProject.

    """
    deleteIMSProject(
        "Defines which IMSProject to delete"
        input: DeleteNodeInput!
    ): DeleteNodePayload!
    """
    Deletes the specified InterfacePart,
    requires ADMIN on the Component of the InterfaceSpecification of the InterfacePart to delete
    """
    deleteInterfacePart(
        "Defines which InterfacePart to delete"
        input: DeleteNodeInput!
    ): DeleteNodePayload!
    "Deletes the specified InterfaceSpecification, requires ADMIN on the Component of the InterfaceSpecification to delete"
    deleteInterfaceSpecification(
        "Defines which InterfaceSpecification to delete"
        input: DeleteNodeInput!
    ): DeleteNodePayload!
    """
    Deletes the specified InterfaceSpecificationVersion,
    requires ADMIN on the Component of the InterfaceSpecification of the InterfaceSpecificationVersion to delete

    """
    deleteInterfaceSpecificationVersion(
        "Defines which InterfaceSpecificationVersion to delete"
        input: DeleteNodeInput!
    ): DeleteNodePayload!
    """
    Deletes the specified IntraComponentDependencySpecification, requires ADMIN on the Component associated with the
    IntraComponentDependencySpecification to delete.
    """
    deleteIntraComponentDependencySpecification(
        "Defines which IntraComponentDependencySpecification to delete"
        input: DeleteNodeInput!
    ): DeleteNodePayload!
    "Deletes the specified Issue, requires MODERATOR on all of the Trackables the Issue is on."
    deleteIssue(
        "Defines which Issue to delete"
        input: DeleteNodeInput!
    ): DeleteNodePayload!
    """
    Deletes an IssueComment. If the user created the IssueComment, requires READ on any of the Trackables the
    Issue is on. Otherwise, requires MODERATOR on any of the Trackables the Issue is on.
    The IssueComment then is marked as deleted, its body set to "", and the referenced Artefacts are cleared.
    It is no longer possible to update the IssueComment.

    """
    deleteIssueComment(
        "Defines how to update which IssueComment"
        input: DeleteNodeInput!
    ): DeleteIssueCommentPayload!
    """
    Deletes the Label, requires MANAGE_LABELS on all Trackables it is on.
    Removes it from all Issues. Note that the Label will still be visible in the timeline of Issues.

    """
    deleteLabel(
        "Defines which Label to delete"
        input: DeleteNodeInput!
    ): DeleteNodePayload!
    "Deletes the specified Project, requires ADMIN on the project to delete"
    deleteProject(
        "Defines which Project to delete"
        input: DeleteNodeInput!
    ): DeleteNodePayload!
    """
    Deletes a ProjectPermission, requires ADMIN on all Projects the permission currently affects.
    Ensures that after the permission is deleted, all previously affected Projects still have a permission which
    grants ADMIN to at least one user.

    """
    deleteProjectPermission(
        "Defines which ProjectPermission to delete"
        input: DeleteNodeInput!
    ): DeleteNodePayload!
    """
    Deletes the specified Relation, requires RELATE_FROM_COMPONENT on the Component associated with start.

    """
    deleteRelation(
        "Defines which Relation to delete"
        input: DeleteNodeInput!
    ): DeleteNodePayload!
    """
    Removes an AffectedByIssue from an Issue, requires MANAGE_ISSUES on any of the Trackables the Issue is on,
    or AFFECT_ENTITIES_WITH_ISSUES on the Trackable associated with the AffectedByIssue.
    If the Issue does not affect the AffectedByIssue, no event is created.

    """
    removeAffectedEntityFromIssue(
        "Defines the Issue and Trackable"
        input: RemoveAffectedEntityFromIssueInput!
    ): RemoveAffectedEntityFromIssuePayload!
    """
    Removes a Artefact from an Issue, requires MANAGE_ISSUES on any Trackable the issue is on.
    If the Artefact is not on the Issue, no event is created.

    """
    removeArtefactFromIssue(
        "Defines the Artefact and Issue"
        input: RemoveArtefactFromIssueInput!
    ): RemoveArtefactFromIssuePayload!
    """
    Removes an Assignment from an Issue, require MANAGE_ISSUES on any of the Trackables the Issue the Assignment
    is part of is on.
    If the Assignment was already removed, no event is created.

    """
    removeAssignment(
        "Defines the Assignment to remove"
        input: RemoveAssignmentInput!
    ): RemoveAssignmentPayload!
    """
    Removes a ComponentVersion from a Project,
    requires MANAGE_COMPONENTS on the Project

    """
    removeComponentVersionFromProject(
        "Defines which ComponentVersion to remove from which Project"
        input: RemoveComponentVersionFromProjectInput!
    ): RemoveComponentVersionFromProjectPayload!
    """
    Removes an InterfaceSpecificationVersion (in)visible from ComponentVersions,
    requires ADMIN on the Component of the ComponentVersion to update

    """
    removeInterfaceSpecificationVersionFromComponentVersion(
        "Defines the InterfaceSpecificationVersion and ComponentVersion"
        input: RemoveInterfaceSpecificationVersionFromComponentVersionInput!
    ): RemoveInterfaceSpecificationVersionFromComponentVersionPayload!
    """
    Unpins the Issue on a Trackable, requires MANAGE_ISSUES on the Trackable where the Issue should
    be unpinned.
    If the Issue is not pinned on the Trackable, no event is created.

    """
    removeIssueFromPinnedIssues(
        "Defines the Issue and Trackable"
        input: RemoveIssueFromPinnedIssuesInput!
    ): RemoveIssueFromPinnedIssuesPayload!
    """
    Removes an Issue from a Trackable, requires MANAGE_ISSUES on the Trackable where the Issue should
    be removed from.
    Additionally requires that the Issue is on at least one Trackable afterwards.
    If the Issue is not on the Trackable, no event is created.
    Also removes any Artefacts, Labels and AffectedByIssue which cannot be any more on the Issue,
    and unpins the issue on the defined Trackable if it was pinned.
    The created events can be found in the childItems of the returned RemovedFromTrackableEvent.

    """
    removeIssueFromTrackable(
        "Defines the Issue and Trackable"
        input: RemoveIssueFromTrackableInput!
    ): RemoveIssueFromTrackablePayload!
    """
    Removes an IssueRelation from an Issue, require MANAGE_ISSUES on any of the Trackables the Issue the
    IssueRelation starts at is on.
    If the IssueRelation was already removed, no event is created.

    """
    removeIssueRelation(
        "Defines the IssueRelation to remove"
        input: RemoveIssueRelationInput!
    ): RemoveIssueRelationPayload!
    """
    Removes a Label from an Issue, requires MANAGE_ISSUES on any Trackable the issue is on.
    If the Label is not on the Issue, no event is created.

    """
    removeLabelFromIssue(
        "Defines the Label and Issue"
        input: RemoveLabelFromIssueInput!
    ): RemoveLabelFromIssuePayload!
    """
    Removes a Label from a Trackable, requires MANAGE_LABELS on the Trackable.
    Removes the Label from all Issues where the Label cannot be anymore, as the Trackable of the Label and the Issue
    are now disjoint.

    """
    removeLabelFromTrackable(
        "Defines the Label and Trackable"
        input: RemoveLabelFromTrackableInput!
    ): RemoveLabelFromTrackablePayload!
    """
    Updates the specified Artefact, requires MANAGE_ARTEFACTS on the Trackable the Artefact is part of

    """
    updateArtefact(
        "Defines which Artefact to update and how to update it"
        input: UpdateArtefactInput!
    ): UpdateArtefactPayload!
    """
    Updates an IssueComment. If the user created the IssueComment, requires READ on any of the Trackables the
    Issue is on. Otherwise, requires MODERATOR on any of the Trackables the Issue is on.

    """
    updateBody(
        "Defines how to update which Body"
        input: UpdateBodyInput!
    ): UpdateBodyPayload!
    "Updates the specified Component, requires ADMIN on the component to update"
    updateComponent(
        "Defines which Component to update and how to update it"
        input: UpdateComponentInput!
    ): UpdateComponentPayload!
    """
    Updates a ComponentPermission, requires ADMIN on all Components the permission currently affects.
    Ensures that after the update, all affected Components still have a permission which grants ADMIN to at least
    one user.

    """
    updateComponentPermission(
        "Defines which ComponentPermission to update and how to update it"
        input: UpdateComponentPermissionInput!
    ): UpdateComponentPermissionPayload!
    "Updates the specified ComponentVersion, requires ADMIN on the Component of the ComponentVersion to update"
    updateComponentVersion(
        "Defines which ComponentVersion to update and how to update it"
        input: UpdateComponentVersionInput!
    ): UpdateComponentVersionPayload!
    "Updates a GlobalPermission, requires that the user is an admin"
    updateGlobalPermission(
        "Defines which GlobalPermission to update and how to update it"
        input: UpdateGlobalPermissionInput!
    ): UpdateGlobalPermissionPayload!
    """
    Updates a GropiusUser. Only the same user and admin users can update a GropiusUser.
    Only admin users can update isAdmin

    """
    updateGropiusUser(
        "Defines which GropiusUser to update and how to update it"
        input: UpdateGropiusUserInput!
    ): UpdateGropiusUserPayload!
    "Updates the specified IMS, requires ADMIN on the IMS."
    updateIMS(
        "Defines which IMS to update and how to update it"
        input: UpdateIMSInput!
    ): UpdateIMSPayload!
    """
    Updates a IMSPermission, requires ADMIN on all IMSs the permission currently affects.
    Ensures that after the update, all affected IMSs still have a permission which grants ADMIN to at least
    one user.

    """
    updateIMSPermission(
        "Defines which IMSPermission to update and how to update it"
        input: UpdateIMSPermissionInput!
    ): UpdateIMSPermissionPayload!
    """
    Updates the specified IMSProject, requirse SYNC_TRACKABLES on the IMS associted with the
    specified IMSProject AND MANAGE_IMS on the Trackable associated with the specified
    IMSProject.

    """
    updateIMSProject(
        "Defines which IMSProject to update and how to update it"
        input: UpdateIMSProjectInput!
    ): UpdateIMSProjectPayload!
    """
    Updates the specified Interface,
    requires ADMIN on the Component of the ComponentVersion of the InterfaceDefinition of the Interface  to update

    """
    updateInterface(
        "Defines which Interface to update and how to update it"
        input: UpdateInterfaceInput!
    ): UpdateInterfacePayload!
    """
    Updates the specified InterfaceDefinition,
    requires ADMIN on the Component of the ComponentVersion of the InterfaceDefinition to update

    """
    updateInterfaceDefinition(
        "Defines which InterfaceDefinition to update and how to update it"
        input: UpdateInterfaceDefinitionInput!
    ): UpdateInterfaceDefinitionPayload!
    """
    Updates the specified InterfacePart,
    requires ADMIN on the Component of the InterfaceSpecification of the InterfacePart to update

    """
    updateInterfacePart(
        "Defines which InterfacePart to update and how to update it"
        input: UpdateInterfacePartInput!
    ): UpdateInterfacePartPayload!
    "Updates the specified InterfaceSpecification, requires ADMIN on the Component of the InterfaceSpecification to update"
    updateInterfaceSpecification(
        "Defines which InterfaceSpecification to update and how to update it"
        input: UpdateInterfaceSpecificationInput!
    ): UpdateInterfaceSpecificationPayload!
    """
    Updates the specified InterfaceSpecificationVersion,
    requires ADMIN on the Component of the InterfaceSpecification of the InterfaceSpecificationVersion to update

    """
    updateInterfaceSpecificationVersion(
        "Defines which InterfaceSpecificationVersion to update and how to update it"
        input: UpdateInterfaceSpecificationVersionInput!
    ): UpdateInterfaceSpecificationVersionPayload!
    """
    Updates the specified IntraComponentDependencySpecification, requires ADMIN on the Component associated with the
    IntraComponentDependencySpecification to update.
    """
    updateIntraComponentDependencySpecification(
        "Defines which IntraComponentDependencySpecification to update and how to update it"
        input: UpdateIntraComponentDependencySpecificationInput!
    ): UpdateIntraComponentDependencySpecificationPayload!
    """
    Updates an IssueComment. If the user created the IssueComment, requires READ on any of the Trackables the
    Issue is on. Otherwise, requires MODERATOR on any of the Trackables the Issue is on.
    Requires READ on referenced Artefacts, additionally, added ones must be part of a Trackable the Issue is on.

    """
    updateIssueComment(
        "Defines how to update which IssueComment"
        input: UpdateIssueCommentInput!
    ): UpdateIssueCommentPayload!
    "Updates the specified Label, requires MANAGE_LABELS on any Trackable the Label is on"
    updateLabel(
        "Defines which Label to update and how to update it"
        input: UpdateLabelInput!
    ): UpdateLabelPayload!
    "Updates the specified Project, requires ADMIN on the project to update"
    updateProject(
        "Defines which Project to update and how to update it"
        input: UpdateProjectInput!
    ): UpdateProjectPayload!
    """
    Updates a ProjectPermission, requires ADMIN on all Projects the permission currently affects.
    Ensures that after the update, all affected Projects still have a permission which grants ADMIN to at least
    one user.

    """
    updateProjectPermission(
        "Defines which ProjectPermission to update and how to update it"
        input: UpdateProjectPermissionInput!
    ): UpdateProjectPermissionPayload!
    """
    Updates the specified Relation, requires RELATE_FROM_COMPONENT on the Component associated with start.

    """
    updateRelation(
        "Defines which Relation to update and how to update it"
        input: UpdateRelationInput!
    ): UpdateRelationPayload!
    "Updates whether the current user allows sync self/others on the specified target"
    updateSyncPermissions(
        "Defines which SyncPermissionTarget to update and how to update it"
        input: UpdateSyncPermissionsInput!
    ): UpdateSyncPermissionsPayload!
    "Updates the deprecation state of the template, requires CAN_CREATE_TEMPLATES"
    updateTemplateDeprecationStatus(
        "Defines the new deprecation status and the Template to update"
        input: UpdateTemplateDeprecationStatusInput!
    ): UpdateTemplateDeprecationStatusPayload!
}

"""
Event representing that the type of an incoming IssueRelation changed.
READ is granted if READ is granted on `issue`.

"""
type OutgoingRelationTypeChangedEvent implements AuditedNode & BaseNode & Node & RelationTypeChangedEvent & TimelineItem {
    "The DateTime this entity was created at."
    createdAt: DateTime!
    "The User who created this entity."
    createdBy: User!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "The Issue this TimelineItem is part of."
    issue: Issue
    "The IssueRelation of which the type was changed"
    issueRelation: IssueRelation!
    "The DateTime this entity was last modified at."
    lastModifiedAt: DateTime!
    "The User who last modified this entity."
    lastModifiedBy: User!
    "The new type."
    newType: IssueRelationType
    "The old type."
    oldType: IssueRelationType
    "If existing, the parent TimelineItem"
    parentItem: ParentTimelineItem
}

"Information about the current page in a connection"
type PageInfo {
    "When paginating backwards, the cursor to continue"
    endCursor: String
    "When paginating forwards, are there more items?"
    hasNextPage: Boolean!
    "When paginating backwards, are there more items?"
    hasPreviousPage: Boolean!
    "When paginating forwards, the cursor to continue"
    startCursor: String
}

"""
Event representing that the priority of an Issue changed.
READ is granted if READ is granted on `issue`.

"""
type PriorityChangedEvent implements AuditedNode & BaseNode & Node & TimelineItem {
    "The DateTime this entity was created at."
    createdAt: DateTime!
    "The User who created this entity."
    createdBy: User!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "The Issue this TimelineItem is part of."
    issue: Issue
    "The DateTime this entity was last modified at."
    lastModifiedAt: DateTime!
    "The User who last modified this entity."
    lastModifiedBy: User!
    "The new priority."
    newPriority: IssuePriority
    "The old priority."
    oldPriority: IssuePriority
    "If existing, the parent TimelineItem"
    parentItem: ParentTimelineItem
}

"""
A project of the Gropius system.
Consists of a set of ComponentVersions, which form a graph with the Relations between them.
Can be affected by issues.
Can have issues, labels and artefacts as this is a Trackable.
READ is granted via an associated ProjectPermission.

"""
type Project implements AffectedByIssue & BaseNode & Named & NamedNode & Node & Trackable {
    "The issues which affect this entity"
    affectingIssues(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: IssueFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: IssueOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): IssueConnection!
    "Artefacts of this trackable, typically some kind of file."
    artefacts(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: ArtefactFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: ArtefactOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): ArtefactConnection!
    "The ComponentVersions this consists of."
    components(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: ComponentVersionFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: ComponentVersionOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): ComponentVersionConnection!
    "The description of this entity."
    description: String!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    """
    The set of Issues which are part of this Trackable.
    An Issue has to be part of a Trackable to use the Labels and Artefacts defined by the Trackable.

    """
    issues(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: IssueFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: IssueOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): IssueConnection!
    "The set of Labels which can be added to issues of this trackable."
    labels(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: LabelFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: LabelOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): LabelConnection!
    "The name of this entity."
    name: String!
    "Permissions for this Project."
    permissions(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: ProjectPermissionFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: ProjectPermissionOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): ProjectPermissionConnection!
    "Issues which are pinned to this trackable, subset of `issues`."
    pinnedIssues(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: IssueFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: IssueOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): IssueConnection!
    "If existing, the URL of the repository (e.g. a GitHub repository)."
    repositoryURL: URL
    "IMSProjects this Trackable is synced to and from."
    syncsTo(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: IMSProjectFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: IMSProjectOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): IMSProjectConnection!
}

"The connection type for Project."
type ProjectConnection {
    "A list of all edges of the current page."
    edges: [ProjectEdge!]!
    "A list of all nodes of the current page."
    nodes: [Project!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "Identifies the total count of items in the connection."
    totalCount: Int!
}

"An edge in a connection."
type ProjectEdge {
    "A cursor used in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Project!
}

"NodePermission to grant specific permissions to a set of Projects."
type ProjectPermission implements BaseNode & BasePermission & Named & NamedNode & Node {
    "If, the permission is granted to all users. Use with caution."
    allUsers: Boolean!
    "The description of this entity."
    description: String!
    "All permissions this Permission grants"
    entries: [ProjectPermissionEntry!]!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "The name of this entity."
    name: String!
    "Nodes on which the Permission is granted."
    nodesWithPermission(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: ProjectFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: ProjectOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): ProjectConnection!
    "GropiusUsers granted this Permission"
    users(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: GropiusUserFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: GropiusUserOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): GropiusUserConnection!
}

"The connection type for ProjectPermission."
type ProjectPermissionConnection {
    "A list of all edges of the current page."
    edges: [ProjectPermissionEdge!]!
    "A list of all nodes of the current page."
    nodes: [ProjectPermission!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "Identifies the total count of items in the connection."
    totalCount: Int!
}

"An edge in a connection."
type ProjectPermissionEdge {
    "A cursor used in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: ProjectPermission!
}

type Query {
    "Query for nodes of type ArtefactTemplate"
    artefactTemplates(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: ArtefactTemplateFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: ArtefactTemplateOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): ArtefactTemplateConnection!
    "Query for nodes of type ComponentTemplate"
    componentTemplates(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: ComponentTemplateFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: ComponentTemplateOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): ComponentTemplateConnection!
    "Query for nodes of type Component"
    components(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: ComponentFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: ComponentOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): ComponentConnection!
    "The current authenticated user"
    currentUser: GropiusUser
    "Checks if the current user has a specific global permission"
    hasGlobalPermission(
        "The permission to check for"
        permission: PermissionEntry!
    ): Boolean!
    "Query for nodes of type IMSTemplate"
    imsTemplates(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: IMSTemplateFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: IMSTemplateOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): IMSTemplateConnection!
    "Query for nodes of type IMS"
    imss(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: IMSFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: IMSOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): IMSConnection!
    "Query for nodes of type InterfaceSpecificationTemplate"
    interfaceSpecificationTemplates(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: InterfaceSpecificationTemplateFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: InterfaceSpecificationTemplateOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): InterfaceSpecificationTemplateConnection!
    "Query for nodes of type IssueTemplate"
    issueTemplates(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: IssueTemplateFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: IssueTemplateOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): IssueTemplateConnection!
    "Get a Node by id"
    node(
        "The id of the node to get"
        id: ID!
    ): Node
    "Query for nodes of type Project"
    projects(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: ProjectFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: ProjectOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): ProjectConnection!
    "Query for nodes of type RelationTemplate"
    relationTemplates(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: RelationTemplateFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: RelationTemplateOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): RelationTemplateConnection!
    "Search for nodes of type AffectedByIssue"
    searchAffectedByIssues(
        "Filter for specific items"
        filter: AffectedByIssueFilterInput,
        "Get the first n items."
        first: Int!,
        "Search query nodes must match"
        query: String!,
        "Skips n items."
        skip: Int
    ): [AffectedByIssue!]!
    "Search for nodes of type AssignmentType"
    searchAssignmentTypes(
        "Filter for specific items"
        filter: AssignmentTypeFilterInput,
        "Get the first n items."
        first: Int!,
        "Search query nodes must match"
        query: String!,
        "Skips n items."
        skip: Int
    ): [AssignmentType!]!
    "Search for nodes of type ComponentPermission"
    searchComponentPermissions(
        "Filter for specific items"
        filter: ComponentPermissionFilterInput,
        "Get the first n items."
        first: Int!,
        "Search query nodes must match"
        query: String!,
        "Skips n items."
        skip: Int
    ): [ComponentPermission!]!
    "Search for nodes of type ComponentTemplate"
    searchComponentTemplates(
        "Filter for specific items"
        filter: ComponentTemplateFilterInput,
        "Get the first n items."
        first: Int!,
        "Search query nodes must match"
        query: String!,
        "Skips n items."
        skip: Int
    ): [ComponentTemplate!]!
    "Search for nodes of type ComponentVersion"
    searchComponentVersions(
        "Filter for specific items"
        filter: ComponentVersionFilterInput,
        "Get the first n items."
        first: Int!,
        "Search query nodes must match"
        query: String!,
        "Skips n items."
        skip: Int
    ): [ComponentVersion!]!
    "Search for nodes of type Component"
    searchComponents(
        "Filter for specific items"
        filter: ComponentFilterInput,
        "Get the first n items."
        first: Int!,
        "Search query nodes must match"
        query: String!,
        "Skips n items."
        skip: Int
    ): [Component!]!
    "Search for nodes of type GlobalPermission"
    searchGlobalPermissions(
        "Filter for specific items"
        filter: GlobalPermissionFilterInput,
        "Get the first n items."
        first: Int!,
        "Search query nodes must match"
        query: String!,
        "Skips n items."
        skip: Int
    ): [GlobalPermission!]!
    "Search for nodes of type GropiusUser"
    searchGropiusUsers(
        "Filter for specific items"
        filter: GropiusUserFilterInput,
        "Get the first n items."
        first: Int!,
        "Search query nodes must match"
        query: String!,
        "Skips n items."
        skip: Int
    ): [GropiusUser!]!
    "Search for nodes of type IMSPermission"
    searchIMSPermissions(
        "Filter for specific items"
        filter: IMSPermissionFilterInput,
        "Get the first n items."
        first: Int!,
        "Search query nodes must match"
        query: String!,
        "Skips n items."
        skip: Int
    ): [IMSPermission!]!
    "Search for nodes of type IssuePriority"
    searchIssuePriorities(
        "Filter for specific items"
        filter: IssuePriorityFilterInput,
        "Get the first n items."
        first: Int!,
        "Search query nodes must match"
        query: String!,
        "Skips n items."
        skip: Int
    ): [IssuePriority!]!
    "Search for nodes of type IssueRelationType"
    searchIssueRelationTypes(
        "Filter for specific items"
        filter: IssueRelationTypeFilterInput,
        "Get the first n items."
        first: Int!,
        "Search query nodes must match"
        query: String!,
        "Skips n items."
        skip: Int
    ): [IssueRelationType!]!
    "Search for nodes of type IssueState"
    searchIssueStates(
        "Filter for specific items"
        filter: IssueStateFilterInput,
        "Get the first n items."
        first: Int!,
        "Search query nodes must match"
        query: String!,
        "Skips n items."
        skip: Int
    ): [IssueState!]!
    "Search for nodes of type IssueTemplate"
    searchIssueTemplates(
        "Filter for specific items"
        filter: IssueTemplateFilterInput,
        "Get the first n items."
        first: Int!,
        "Search query nodes must match"
        query: String!,
        "Skips n items."
        skip: Int
    ): [IssueTemplate!]!
    "Search for nodes of type IssueType"
    searchIssueTypes(
        "Filter for specific items"
        filter: IssueTypeFilterInput,
        "Get the first n items."
        first: Int!,
        "Search query nodes must match"
        query: String!,
        "Skips n items."
        skip: Int
    ): [IssueType!]!
    "Search for nodes of type Issue"
    searchIssues(
        "Filter for specific items"
        filter: IssueFilterInput,
        "Get the first n items."
        first: Int!,
        "Search query nodes must match"
        query: String!,
        "Skips n items."
        skip: Int
    ): [Issue!]!
    "Search for nodes of type Label"
    searchLabels(
        "Filter for specific items"
        filter: LabelFilterInput,
        "Get the first n items."
        first: Int!,
        "Search query nodes must match"
        query: String!,
        "Skips n items."
        skip: Int
    ): [Label!]!
    "Search for nodes of type ProjectPermission"
    searchProjectPermissions(
        "Filter for specific items"
        filter: ProjectPermissionFilterInput,
        "Get the first n items."
        first: Int!,
        "Search query nodes must match"
        query: String!,
        "Skips n items."
        skip: Int
    ): [ProjectPermission!]!
    "Search for nodes of type Project"
    searchProjects(
        "Filter for specific items"
        filter: ProjectFilterInput,
        "Get the first n items."
        first: Int!,
        "Search query nodes must match"
        query: String!,
        "Skips n items."
        skip: Int
    ): [Project!]!
    "Search for nodes of type RelationTemplate"
    searchRelationTemplates(
        "Filter for specific items"
        filter: RelationTemplateFilterInput,
        "Get the first n items."
        first: Int!,
        "Search query nodes must match"
        query: String!,
        "Skips n items."
        skip: Int
    ): [RelationTemplate!]!
    "Search for nodes of type Trackable"
    searchTrackables(
        "Filter for specific items"
        filter: TrackableFilterInput,
        "Get the first n items."
        first: Int!,
        "Search query nodes must match"
        query: String!,
        "Skips n items."
        skip: Int
    ): [Trackable!]!
    "Search for nodes of type User"
    searchUsers(
        "Filter for specific items"
        filter: UserFilterInput,
        "Get the first n items."
        first: Int!,
        "Search query nodes must match"
        query: String!,
        "Skips n items."
        skip: Int
    ): [User!]!
}

"""
Event representing that the Issue was used in an IssueRelation as related issue.
The IssueRelation may not be active any more.
READ is granted if READ is granted on `relation`.

"""
type RelatedByIssueEvent implements AuditedNode & BaseNode & Node & TimelineItem {
    "The DateTime this entity was created at."
    createdAt: DateTime!
    "The User who created this entity."
    createdBy: User!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "The Issue this TimelineItem is part of."
    issue: Issue
    "The DateTime this entity was last modified at."
    lastModifiedAt: DateTime!
    "The User who last modified this entity."
    lastModifiedBy: User!
    "If existing, the parent TimelineItem"
    parentItem: ParentTimelineItem
    "The IssueRelation the Issue is related at, null if deleted."
    relation: IssueRelation
}

"""
A relation between RelationPartners (ComponentVersions and Interfaces).
Relations are always directional.
Relations can derive Interfaces from `end` to `start` if both `start` and `end` are ComponentVersions
and the template of this Relation allows it.
The template defines which RelationPartners are possible as `start` / `end`.
For both start and end, if it is an Interface, it is possible to define the InterfaceParts this includes.
Caution: This is **not** a supertype of IssueRelation.
READ is granted if READ is granted on `start`.

"""
type Relation implements BaseNode & MutableTemplatedNode & Node & TemplatedNode {
    "InterfaceDefinition this Relation derives invisible"
    derivesInvisible(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: InterfaceDefinitionFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: InterfaceDefinitionOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): InterfaceDefinitionConnection!
    "InterfaceDefinition this Relation derives visible"
    derivesVisible(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: InterfaceDefinitionFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: InterfaceDefinitionOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): InterfaceDefinitionConnection!
    "The end of this Relation."
    end: RelationPartner
    "If the end is an Interface, the parts of that Interface this Relation includes."
    endParts(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: InterfacePartFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: InterfacePartOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): InterfacePartConnection!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "The start of this Relation."
    start: RelationPartner
    "If the start is an Interface, the parts of that Interface this Relation includes."
    startParts(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: InterfacePartFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: InterfacePartOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): InterfacePartConnection!
    "The Template of this Relation."
    template: RelationTemplate!
    "Value of a field defined by the template. Error if such a field is not defined."
    templatedField(
        "Name of the extension field"
        name: String!
    ): JSON
    """
    All templatedFields
    If `names` is provided, only those matching the name. If `prefixMatching` is true, matching is done by
    prefix, otherwise by full name.

    """
    templatedFields(
        "Names of the templated fields. If not provided, all templatedFields."
        names: [String!],
        """
        If true, name matching is performed as prefix matching, otherwise as absolute match.
        Defaults to absolute matching

        """
        prefixMatching: Boolean
    ): [JSONField!]!
}

"""
Condition which defines if a Relation can use a RelationTemplate.
A relation can only use the Template, if the start of the Relation has a template in from,
and the end of the Relation has a template in to.
Also defines which InterfaceSpecifications are derived via the Relation.
Part of a RelationTemplate.
READ is always granted.

"""
type RelationCondition implements BaseNode & Node {
    "Templates of allowed start RelationPartners"
    from(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: RelationPartnerTemplateFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: RelationPartnerTemplateOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): RelationPartnerTemplateConnection!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "Defines which InterfaceSpecifications are derived via the Relation."
    interfaceSpecificationDerivationConditions(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: InterfaceSpecificationDerivationConditionFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: InterfaceSpecificationDerivationConditionOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): InterfaceSpecificationDerivationConditionConnection!
    "The RelationTemplates this is part of."
    partOf(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: RelationTemplateFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: RelationTemplateOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): RelationTemplateConnection!
    "Templates of allowed end RelationPartners"
    to(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: RelationPartnerTemplateFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: RelationPartnerTemplateOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): RelationPartnerTemplateConnection!
}

"The connection type for RelationCondition."
type RelationConditionConnection {
    "A list of all edges of the current page."
    edges: [RelationConditionEdge!]!
    "A list of all nodes of the current page."
    nodes: [RelationCondition!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "Identifies the total count of items in the connection."
    totalCount: Int!
}

"An edge in a connection."
type RelationConditionEdge {
    "A cursor used in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: RelationCondition!
}

"The connection type for Relation."
type RelationConnection {
    "A list of all edges of the current page."
    edges: [RelationEdge!]!
    "A list of all nodes of the current page."
    nodes: [Relation!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "Identifies the total count of items in the connection."
    totalCount: Int!
}

"An edge in a connection."
type RelationEdge {
    "A cursor used in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Relation!
}

"The connection type for RelationPartnerTemplate."
type RelationPartnerTemplateConnection {
    "A list of all edges of the current page."
    edges: [RelationPartnerTemplateEdge!]!
    "A list of all nodes of the current page."
    nodes: [RelationPartnerTemplate!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "Identifies the total count of items in the connection."
    totalCount: Int!
}

"An edge in a connection."
type RelationPartnerTemplateEdge {
    "A cursor used in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: RelationPartnerTemplate!
}

"""
Template for Relations.
Defines templated fields with specific types (defined using JSON schema).
Defines which Relations can use this Template.
At least one RelationCondition has to match.

"""
type RelationTemplate implements BaseNode & BaseTemplate & Named & NamedNode & Node & Template {
    "The description of this entity."
    description: String!
    "Templates that extend this template."
    extendedBy(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: RelationTemplateFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: RelationTemplateOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): RelationTemplateConnection!
    "Template this template extends."
    extends(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: RelationTemplateFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: RelationTemplateOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): RelationTemplateConnection!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "If true, this template is deprecated and cannot be used for new entities any more."
    isDeprecated: Boolean!
    "The type of the marker at the end of the relation."
    markerType: MarkerType!
    "The name of this entity."
    name: String!
    "Defines which Relations can use this template, at least one RelationCondition has to match"
    relationConditions(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: RelationConditionFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: RelationConditionOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): RelationConditionConnection!
    "Style of the stroke"
    stroke: StrokeStyle
    "All template field specifications, if a `namePrefix` is provided, only those matching it"
    templateFieldSpecifications(
        "Name of the extension field."
        namePrefix: String
    ): [JSONField!]!
    "Entities which use this template."
    usedIn(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: RelationFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: RelationOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): RelationConnection!
}

"The connection type for RelationTemplate."
type RelationTemplateConnection {
    "A list of all edges of the current page."
    edges: [RelationTemplateEdge!]!
    "A list of all nodes of the current page."
    nodes: [RelationTemplate!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "Identifies the total count of items in the connection."
    totalCount: Int!
}

"An edge in a connection."
type RelationTemplateEdge {
    "A cursor used in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: RelationTemplate!
}

type RemoveAffectedEntityFromIssuePayload {
    "The created event, if present"
    removedAffectedEntityEvent: RemovedAffectedEntityEvent
}

type RemoveArtefactFromIssuePayload {
    "The created event, if present"
    removedArtefactEvent: RemovedArtefactEvent
}

type RemoveAssignmentPayload {
    "The created event, if present"
    removedAssignmentEvent: RemovedAssignmentEvent
}

type RemoveComponentVersionFromProjectPayload {
    "The updated Project"
    project: Project!
}

type RemoveInterfaceSpecificationVersionFromComponentVersionPayload {
    "The updated ComponentVersion"
    componentVersion: ComponentVersion!
}

type RemoveIssueFromPinnedIssuesPayload {
    "The created event, if present"
    removedFromPinnedIssuesEvent: RemovedFromPinnedIssuesEvent
}

type RemoveIssueFromTrackablePayload {
    "The created event, if present"
    removedFromTrackableEvent: RemovedFromTrackableEvent
}

type RemoveIssueRelationPayload {
    "The created event, if present"
    removedOutgoingRelationEvent: RemovedOutgoingRelationEvent
}

type RemoveLabelFromIssuePayload {
    "The created event, if present"
    removedLabelEvent: RemovedLabelEvent
}

type RemoveLabelFromTrackablePayload {
    "The Trackable from which the Label was removed"
    trackable: Trackable!
}

"""
Event representing that an entity is no longer affected by an Issue.
READ is granted if READ is granted on `issue`.

"""
type RemovedAffectedEntityEvent implements AuditedNode & BaseNode & Node & TimelineItem {
    "The DateTime this entity was created at."
    createdAt: DateTime!
    "The User who created this entity."
    createdBy: User!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "The Issue this TimelineItem is part of."
    issue: Issue
    "The DateTime this entity was last modified at."
    lastModifiedAt: DateTime!
    "The User who last modified this entity."
    lastModifiedBy: User!
    "If existing, the parent TimelineItem"
    parentItem: ParentTimelineItem
    "The entity which is no longer affected by the Issue, null if deleted."
    removedAffectedEntity: AffectedByIssue
}

"""
Event representing that an Artefact was removed from an Issue.
READ is granted if READ is granted on `issue`.

"""
type RemovedArtefactEvent implements AuditedNode & BaseNode & Node & TimelineItem {
    "The DateTime this entity was created at."
    createdAt: DateTime!
    "The User who created this entity."
    createdBy: User!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "The Issue this TimelineItem is part of."
    issue: Issue
    "The DateTime this entity was last modified at."
    lastModifiedAt: DateTime!
    "The User who last modified this entity."
    lastModifiedBy: User!
    "If existing, the parent TimelineItem"
    parentItem: ParentTimelineItem
    "The Artefact which was removed from the Issue, null if deleted."
    removedArtefact: Artefact
}

"""
Event representing that a User was unassigned from an Issue,
meaning an Assignment was removed from an Issue.
READ is granted if READ is granted on `issue`.

"""
type RemovedAssignmentEvent implements AuditedNode & BaseNode & Node & TimelineItem {
    "The DateTime this entity was created at."
    createdAt: DateTime!
    "The User who created this entity."
    createdBy: User!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "The Issue this TimelineItem is part of."
    issue: Issue
    "The DateTime this entity was last modified at."
    lastModifiedAt: DateTime!
    "The User who last modified this entity."
    lastModifiedBy: User!
    "If existing, the parent TimelineItem"
    parentItem: ParentTimelineItem
    "The removed Assignment."
    removedAssignment: Assignment!
}

"""
Event representing that an Issue was unpinned on a Trackable.
READ is granted if READ is granted on `issue`.

"""
type RemovedFromPinnedIssuesEvent implements AuditedNode & BaseNode & Node & TimelineItem {
    "The DateTime this entity was created at."
    createdAt: DateTime!
    "The User who created this entity."
    createdBy: User!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "The Issue this TimelineItem is part of."
    issue: Issue
    "The DateTime this entity was last modified at."
    lastModifiedAt: DateTime!
    "The User who last modified this entity."
    lastModifiedBy: User!
    "If existing, the parent TimelineItem"
    parentItem: ParentTimelineItem
    "The Trackable the Issue is no longer pinned on, null if deleted."
    unpinnedOn: Trackable
}

"""
Event representing that an Issue was removed from a Trackable.
READ is granted if READ is granted on `issue`.

"""
type RemovedFromTrackableEvent implements AuditedNode & BaseNode & Node & ParentTimelineItem & TimelineItem {
    "Child TimelineItems. These are still part of the main timeline."
    childItems(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: TimelineItemFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: TimelineItemOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): TimelineItemConnection!
    "The DateTime this entity was created at."
    createdAt: DateTime!
    "The User who created this entity."
    createdBy: User!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "The Issue this TimelineItem is part of."
    issue: Issue
    "The DateTime this entity was last modified at."
    lastModifiedAt: DateTime!
    "The User who last modified this entity."
    lastModifiedBy: User!
    "If existing, the parent TimelineItem"
    parentItem: ParentTimelineItem
    "The Trackable the Issue was removed from, null if deleted."
    removedFromTrackable: Trackable
}

"""
Event representing that an incoming IssueRelation was removed.
READ is granted if READ is granted on `removedRelation`.

"""
type RemovedIncomingRelationEvent implements AuditedNode & BaseNode & Node & RemovedRelationEvent & TimelineItem {
    "The DateTime this entity was created at."
    createdAt: DateTime!
    "The User who created this entity."
    createdBy: User!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "The Issue this TimelineItem is part of."
    issue: Issue
    "The DateTime this entity was last modified at."
    lastModifiedAt: DateTime!
    "The User who last modified this entity."
    lastModifiedBy: User!
    "If existing, the parent TimelineItem"
    parentItem: ParentTimelineItem
    "The removed IssueRelation, null if deleted."
    removedRelation: IssueRelation
}

"""
Event representing that a Label was removed from an Issue.
READ is granted if READ is granted on `issue`.

"""
type RemovedLabelEvent implements AuditedNode & BaseNode & Node & TimelineItem {
    "The DateTime this entity was created at."
    createdAt: DateTime!
    "The User who created this entity."
    createdBy: User!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "The Issue this TimelineItem is part of."
    issue: Issue
    "The DateTime this entity was last modified at."
    lastModifiedAt: DateTime!
    "The User who last modified this entity."
    lastModifiedBy: User!
    "If existing, the parent TimelineItem"
    parentItem: ParentTimelineItem
    "The Label removed from the Issue, null if deleted."
    removedLabel: Label
}

"""
Event representing that an outgoing IssueRelation was removed.
READ is granted if READ is granted on `issue`.

"""
type RemovedOutgoingRelationEvent implements AuditedNode & BaseNode & Node & RemovedRelationEvent & TimelineItem {
    "The DateTime this entity was created at."
    createdAt: DateTime!
    "The User who created this entity."
    createdBy: User!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "The Issue this TimelineItem is part of."
    issue: Issue
    "The DateTime this entity was last modified at."
    lastModifiedAt: DateTime!
    "The User who last modified this entity."
    lastModifiedBy: User!
    "If existing, the parent TimelineItem"
    parentItem: ParentTimelineItem
    "The removed IssueRelation, null if deleted."
    removedRelation: IssueRelation
}

"""
Event representing that a templated field was removed.
READ is granted if READ is granted on `issue`.

"""
type RemovedTemplatedFieldEvent implements AuditedNode & BaseNode & Node & TimelineItem {
    "The DateTime this entity was created at."
    createdAt: DateTime!
    "The User who created this entity."
    createdBy: User!
    "The name of the templated field."
    fieldName: String!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "The Issue this TimelineItem is part of."
    issue: Issue
    "The DateTime this entity was last modified at."
    lastModifiedAt: DateTime!
    "The User who last modified this entity."
    lastModifiedBy: User!
    "The removed old value of the templated field."
    oldValue: JSON
    "If existing, the parent TimelineItem"
    parentItem: ParentTimelineItem
}

"""
Event representing that the spent time of an Issue changed.
READ is granted if READ is granted on `issue`.

"""
type SpentTimeChangedEvent implements AuditedNode & BaseNode & Node & TimelineItem {
    "The DateTime this entity was created at."
    createdAt: DateTime!
    "The User who created this entity."
    createdBy: User!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "The Issue this TimelineItem is part of."
    issue: Issue
    "The DateTime this entity was last modified at."
    lastModifiedAt: DateTime!
    "The User who last modified this entity."
    lastModifiedBy: User!
    "The mew spent time."
    newSpentTime: Duration
    "The old spent time."
    oldSpentTime: Duration
    "If existing, the parent TimelineItem"
    parentItem: ParentTimelineItem
}

"""
Event representing that the start date of an Issue changed.
READ is granted if READ is granted on `issue`.

"""
type StartDateChangedEvent implements AuditedNode & BaseNode & Node & TimelineItem {
    "The DateTime this entity was created at."
    createdAt: DateTime!
    "The User who created this entity."
    createdBy: User!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "The Issue this TimelineItem is part of."
    issue: Issue
    "The DateTime this entity was last modified at."
    lastModifiedAt: DateTime!
    "The User who last modified this entity."
    lastModifiedBy: User!
    "The new start date."
    newStartDate: DateTime
    "The old start date."
    oldStartDate: DateTime
    "If existing, the parent TimelineItem"
    parentItem: ParentTimelineItem
}

"""
Event representing that the state of an Issue changed.
READ is granted if READ is granted on `issue`.

"""
type StateChangedEvent implements AuditedNode & BaseNode & Node & TimelineItem {
    "The DateTime this entity was created at."
    createdAt: DateTime!
    "The User who created this entity."
    createdBy: User!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "The Issue this TimelineItem is part of."
    issue: Issue
    "The DateTime this entity was last modified at."
    lastModifiedAt: DateTime!
    "The User who last modified this entity."
    lastModifiedBy: User!
    "The new state."
    newState: IssueState!
    "The old state."
    oldState: IssueState!
    "If existing, the parent TimelineItem"
    parentItem: ParentTimelineItem
}

"Style of the stroke"
type StrokeStyle implements BaseNode & Node {
    "The color of the stroke"
    color: String
    "The dash pattern of the stroke"
    dash: [Float!]
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
}

"The connection type for SyncPermissionTarget."
type SyncPermissionTargetConnection {
    "A list of all edges of the current page."
    edges: [SyncPermissionTargetEdge!]!
    "A list of all nodes of the current page."
    nodes: [SyncPermissionTarget!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "Identifies the total count of items in the connection."
    totalCount: Int!
}

"An edge in a connection."
type SyncPermissionTargetEdge {
    "A cursor used in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: SyncPermissionTarget!
}

"""
Event representing the template of an Issue changed.
READ is granted if READ is granted on `issue`.

"""
type TemplateChangedEvent implements AuditedNode & BaseNode & Node & ParentTimelineItem & TimelineItem {
    "Child TimelineItems. These are still part of the main timeline."
    childItems(
        "Get only items after the cursor"
        after: String,
        "Get only items before the cursor"
        before: String,
        "Filter for specific items in the connection"
        filter: TimelineItemFilterInput,
        "Get the first n items. Must not be used if before is specified"
        first: Int,
        "Get the last n items. Must not be used if after is specified"
        last: Int,
        "Order in which the items are sorted"
        orderBy: TimelineItemOrder,
        "Skips n items. First or last MUST be specified, is otherwise ignored"
        skip: Int
    ): TimelineItemConnection!
    "The DateTime this entity was created at."
    createdAt: DateTime!
    "The User who created this entity."
    createdBy: User!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "The Issue this TimelineItem is part of."
    issue: Issue
    "The DateTime this entity was last modified at."
    lastModifiedAt: DateTime!
    "The User who last modified this entity."
    lastModifiedBy: User!
    "The new template."
    newTemplate: IssueTemplate!
    "The old template."
    oldTemplate: IssueTemplate!
    "If existing, the parent TimelineItem"
    parentItem: ParentTimelineItem
}

"""
Event representing that the value of a templated field changed.
READ is granted if READ is granted on `issue`.

"""
type TemplatedFieldChangedEvent implements AuditedNode & BaseNode & Node & TimelineItem {
    "The DateTime this entity was created at."
    createdAt: DateTime!
    "The User who created this entity."
    createdBy: User!
    "The name of the templated field."
    fieldName: String!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "The Issue this TimelineItem is part of."
    issue: Issue
    "The DateTime this entity was last modified at."
    lastModifiedAt: DateTime!
    "The User who last modified this entity."
    lastModifiedBy: User!
    "The new value of the templated field."
    newValue: JSON
    "The old value of the templated field."
    oldValue: JSON
    "If existing, the parent TimelineItem"
    parentItem: ParentTimelineItem
}

"The connection type for TimelineItem."
type TimelineItemConnection {
    "A list of all edges of the current page."
    edges: [TimelineItemEdge!]!
    "A list of all nodes of the current page."
    nodes: [TimelineItem!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "Identifies the total count of items in the connection."
    totalCount: Int!
}

"An edge in a connection."
type TimelineItemEdge {
    "A cursor used in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: TimelineItem!
}

"""
Event representing that the title of an Issue changed.
READ is granted if READ is granted on `issue`.

"""
type TitleChangedEvent implements AuditedNode & BaseNode & Node & TimelineItem {
    "The DateTime this entity was created at."
    createdAt: DateTime!
    "The User who created this entity."
    createdBy: User!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "The Issue this TimelineItem is part of."
    issue: Issue
    "The DateTime this entity was last modified at."
    lastModifiedAt: DateTime!
    "The User who last modified this entity."
    lastModifiedBy: User!
    "The new title."
    newTitle: String!
    "The old title."
    oldTitle: String!
    "If existing, the parent TimelineItem"
    parentItem: ParentTimelineItem
}

"The connection type for Trackable."
type TrackableConnection {
    "A list of all edges of the current page."
    edges: [TrackableEdge!]!
    "A list of all nodes of the current page."
    nodes: [Trackable!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "Identifies the total count of items in the connection."
    totalCount: Int!
}

"An edge in a connection."
type TrackableEdge {
    "A cursor used in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Trackable!
}

"""
Event representing that the type of an Issue changed.
READ is granted if READ is granted on `issue`.

"""
type TypeChangedEvent implements AuditedNode & BaseNode & Node & TimelineItem {
    "The DateTime this entity was created at."
    createdAt: DateTime!
    "The User who created this entity."
    createdBy: User!
    "Checks if the current user has a specific permission on this Node"
    hasPermission(
        "The permission to check for"
        permission: AllPermissionEntry
    ): Boolean!
    "The unique id of this node"
    id: ID!
    "The Issue this TimelineItem is part of."
    issue: Issue
    "The DateTime this entity was last modified at."
    lastModifiedAt: DateTime!
    "The User who last modified this entity."
    lastModifiedBy: User!
    "The new type."
    newType: IssueType!
    "The old type."
    oldType: IssueType!
    "If existing, the parent TimelineItem"
    parentItem: ParentTimelineItem
}

type UpdateArtefactPayload {
    "The updated Artefact"
    artefact: Artefact!
}

type UpdateBodyPayload {
    "The updated Body"
    body: Body!
}

type UpdateComponentPayload {
    "The updated Component"
    component: Component!
}

type UpdateComponentPermissionPayload {
    "The updated ComponentPermission"
    componentPermission: ComponentPermission!
}

type UpdateComponentVersionPayload {
    "The updated ComponentVersion"
    componentVersion: ComponentVersion!
}

type UpdateGlobalPermissionPayload {
    "The updated GlobalPermission"
    globalPermission: GlobalPermission!
}

type UpdateGropiusUserPayload {
    "The updated GropiusUser"
    gropiusUser: GropiusUser!
}

type UpdateIMSPayload {
    "The updated IMS"
    ims: IMS!
}

type UpdateIMSPermissionPayload {
    "The updated IMSPermission"
    imsPermission: IMSPermission!
}

type UpdateIMSProjectPayload {
    "The updated IMSProject"
    imsProject: IMSProject!
}

type UpdateInterfaceDefinitionPayload {
    "The updated InterfaceDefinition "
    interfaceDefinition: InterfaceDefinition!
}

type UpdateInterfacePartPayload {
    "The updated InterfacePart"
    interfacePart: InterfacePart!
}

type UpdateInterfacePayload {
    "The updated Interface "
    interface: Interface!
}

type UpdateInterfaceSpecificationPayload {
    "The updated InterfaceSpecification"
    interfaceSpecification: InterfaceSpecification!
}

type UpdateInterfaceSpecificationVersionPayload {
    "The updated InterfaceSpecificationVersion"
    interfaceSpecificationVersion: InterfaceSpecificationVersion!
}

type UpdateIntraComponentDependencySpecificationPayload {
    "The updated IntraComponentDependencySpecification"
    intraComponentDependencySpecification: IntraComponentDependencySpecification!
}

type UpdateIssueCommentPayload {
    "The updated IssueComment"
    issueComment: IssueComment!
}

type UpdateLabelPayload {
    "The updated Label"
    label: Label!
}

type UpdateProjectPayload {
    "The updated Project"
    project: Project!
}

type UpdateProjectPermissionPayload {
    "The updated ProjectPermission"
    projectPermission: ProjectPermission!
}

type UpdateRelationPayload {
    "The updated Relation"
    relation: Relation!
}

type UpdateSyncPermissionsPayload {
    "The updated SyncPermissionTarget"
    syncPermissionTarget: SyncPermissionTarget!
}

type UpdateTemplateDeprecationStatusPayload {
    "The updated Template"
    template: Template!
}

"The connection type for User."
type UserConnection {
    "A list of all edges of the current page."
    edges: [UserEdge!]!
    "A list of all nodes of the current page."
    nodes: [User!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "Identifies the total count of items in the connection."
    totalCount: Int!
}

"An edge in a connection."
type UserEdge {
    "A cursor used in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: User!
}

"Fields a list of AffectedByIssue can be sorted by"
enum AffectedByIssueOrderField {
    "Order by id"
    ID
    "Order by name"
    NAME
}

"Fields a list of AggregatedIssue can be sorted by"
enum AggregatedIssueOrderField {
    "Order by count"
    COUNT
    "Order by id"
    ID
}

"Fields a list of AggregatedIssueRelation can be sorted by"
enum AggregatedIssueRelationOrderField {
    "Order by id"
    ID
}

"Non global permission entries"
enum AllPermissionEntry {
    """
    Allows to add the Component to Projects
    Note: this should be handled very carefully, as adding a Component to a Project gives
    all users with READ access to the Project READ access to the Component
    """
    ADD_TO_PROJECTS
    "Grants all other permissions on the Node except READ."
    ADMIN
    """
    Allows affecting entities part of this Trackable with any Issues.
    Affectable entitites include
    - the Trackable itself
    - in case the Trackable is a Component
    - InterfaceSpecifications, their InterfaceSpecificationVersions and their InterfaceParts of the Component (not inherited ones)
    - Interfaces on the Component
    - ComponentVersions of the Component
    """
    AFFECT_ENTITIES_WITH_ISSUES
    """
    Allows to create Comments on Issues on this Trackable.
    Also allows editing of your own Comments.
    """
    COMMENT
    """
    Allows to create new Issues on the Trackable.
    This includes adding Issues from other Trackables.
    """
    CREATE_ISSUES
    "Allows adding Issues on this Trackable to other Trackables."
    EXPORT_ISSUES
    "Allows adding Labels on this Trackable to other Trackables."
    EXPORT_LABELS
    "Allows to add, remove, and update Artefacts on this Trackable."
    MANAGE_ARTEFACTS
    "Allows to add / remove ComponentVersions to / from this Project."
    MANAGE_COMPONENTS
    """
    Allows to add, remove, and update IMSProjects on this Trackable.
    Note: for adding, `IMSPermissionEntry.SYNC_TRACKABLES` is required additionally
    """
    MANAGE_IMS
    """
    Allows to manage issues.
    This includes `CREATE_ISSUES` and `COMMENT`.
    This does NOT include `LINK_TO_ISSUES` and `LINK_FROM_ISSUES`.
    Additionaly includes
    - change the Template
    - add / remove Labels
    - add / remove Artefacts
    - change any field on the Issue (title, startDate, dueDate, ...)
    - change templated fields
    In contrast to `MODERATOR`, this does not allow editing / removing Comments of other users
    """
    MANAGE_ISSUES
    """
    Allows to add, remove, and update Labels on this Trackable.
    Also allows to delete a Label, but only if it is allowed on all Trackable the Label is on.
    """
    MANAGE_LABELS
    """
    Allows to moderate Issues on this Trackable.
    This allows everything `MANAGE_ISSUES` allows.
    Additionally, it allows editing and deleting Comments of other Users
    """
    MODERATOR
    """
    Allows to read the Node (obtain it via the API) and to read certain related Nodes.
    See documentation for specific Node for the specific conditions.
    """
    READ
    """
    Allows to create Relations with a version of this Component or an Interface of this Component
    as start.
    Note: as these Relations cannot cause new Interfaces on this Component, this can be granted
    more permissively compared to `RELATE_TO_COMPONENT`.
    """
    RELATE_FROM_COMPONENT
    "Allows to create IMSProjects with this IMS."
    SYNC_TRACKABLES
}

"Fields a list of Artefact can be sorted by"
enum ArtefactOrderField {
    "Order by createdAt"
    CREATED_AT
    "Order by file"
    FILE
    "Order by from"
    FROM
    "Order by id"
    ID
    "Order by lastModifiedAt"
    LAST_MODIFIED_AT
    "Order by to"
    TO
    "Order by version"
    VERSION
}

"Fields a list of ArtefactTemplate can be sorted by"
enum ArtefactTemplateOrderField {
    "Order by id"
    ID
    "Order by name"
    NAME
}

"Fields a list of Assignment can be sorted by"
enum AssignmentOrderField {
    "Order by createdAt"
    CREATED_AT
    "Order by id"
    ID
    "Order by lastModifiedAt"
    LAST_MODIFIED_AT
}

"Fields a list of AssignmentType can be sorted by"
enum AssignmentTypeOrderField {
    "Order by id"
    ID
    "Order by name"
    NAME
}

"Fields a list of AuditedNode can be sorted by"
enum AuditedNodeOrderField {
    "Order by createdAt"
    CREATED_AT
    "Order by id"
    ID
    "Order by lastModifiedAt"
    LAST_MODIFIED_AT
}

"Fields a list of BasePermission can be sorted by"
enum BasePermissionOrderField {
    "Order by allUsers"
    ALL_USERS
    "Order by id"
    ID
    "Order by name"
    NAME
}

"Fields a list of Component can be sorted by"
enum ComponentOrderField {
    "Order by id"
    ID
    "Order by name"
    NAME
}

"ComponentPermission entry enum type."
enum ComponentPermissionEntry {
    """
    Allows to add the Component to Projects
    Note: this should be handled very carefully, as adding a Component to a Project gives
    all users with READ access to the Project READ access to the Component
    """
    ADD_TO_PROJECTS
    "Grants all other permissions on the Node except READ."
    ADMIN
    """
    Allows affecting entities part of this Trackable with any Issues.
    Affectable entitites include
    - the Trackable itself
    - in case the Trackable is a Component
    - InterfaceSpecifications, their InterfaceSpecificationVersions and their InterfaceParts of the Component (not inherited ones)
    - Interfaces on the Component
    - ComponentVersions of the Component
    """
    AFFECT_ENTITIES_WITH_ISSUES
    """
    Allows to create Comments on Issues on this Trackable.
    Also allows editing of your own Comments.
    """
    COMMENT
    """
    Allows to create new Issues on the Trackable.
    This includes adding Issues from other Trackables.
    """
    CREATE_ISSUES
    "Allows adding Issues on this Trackable to other Trackables."
    EXPORT_ISSUES
    "Allows adding Labels on this Trackable to other Trackables."
    EXPORT_LABELS
    "Allows to add, remove, and update Artefacts on this Trackable."
    MANAGE_ARTEFACTS
    """
    Allows to add, remove, and update IMSProjects on this Trackable.
    Note: for adding, `IMSPermissionEntry.SYNC_TRACKABLES` is required additionally
    """
    MANAGE_IMS
    """
    Allows to manage issues.
    This includes `CREATE_ISSUES` and `COMMENT`.
    This does NOT include `LINK_TO_ISSUES` and `LINK_FROM_ISSUES`.
    Additionaly includes
    - change the Template
    - add / remove Labels
    - add / remove Artefacts
    - change any field on the Issue (title, startDate, dueDate, ...)
    - change templated fields
    In contrast to `MODERATOR`, this does not allow editing / removing Comments of other users
    """
    MANAGE_ISSUES
    """
    Allows to add, remove, and update Labels on this Trackable.
    Also allows to delete a Label, but only if it is allowed on all Trackable the Label is on.
    """
    MANAGE_LABELS
    """
    Allows to moderate Issues on this Trackable.
    This allows everything `MANAGE_ISSUES` allows.
    Additionally, it allows editing and deleting Comments of other Users
    """
    MODERATOR
    """
    Allows to read the Node (obtain it via the API) and to read certain related Nodes.
    See documentation for specific Node for the specific conditions.
    """
    READ
    """
    Allows to create Relations with a version of this Component or an Interface of this Component
    as start.
    Note: as these Relations cannot cause new Interfaces on this Component, this can be granted
    more permissively compared to `RELATE_TO_COMPONENT`.
    """
    RELATE_FROM_COMPONENT
}

"Fields a list of ComponentPermission can be sorted by"
enum ComponentPermissionOrderField {
    "Order by allUsers"
    ALL_USERS
    "Order by id"
    ID
    "Order by name"
    NAME
}

"Fields a list of ComponentTemplate can be sorted by"
enum ComponentTemplateOrderField {
    "Order by id"
    ID
    "Order by name"
    NAME
}

"Fields a list of ComponentVersion can be sorted by"
enum ComponentVersionOrderField {
    "Order by id"
    ID
    "Order by name"
    NAME
    "Order by version"
    VERSION
}

"Fields a list of GropiusUser can be sorted by"
enum GropiusUserOrderField {
    "Order by displayName"
    DISPLAY_NAME
    "Order by email"
    EMAIL
    "Order by id"
    ID
    "Order by username"
    USERNAME
}

"Fields a list of IMSIssue can be sorted by"
enum IMSIssueOrderField {
    "Order by id"
    ID
}

"Fields a list of IMS can be sorted by"
enum IMSOrderField {
    "Order by id"
    ID
    "Order by name"
    NAME
}

"IMSPermission entry enum type."
enum IMSPermissionEntry {
    "Grants all other permissions on the Node except READ."
    ADMIN
    """
    Allows to read the Node (obtain it via the API) and to read certain related Nodes.
    See documentation for specific Node for the specific conditions.
    """
    READ
    "Allows to create IMSProjects with this IMS."
    SYNC_TRACKABLES
}

"Fields a list of IMSPermission can be sorted by"
enum IMSPermissionOrderField {
    "Order by allUsers"
    ALL_USERS
    "Order by id"
    ID
    "Order by name"
    NAME
}

"Fields a list of IMSProject can be sorted by"
enum IMSProjectOrderField {
    "Order by id"
    ID
    "Order by name"
    NAME
}

"Fields a list of IMSTemplate can be sorted by"
enum IMSTemplateOrderField {
    "Order by id"
    ID
    "Order by name"
    NAME
}

"Fields a list of IMSUser can be sorted by"
enum IMSUserOrderField {
    "Order by displayName"
    DISPLAY_NAME
    "Order by email"
    EMAIL
    "Order by id"
    ID
    "Order by username"
    USERNAME
}

"Fields a list of InterfaceDefinition can be sorted by"
enum InterfaceDefinitionOrderField {
    "Order by id"
    ID
    "Order by invisibleSelfDefined"
    INVISIBLE_SELF_DEFINED
    "Order by visibleSelfDefined"
    VISIBLE_SELF_DEFINED
}

"Fields a list of Interface can be sorted by"
enum InterfaceOrderField {
    "Order by id"
    ID
    "Order by name"
    NAME
}

"Fields a list of InterfacePart can be sorted by"
enum InterfacePartOrderField {
    "Order by id"
    ID
    "Order by name"
    NAME
}

"Fields a list of InterfaceSpecificationDerivationCondition can be sorted by"
enum InterfaceSpecificationDerivationConditionOrderField {
    "Order by id"
    ID
}

"Fields a list of InterfaceSpecification can be sorted by"
enum InterfaceSpecificationOrderField {
    "Order by id"
    ID
    "Order by name"
    NAME
}

"Fields a list of InterfaceSpecificationTemplate can be sorted by"
enum InterfaceSpecificationTemplateOrderField {
    "Order by id"
    ID
    "Order by name"
    NAME
}

"Fields a list of InterfaceSpecificationVersion can be sorted by"
enum InterfaceSpecificationVersionOrderField {
    "Order by id"
    ID
    "Order by name"
    NAME
    "Order by version"
    VERSION
}

"Fields a list of IntraComponentDependencyParticipant can be sorted by"
enum IntraComponentDependencyParticipantOrderField {
    "Order by id"
    ID
}

"Fields a list of IntraComponentDependencySpecification can be sorted by"
enum IntraComponentDependencySpecificationOrderField {
    "Order by id"
    ID
    "Order by name"
    NAME
}

"Fields a list of IssueComment can be sorted by"
enum IssueCommentOrderField {
    "Order by bodyLastEditedAt"
    BODY_LAST_EDITED_AT
    "Order by createdAt"
    CREATED_AT
    "Order by id"
    ID
    "Order by lastModifiedAt"
    LAST_MODIFIED_AT
}

"Fields a list of Issue can be sorted by"
enum IssueOrderField {
    "Order by createdAt"
    CREATED_AT
    "Order by dueDate"
    DUE_DATE
    "Order by estimatedTime"
    ESTIMATED_TIME
    "Order by id"
    ID
    "Order by lastModifiedAt"
    LAST_MODIFIED_AT
    "Order by lastUpdatedAt"
    LAST_UPDATED_AT
    "Order by spentTime"
    SPENT_TIME
    "Order by startDate"
    START_DATE
    "Order by title"
    TITLE
}

"Fields a list of IssuePriority can be sorted by"
enum IssuePriorityOrderField {
    "Order by id"
    ID
    "Order by name"
    NAME
    "Order by value"
    VALUE
}

"Fields a list of IssueRelation can be sorted by"
enum IssueRelationOrderField {
    "Order by createdAt"
    CREATED_AT
    "Order by id"
    ID
    "Order by lastModifiedAt"
    LAST_MODIFIED_AT
}

"Fields a list of IssueRelationType can be sorted by"
enum IssueRelationTypeOrderField {
    "Order by id"
    ID
    "Order by inverseName"
    INVERSE_NAME
    "Order by name"
    NAME
}

"Fields a list of IssueState can be sorted by"
enum IssueStateOrderField {
    "Order by id"
    ID
    "Order by isOpen"
    IS_OPEN
    "Order by name"
    NAME
}

"Fields a list of IssueTemplate can be sorted by"
enum IssueTemplateOrderField {
    "Order by id"
    ID
    "Order by name"
    NAME
}

"Fields a list of IssueType can be sorted by"
enum IssueTypeOrderField {
    "Order by id"
    ID
    "Order by name"
    NAME
}

"Fields a list of Label can be sorted by"
enum LabelOrderField {
    "Order by color"
    COLOR
    "Order by createdAt"
    CREATED_AT
    "Order by id"
    ID
    "Order by lastModifiedAt"
    LAST_MODIFIED_AT
    "Order by name"
    NAME
}

"Type of a Relation marker"
enum MarkerType {
    "A regular arrow"
    ARROW
    "A circle"
    CIRCLE
    "A diamond"
    DIAMOND
    "A filled circle"
    FILLED_CIRCLE
    "A filled diamond"
    FILLED_DIAMOND
    "A filled triangle"
    FILLED_TRIANGLE
    "A triangle"
    TRIANGLE
}

"Possible direction in which a list of nodes can be ordered"
enum OrderDirection {
    "Ascending"
    ASC
    "Descending"
    DESC
}

"Permission entry enum type."
enum PermissionEntry {
    "Allows to create new Components."
    CAN_CREATE_COMPONENTS
    "Allows to create new IMSs."
    CAN_CREATE_IMSS
    "Allows to create new Projects."
    CAN_CREATE_PROJECTS
    "Allows to create new Templates."
    CAN_CREATE_TEMPLATES
}

"Fields a list of Project can be sorted by"
enum ProjectOrderField {
    "Order by id"
    ID
    "Order by name"
    NAME
}

"ProjectPermission entry enum type."
enum ProjectPermissionEntry {
    "Grants all other permissions on the Node except READ."
    ADMIN
    """
    Allows affecting entities part of this Trackable with any Issues.
    Affectable entitites include
    - the Trackable itself
    - in case the Trackable is a Component
    - InterfaceSpecifications, their InterfaceSpecificationVersions and their InterfaceParts of the Component (not inherited ones)
    - Interfaces on the Component
    - ComponentVersions of the Component
    """
    AFFECT_ENTITIES_WITH_ISSUES
    """
    Allows to create Comments on Issues on this Trackable.
    Also allows editing of your own Comments.
    """
    COMMENT
    """
    Allows to create new Issues on the Trackable.
    This includes adding Issues from other Trackables.
    """
    CREATE_ISSUES
    "Allows adding Issues on this Trackable to other Trackables."
    EXPORT_ISSUES
    "Allows adding Labels on this Trackable to other Trackables."
    EXPORT_LABELS
    "Allows to add, remove, and update Artefacts on this Trackable."
    MANAGE_ARTEFACTS
    "Allows to add / remove ComponentVersions to / from this Project."
    MANAGE_COMPONENTS
    """
    Allows to add, remove, and update IMSProjects on this Trackable.
    Note: for adding, `IMSPermissionEntry.SYNC_TRACKABLES` is required additionally
    """
    MANAGE_IMS
    """
    Allows to manage issues.
    This includes `CREATE_ISSUES` and `COMMENT`.
    This does NOT include `LINK_TO_ISSUES` and `LINK_FROM_ISSUES`.
    Additionaly includes
    - change the Template
    - add / remove Labels
    - add / remove Artefacts
    - change any field on the Issue (title, startDate, dueDate, ...)
    - change templated fields
    In contrast to `MODERATOR`, this does not allow editing / removing Comments of other users
    """
    MANAGE_ISSUES
    """
    Allows to add, remove, and update Labels on this Trackable.
    Also allows to delete a Label, but only if it is allowed on all Trackable the Label is on.
    """
    MANAGE_LABELS
    """
    Allows to moderate Issues on this Trackable.
    This allows everything `MANAGE_ISSUES` allows.
    Additionally, it allows editing and deleting Comments of other Users
    """
    MODERATOR
    """
    Allows to read the Node (obtain it via the API) and to read certain related Nodes.
    See documentation for specific Node for the specific conditions.
    """
    READ
}

"Fields a list of ProjectPermission can be sorted by"
enum ProjectPermissionOrderField {
    "Order by allUsers"
    ALL_USERS
    "Order by id"
    ID
    "Order by name"
    NAME
}

"Fields a list of RelationCondition can be sorted by"
enum RelationConditionOrderField {
    "Order by id"
    ID
}

"Fields a list of Relation can be sorted by"
enum RelationOrderField {
    "Order by id"
    ID
}

"Fields a list of RelationPartnerTemplate can be sorted by"
enum RelationPartnerTemplateOrderField {
    "Order by id"
    ID
    "Order by name"
    NAME
}

"Fields a list of RelationTemplate can be sorted by"
enum RelationTemplateOrderField {
    "Order by id"
    ID
    "Order by name"
    NAME
}

"Type of a Shape"
enum ShapeType {
    "A Circle"
    CIRCLE
    "An Ellipse"
    ELLIPSE
    "A Hexagon"
    HEXAGON
    "A Rectangle"
    RECT
    "A Rhombus"
    RHOMBUS
}

"Fields a list of SyncPermissionTarget can be sorted by"
enum SyncPermissionTargetOrderField {
    "Order by id"
    ID
    "Order by name"
    NAME
}

"Fields a list of TimelineItem can be sorted by"
enum TimelineItemOrderField {
    "Order by createdAt"
    CREATED_AT
    "Order by id"
    ID
    "Order by lastModifiedAt"
    LAST_MODIFIED_AT
}

"All timeline items types"
enum TimelineItemType {
    "AbstractTypeChangedEvent timeline item"
    ABSTRACT_TYPE_CHANGED_EVENT
    "AddedAffectedEntityEvent timeline item"
    ADDED_AFFECTED_ENTITY_EVENT
    "AddedArtefactEvent timeline item"
    ADDED_ARTEFACT_EVENT
    "AddedLabelEvent timeline item"
    ADDED_LABEL_EVENT
    "AddedToPinnedIssuesEvent timeline item"
    ADDED_TO_PINNED_ISSUES_EVENT
    "AddedToTrackableEvent timeline item"
    ADDED_TO_TRACKABLE_EVENT
    "Assignment timeline item"
    ASSIGNMENT
    "AssignmentTypeChangedEvent timeline item"
    ASSIGNMENT_TYPE_CHANGED_EVENT
    "Body timeline item"
    BODY
    "Comment timeline item"
    COMMENT
    "DueDateChangedEvent timeline item"
    DUE_DATE_CHANGED_EVENT
    "EstimatedTimeChangedEvent timeline item"
    ESTIMATED_TIME_CHANGED_EVENT
    "IncomingRelationTypeChangedEvent timeline item"
    INCOMING_RELATION_TYPE_CHANGED_EVENT
    "IssueComment timeline item"
    ISSUE_COMMENT
    "IssueRelation timeline item"
    ISSUE_RELATION
    "OutgoingRelationTypeChangedEvent timeline item"
    OUTGOING_RELATION_TYPE_CHANGED_EVENT
    "ParentTimelineItem timeline item"
    PARENT_TIMELINE_ITEM
    "PriorityChangedEvent timeline item"
    PRIORITY_CHANGED_EVENT
    "PublicTimelineItem timeline item"
    PUBLIC_TIMELINE_ITEM
    "RelatedByIssueEvent timeline item"
    RELATED_BY_ISSUE_EVENT
    "RelationTypeChangedEvent timeline item"
    RELATION_TYPE_CHANGED_EVENT
    "RemovedAffectedEntityEvent timeline item"
    REMOVED_AFFECTED_ENTITY_EVENT
    "RemovedArtefactEvent timeline item"
    REMOVED_ARTEFACT_EVENT
    "RemovedAssignmentEvent timeline item"
    REMOVED_ASSIGNMENT_EVENT
    "RemovedFromPinnedIssuesEvent timeline item"
    REMOVED_FROM_PINNED_ISSUES_EVENT
    "RemovedFromTrackableEvent timeline item"
    REMOVED_FROM_TRACKABLE_EVENT
    "RemovedIncomingRelationEvent timeline item"
    REMOVED_INCOMING_RELATION_EVENT
    "RemovedLabelEvent timeline item"
    REMOVED_LABEL_EVENT
    "RemovedOutgoingRelationEvent timeline item"
    REMOVED_OUTGOING_RELATION_EVENT
    "RemovedRelationEvent timeline item"
    REMOVED_RELATION_EVENT
    "RemovedTemplatedFieldEvent timeline item"
    REMOVED_TEMPLATED_FIELD_EVENT
    "SpentTimeChangedEvent timeline item"
    SPENT_TIME_CHANGED_EVENT
    "StartDateChangedEvent timeline item"
    START_DATE_CHANGED_EVENT
    "StateChangedEvent timeline item"
    STATE_CHANGED_EVENT
    "TemplatedFieldChangedEvent timeline item"
    TEMPLATED_FIELD_CHANGED_EVENT
    "TemplateChangedEvent timeline item"
    TEMPLATE_CHANGED_EVENT
    "TimelineItem timeline item"
    TIMELINE_ITEM
    "TitleChangedEvent timeline item"
    TITLE_CHANGED_EVENT
    "TypeChangedEvent timeline item"
    TYPE_CHANGED_EVENT
}

"Fields a list of Trackable can be sorted by"
enum TrackableOrderField {
    "Order by id"
    ID
    "Order by name"
    NAME
}

"Fields a list of User can be sorted by"
enum UserOrderField {
    "Order by displayName"
    DISPLAY_NAME
    "Order by email"
    EMAIL
    "Order by id"
    ID
    "Order by username"
    USERNAME
}

"A slightly refined version of RFC-3339 compliant DateTime Scalar"
scalar DateTime

"An ISO 8601 duration string, e.g. P2Y7M4DT5H42M"
scalar Duration

"A JSON scalar"
scalar JSON

"A URL scalar. Must specify a scheme (https, http, ...). E.g. https://example.com"
scalar URL

"Input for the addAffectedEntityToIssue mutation"
input AddAffectedEntityToIssueInput {
    "The id of the AffectedByIssue which is affected by the Issue"
    affectedEntity: ID!
    "The id of the Issue which affects the entity"
    issue: ID!
}

"Input for the addArtefactToIssue mutation"
input AddArtefactToIssueInput {
    "The id of the Artefact to add"
    artefact: ID!
    "The id of the Issue where to add the Artefact"
    issue: ID!
}

"Input for the addComponentVersionToProject mutation"
input AddComponentVersionToProjectInput {
    "The id of the ComponentVersion to add"
    componentVersion: ID!
    "The id of the Project where to add the ComponentVersion"
    project: ID!
}

"Input for the addInterfaceSpecificationVersionToComponentVersion mutation"
input AddInterfaceSpecificationVersionToComponentVersionInput {
    "The id of the ComponentVersion to add the InterfaceSpecificationVersion to."
    componentVersion: ID!
    "The id of the InterfaceSpecificationVersion to add. Must be part of the same Component as `componentVersion`"
    interfaceSpecificationVersion: ID!
    "If `true`, the InterfaceSpecificationVersion is added invisible"
    invisible: Boolean!
    "If `true`, the InterfaceSpecificationVersion is added visible"
    visible: Boolean!
}

"Input for the addIssueToPinnedIssues mutation"
input AddIssueToPinnedIssuesInput {
    "The id of the Issue to pin"
    issue: ID!
    "The id of the Trackable where the Issue should be pinned"
    trackable: ID!
}

"Input for the addIssueToTrackable mutation"
input AddIssueToTrackableInput {
    "The id of the Issue to add to the Trackable"
    issue: ID!
    "The id of the Trackable where to add the Issue"
    trackable: ID!
}

"Input for the addLabelToIssue mutation"
input AddLabelToIssueInput {
    "The id of the Issue where to add the Label"
    issue: ID!
    "The id of the Label to add"
    label: ID!
}

"Input for the addLabelToTrackable mutation"
input AddLabelToTrackableInput {
    "The id of the Label to add"
    label: ID!
    "The id of the Trackable where to add the Label"
    trackable: ID!
}

"Filter used to filter AffectedByIssue"
input AffectedByIssueFilterInput {
    "Filter by affectingIssues"
    affectingIssues: IssueListFilterInput
    "Connects all subformulas via and"
    and: [AffectedByIssueFilterInput!]
    "Filter by description"
    description: StringFilterInput
    "Filter by id"
    id: IDFilterInput
    "Filter by name"
    name: StringFilterInput
    "Negates the subformula"
    not: AffectedByIssueFilterInput
    "Connects all subformulas via or"
    or: [AffectedByIssueFilterInput!]
    "Filters for AffectedByIssues which are related to a Trackable"
    relatedTo: ID
}

"Used to filter by a connection-based property. Fields are joined by AND"
input AffectedByIssueListFilterInput {
    "Filters for nodes where all of the related nodes match this filter"
    all: AffectedByIssueFilterInput
    "Filters for nodes where any of the related nodes match this filter"
    any: AffectedByIssueFilterInput
    "Filters for nodes where none of the related nodes match this filter"
    none: AffectedByIssueFilterInput
}

"Defines the order of a AffectedByIssue list"
input AffectedByIssueOrder {
    "The direction to order by, defaults to ASC"
    direction: OrderDirection = ASC
    "The field to order by, defaults to ID"
    field: AffectedByIssueOrderField = ID
}

"Filter used to filter AggregatedIssue"
input AggregatedIssueFilterInput {
    "Connects all subformulas via and"
    and: [AggregatedIssueFilterInput!]
    "Filter by count"
    count: IntFilterInput
    "Filter by id"
    id: IDFilterInput
    "Filter by incomingRelations"
    incomingRelations: AggregatedIssueRelationListFilterInput
    "Filter by isOpen"
    isOpen: BooleanFilterInput
    "Filter by issues"
    issues: IssueListFilterInput
    "Negates the subformula"
    not: AggregatedIssueFilterInput
    "Connects all subformulas via or"
    or: [AggregatedIssueFilterInput!]
    "Filter by outgoingRelations"
    outgoingRelations: AggregatedIssueRelationListFilterInput
    "Filters for nodes where the related node match this filter"
    relationPartner: RelationPartnerFilterInput
    "Filters for nodes where the related node match this filter"
    type: IssueTypeFilterInput
}

"Used to filter by a connection-based property. Fields are joined by AND"
input AggregatedIssueListFilterInput {
    "Filters for nodes where all of the related nodes match this filter"
    all: AggregatedIssueFilterInput
    "Filters for nodes where any of the related nodes match this filter"
    any: AggregatedIssueFilterInput
    "Filters for nodes where none of the related nodes match this filter"
    none: AggregatedIssueFilterInput
}

"Defines the order of a AggregatedIssue list"
input AggregatedIssueOrder {
    "The direction to order by, defaults to ASC"
    direction: OrderDirection = ASC
    "The field to order by, defaults to ID"
    field: AggregatedIssueOrderField = ID
}

"Filter used to filter AggregatedIssueRelation"
input AggregatedIssueRelationFilterInput {
    "Connects all subformulas via and"
    and: [AggregatedIssueRelationFilterInput!]
    "Filters for nodes where the related node match this filter"
    end: AggregatedIssueFilterInput
    "Filter by id"
    id: IDFilterInput
    "Filter by issueRelations"
    issueRelations: IssueRelationListFilterInput
    "Negates the subformula"
    not: AggregatedIssueRelationFilterInput
    "Connects all subformulas via or"
    or: [AggregatedIssueRelationFilterInput!]
    "Filters for nodes where the related node match this filter"
    start: AggregatedIssueFilterInput
    "Filters for nodes where the related node match this filter"
    type: IssueRelationTypeFilterInput
}

"Used to filter by a connection-based property. Fields are joined by AND"
input AggregatedIssueRelationListFilterInput {
    "Filters for nodes where all of the related nodes match this filter"
    all: AggregatedIssueRelationFilterInput
    "Filters for nodes where any of the related nodes match this filter"
    any: AggregatedIssueRelationFilterInput
    "Filters for nodes where none of the related nodes match this filter"
    none: AggregatedIssueRelationFilterInput
}

"Defines the order of a AggregatedIssueRelation list"
input AggregatedIssueRelationOrder {
    "The direction to order by, defaults to ASC"
    direction: OrderDirection = ASC
    "The field to order by, defaults to ID"
    field: AggregatedIssueRelationOrderField = ID
}

"Filter used to filter Artefact"
input ArtefactFilterInput {
    "Connects all subformulas via and"
    and: [ArtefactFilterInput!]
    "Filter by createdAt"
    createdAt: DateTimeFilterInput
    "Filters for nodes where the related node match this filter"
    createdBy: UserFilterInput
    "Filter by file"
    file: StringFilterInput
    "Filter by from"
    from: NullableIntFilterInput
    "Filter by id"
    id: IDFilterInput
    "Filter by issues"
    issues: IssueListFilterInput
    "Filter by lastModifiedAt"
    lastModifiedAt: DateTimeFilterInput
    "Filters for nodes where the related node match this filter"
    lastModifiedBy: UserFilterInput
    "Negates the subformula"
    not: ArtefactFilterInput
    "Connects all subformulas via or"
    or: [ArtefactFilterInput!]
    "Filter by referencingComments"
    referencingComments: IssueCommentListFilterInput
    "Filters for nodes where the related node match this filter"
    template: ArtefactTemplateFilterInput
    "Filter for templated fields with matching key and values. Entries are joined by AND"
    templatedFields: [JSONFieldInput]
    "Filter by to"
    to: NullableIntFilterInput
    "Filters for nodes where the related node match this filter"
    trackable: TrackableFilterInput
    "Filter by version"
    version: NullableStringFilterInput
}

"Used to filter by a connection-based property. Fields are joined by AND"
input ArtefactListFilterInput {
    "Filters for nodes where all of the related nodes match this filter"
    all: ArtefactFilterInput
    "Filters for nodes where any of the related nodes match this filter"
    any: ArtefactFilterInput
    "Filters for nodes where none of the related nodes match this filter"
    none: ArtefactFilterInput
}

"Defines the order of a Artefact list"
input ArtefactOrder {
    "The direction to order by, defaults to ASC"
    direction: OrderDirection = ASC
    "The field to order by, defaults to ID"
    field: ArtefactOrderField = ID
}

"Filter used to filter ArtefactTemplate"
input ArtefactTemplateFilterInput {
    "Connects all subformulas via and"
    and: [ArtefactTemplateFilterInput!]
    "Filter by description"
    description: StringFilterInput
    "Filter by extendedBy"
    extendedBy: ArtefactTemplateListFilterInput
    "Filter by extends"
    extends: ArtefactTemplateListFilterInput
    "Filter by id"
    id: IDFilterInput
    "Filter by isDeprecated"
    isDeprecated: BooleanFilterInput
    "Filter by name"
    name: StringFilterInput
    "Negates the subformula"
    not: ArtefactTemplateFilterInput
    "Connects all subformulas via or"
    or: [ArtefactTemplateFilterInput!]
}

"Used to filter by a connection-based property. Fields are joined by AND"
input ArtefactTemplateListFilterInput {
    "Filters for nodes where all of the related nodes match this filter"
    all: ArtefactTemplateFilterInput
    "Filters for nodes where any of the related nodes match this filter"
    any: ArtefactTemplateFilterInput
    "Filters for nodes where none of the related nodes match this filter"
    none: ArtefactTemplateFilterInput
}

"Defines the order of a ArtefactTemplate list"
input ArtefactTemplateOrder {
    "The direction to order by, defaults to ASC"
    direction: OrderDirection = ASC
    "The field to order by, defaults to ID"
    field: ArtefactTemplateOrderField = ID
}

"Filter used to filter Assignment"
input AssignmentFilterInput {
    "Connects all subformulas via and"
    and: [AssignmentFilterInput!]
    "Filter by createdAt"
    createdAt: DateTimeFilterInput
    "Filters for nodes where the related node match this filter"
    createdBy: UserFilterInput
    "Filter by id"
    id: IDFilterInput
    "Filters for nodes where the related node match this filter"
    issue: IssueFilterInput
    "Filter by lastModifiedAt"
    lastModifiedAt: DateTimeFilterInput
    "Filters for nodes where the related node match this filter"
    lastModifiedBy: UserFilterInput
    "Negates the subformula"
    not: AssignmentFilterInput
    "Connects all subformulas via or"
    or: [AssignmentFilterInput!]
    "Filters for nodes where the related node match this filter"
    parentItem: ParentTimelineItemFilterInput
    "Filter for specific timeline items. Entries are joined by OR"
    timelineItemTypes: [TimelineItemType!]
    "Filters for nodes where the related node match this filter"
    type: AssignmentTypeFilterInput
    "Filters for nodes where the related node match this filter"
    user: UserFilterInput
}

"Used to filter by a connection-based property. Fields are joined by AND"
input AssignmentListFilterInput {
    "Filters for nodes where all of the related nodes match this filter"
    all: AssignmentFilterInput
    "Filters for nodes where any of the related nodes match this filter"
    any: AssignmentFilterInput
    "Filters for nodes where none of the related nodes match this filter"
    none: AssignmentFilterInput
}

"Defines the order of a Assignment list"
input AssignmentOrder {
    "The direction to order by, defaults to ASC"
    direction: OrderDirection = ASC
    "The field to order by, defaults to ID"
    field: AssignmentOrderField = ID
}

"Filter used to filter AssignmentType"
input AssignmentTypeFilterInput {
    "Connects all subformulas via and"
    and: [AssignmentTypeFilterInput!]
    "Filter by assignmentsWithType"
    assignmentsWithType: AssignmentListFilterInput
    "Filter by description"
    description: StringFilterInput
    "Filter by id"
    id: IDFilterInput
    "Filter by name"
    name: StringFilterInput
    "Negates the subformula"
    not: AssignmentTypeFilterInput
    "Connects all subformulas via or"
    or: [AssignmentTypeFilterInput!]
    "Filter by partOf"
    partOf: IssueTemplateListFilterInput
}

"Input to create an AssignmentType"
input AssignmentTypeInput {
    "The description of the NamedNode"
    description: String!
    "The name of the NamedNode, must not be blank"
    name: String!
}

"Used to filter by a connection-based property. Fields are joined by AND"
input AssignmentTypeListFilterInput {
    "Filters for nodes where all of the related nodes match this filter"
    all: AssignmentTypeFilterInput
    "Filters for nodes where any of the related nodes match this filter"
    any: AssignmentTypeFilterInput
    "Filters for nodes where none of the related nodes match this filter"
    none: AssignmentTypeFilterInput
}

"Defines the order of a AssignmentType list"
input AssignmentTypeOrder {
    "The direction to order by, defaults to ASC"
    direction: OrderDirection = ASC
    "The field to order by, defaults to ID"
    field: AssignmentTypeOrderField = ID
}

"Filter used to filter AuditedNode"
input AuditedNodeFilterInput {
    "Connects all subformulas via and"
    and: [AuditedNodeFilterInput!]
    "Filter by createdAt"
    createdAt: DateTimeFilterInput
    "Filters for nodes where the related node match this filter"
    createdBy: UserFilterInput
    "Filter by id"
    id: IDFilterInput
    "Filter by lastModifiedAt"
    lastModifiedAt: DateTimeFilterInput
    "Filters for nodes where the related node match this filter"
    lastModifiedBy: UserFilterInput
    "Negates the subformula"
    not: AuditedNodeFilterInput
    "Connects all subformulas via or"
    or: [AuditedNodeFilterInput!]
}

"Used to filter by a connection-based property. Fields are joined by AND"
input AuditedNodeListFilterInput {
    "Filters for nodes where all of the related nodes match this filter"
    all: AuditedNodeFilterInput
    "Filters for nodes where any of the related nodes match this filter"
    any: AuditedNodeFilterInput
    "Filters for nodes where none of the related nodes match this filter"
    none: AuditedNodeFilterInput
}

"Defines the order of a AuditedNode list"
input AuditedNodeOrder {
    "The direction to order by, defaults to ASC"
    direction: OrderDirection = ASC
    "The field to order by, defaults to ID"
    field: AuditedNodeOrderField = ID
}

"Filter used to filter BasePermission"
input BasePermissionFilterInput {
    "Filter by allUsers"
    allUsers: BooleanFilterInput
    "Connects all subformulas via and"
    and: [BasePermissionFilterInput!]
    "Filter by description"
    description: StringFilterInput
    "Filter by id"
    id: IDFilterInput
    "Filter by name"
    name: StringFilterInput
    "Negates the subformula"
    not: BasePermissionFilterInput
    "Connects all subformulas via or"
    or: [BasePermissionFilterInput!]
    "Filter by users"
    users: GropiusUserListFilterInput
}

"Used to filter by a connection-based property. Fields are joined by AND"
input BasePermissionListFilterInput {
    "Filters for nodes where all of the related nodes match this filter"
    all: BasePermissionFilterInput
    "Filters for nodes where any of the related nodes match this filter"
    any: BasePermissionFilterInput
    "Filters for nodes where none of the related nodes match this filter"
    none: BasePermissionFilterInput
}

"Defines the order of a BasePermission list"
input BasePermissionOrder {
    "The direction to order by, defaults to ASC"
    direction: OrderDirection = ASC
    "The field to order by, defaults to ID"
    field: BasePermissionOrderField = ID
}

"Filter used to filter Body"
input BodyFilterInput {
    "Connects all subformulas via and"
    and: [BodyFilterInput!]
    "Filter by answeredBy"
    answeredBy: IssueCommentListFilterInput
    "Filter by bodyLastEditedAt"
    bodyLastEditedAt: DateTimeFilterInput
    "Filters for nodes where the related node match this filter"
    bodyLastEditedBy: UserFilterInput
    "Filter by createdAt"
    createdAt: DateTimeFilterInput
    "Filters for nodes where the related node match this filter"
    createdBy: UserFilterInput
    "Filter by id"
    id: IDFilterInput
    "Filters for nodes where the related node match this filter"
    issue: IssueFilterInput
    "Filter by lastModifiedAt"
    lastModifiedAt: DateTimeFilterInput
    "Filters for nodes where the related node match this filter"
    lastModifiedBy: UserFilterInput
    "Negates the subformula"
    not: BodyFilterInput
    "Connects all subformulas via or"
    or: [BodyFilterInput!]
    "Filters for nodes where the related node match this filter"
    parentItem: ParentTimelineItemFilterInput
    "Filter for specific timeline items. Entries are joined by OR"
    timelineItemTypes: [TimelineItemType!]
}

"Filter which can be used to filter for Nodes with a specific Boolean field"
input BooleanFilterInput {
    "Matches values which are equal to the provided value"
    eq: Boolean
    "Matches values which are equal to any of the provided values"
    in: [Boolean!]
}

"Input for the changeAssignmentType mutation"
input ChangeAssignmentTypeInput {
    "The id of the Assignment of which the type is updated"
    assignment: ID!
    "The id of the new type, must be defined by the template of the Issue"
    type: ID
}

"Input for the changeIssueDueDate mutation"
input ChangeIssueDueDateInput {
    "The new dueDate"
    dueDate: DateTime
    "The id of the Issue of which the dueDate is updated"
    issue: ID!
}

"Input for the changeIssueEstimatedTime mutation"
input ChangeIssueEstimatedTimeInput {
    "The new estimatedTime"
    estimatedTime: Duration
    "The id of the Issue of which the estimatedTime is updated"
    issue: ID!
}

"Input for the changeIssuePriority mutation"
input ChangeIssuePriorityInput {
    "The id of the Issue of which the priority is updated"
    issue: ID!
    "The id of the new priority, must be an IssuePriority of the used IssueTemplate"
    priority: ID
}

"Input for the changeIssueRelationType mutation"
input ChangeIssueRelationTypeInput {
    "The id of the IssueRelation of which the type is updated"
    issueRelation: ID!
    "The id of the new type, must be defined by the template of the Issue"
    type: ID
}

"Input for the changeIssueSpentTime mutation"
input ChangeIssueSpentTimeInput {
    "The id of the Issue of which the spentTime is updated"
    issue: ID!
    "The new spentTime"
    spentTime: Duration
}

"Input for the changeIssueStartDate mutation"
input ChangeIssueStartDateInput {
    "The id of the Issue of which the startDate is updated"
    issue: ID!
    "The new startDate"
    startDate: DateTime
}

"Input for the changeIssueState mutation"
input ChangeIssueStateInput {
    "The id of the Issue of which the state is updated"
    issue: ID!
    "The id of the new state, must be an IssueState of the used IssueTemplate"
    state: ID!
}

"Input for the changeIssueTemplate mutation"
input ChangeIssueTemplateInput {
    "Mapping to map existing Assignment Types to new ones"
    assignmentTypeMapping: [TypeMappingInput!]
    "The Issue to update the template of"
    issue: ID!
    "Mapping to map existing IssueRelationTypes to new ones"
    issueRelationTypeMapping: [TypeMappingInput!]
    "The new priority of the Issue"
    priority: ID
    "The new state of the Issue, required if the old one is not compatible with the new template"
    state: ID
    "If provided, the id of the new template for the Issue"
    template: ID!
    "Values for templatedFields to update, required to ensure compatibility with the new template"
    templatedFields: [JSONFieldInput!]
    "The new type of the Issue, required if the old one is not compatible with the new template"
    type: ID
}

"Input for the changeIssueTemplatedField mutations"
input ChangeIssueTemplatedFieldInput {
    "The id of the Issue of which to change a templated field"
    issue: ID!
    "The name of the templated field to update"
    name: String!
    "The new value of the templated field"
    value: JSON
}

"Input for the changeIssueTitle mutation"
input ChangeIssueTitleInput {
    "The id of the Issue of which the title is updated"
    issue: ID!
    "The new title"
    title: String!
}

"Input for the changeIssueType mutation"
input ChangeIssueTypeInput {
    "The id of the Issue of which the type is updated"
    issue: ID!
    "The id of the new type, must be an IssueType of the used IssueTemplate"
    type: ID!
}

"Filter used to filter Comment"
input CommentFilterInput {
    "Connects all subformulas via and"
    and: [CommentFilterInput!]
    "Filter by answeredBy"
    answeredBy: IssueCommentListFilterInput
    "Filter by bodyLastEditedAt"
    bodyLastEditedAt: DateTimeFilterInput
    "Filters for nodes where the related node match this filter"
    bodyLastEditedBy: UserFilterInput
    "Filter by createdAt"
    createdAt: DateTimeFilterInput
    "Filters for nodes where the related node match this filter"
    createdBy: UserFilterInput
    "Filter by id"
    id: IDFilterInput
    "Filters for nodes where the related node match this filter"
    issue: IssueFilterInput
    "Filter by lastModifiedAt"
    lastModifiedAt: DateTimeFilterInput
    "Filters for nodes where the related node match this filter"
    lastModifiedBy: UserFilterInput
    "Negates the subformula"
    not: CommentFilterInput
    "Connects all subformulas via or"
    or: [CommentFilterInput!]
    "Filters for nodes where the related node match this filter"
    parentItem: ParentTimelineItemFilterInput
    "Filter for specific timeline items. Entries are joined by OR"
    timelineItemTypes: [TimelineItemType!]
}

"Filter used to filter Component"
input ComponentFilterInput {
    "Filter by affectingIssues"
    affectingIssues: IssueListFilterInput
    "Connects all subformulas via and"
    and: [ComponentFilterInput!]
    "Filter by artefacts"
    artefacts: ArtefactListFilterInput
    "Filter by description"
    description: StringFilterInput
    "Filter by id"
    id: IDFilterInput
    "Filter by interfaceSpecifications"
    interfaceSpecifications: InterfaceSpecificationListFilterInput
    "Filter by issues"
    issues: IssueListFilterInput
    "Filter by labels"
    labels: LabelListFilterInput
    "Filter by name"
    name: StringFilterInput
    "Negates the subformula"
    not: ComponentFilterInput
    "Connects all subformulas via or"
    or: [ComponentFilterInput!]
    "Filter by permissions"
    permissions: ComponentPermissionListFilterInput
    "Filter by pinnedIssues"
    pinnedIssues: IssueListFilterInput
    "Filters for AffectedByIssues which are related to a Trackable"
    relatedTo: ID
    "Filter by repositoryURL"
    repositoryURL: NullableStringFilterInput
    "Filter by syncsTo"
    syncsTo: IMSProjectListFilterInput
    "Filters for nodes where the related node match this filter"
    template: ComponentTemplateFilterInput
    "Filter for templated fields with matching key and values. Entries are joined by AND"
    templatedFields: [JSONFieldInput]
    "Filter by versions"
    versions: ComponentVersionListFilterInput
}

"Used to filter by a connection-based property. Fields are joined by AND"
input ComponentListFilterInput {
    "Filters for nodes where all of the related nodes match this filter"
    all: ComponentFilterInput
    "Filters for nodes where any of the related nodes match this filter"
    any: ComponentFilterInput
    "Filters for nodes where none of the related nodes match this filter"
    none: ComponentFilterInput
}

"Defines the order of a Component list"
input ComponentOrder {
    "The direction to order by, defaults to ASC"
    direction: OrderDirection = ASC
    "The field to order by, defaults to ID"
    field: ComponentOrderField = ID
}

"Filter used to filter ComponentPermission"
input ComponentPermissionFilterInput {
    "Filter by allUsers"
    allUsers: BooleanFilterInput
    "Connects all subformulas via and"
    and: [ComponentPermissionFilterInput!]
    "Filter by description"
    description: StringFilterInput
    "Filter by id"
    id: IDFilterInput
    "Filter by name"
    name: StringFilterInput
    "Filter by nodesWithPermission"
    nodesWithPermission: ComponentListFilterInput
    "Negates the subformula"
    not: ComponentPermissionFilterInput
    "Connects all subformulas via or"
    or: [ComponentPermissionFilterInput!]
    "Filter by users"
    users: GropiusUserListFilterInput
}

"Used to filter by a connection-based property. Fields are joined by AND"
input ComponentPermissionListFilterInput {
    "Filters for nodes where all of the related nodes match this filter"
    all: ComponentPermissionFilterInput
    "Filters for nodes where any of the related nodes match this filter"
    any: ComponentPermissionFilterInput
    "Filters for nodes where none of the related nodes match this filter"
    none: ComponentPermissionFilterInput
}

"Defines the order of a ComponentPermission list"
input ComponentPermissionOrder {
    "The direction to order by, defaults to ASC"
    direction: OrderDirection = ASC
    "The field to order by, defaults to ID"
    field: ComponentPermissionOrderField = ID
}

"Filter used to filter ComponentTemplate"
input ComponentTemplateFilterInput {
    "Connects all subformulas via and"
    and: [ComponentTemplateFilterInput!]
    "Filter by description"
    description: StringFilterInput
    "Filter by extendedBy"
    extendedBy: ComponentTemplateListFilterInput
    "Filter by extends"
    extends: ComponentTemplateListFilterInput
    "Filter by id"
    id: IDFilterInput
    "Filter by isDeprecated"
    isDeprecated: BooleanFilterInput
    "Filter by name"
    name: StringFilterInput
    "Negates the subformula"
    not: ComponentTemplateFilterInput
    "Connects all subformulas via or"
    or: [ComponentTemplateFilterInput!]
    "Filter by possibleEndOfRelations"
    possibleEndOfRelations: RelationConditionListFilterInput
    "Filter by possibleInvisibleInterfaceSpecifications"
    possibleInvisibleInterfaceSpecifications: InterfaceSpecificationTemplateListFilterInput
    "Filter by possibleStartOfRelations"
    possibleStartOfRelations: RelationConditionListFilterInput
    "Filter by possibleVisibleInterfaceSpecifications"
    possibleVisibleInterfaceSpecifications: InterfaceSpecificationTemplateListFilterInput
}

"Used to filter by a connection-based property. Fields are joined by AND"
input ComponentTemplateListFilterInput {
    "Filters for nodes where all of the related nodes match this filter"
    all: ComponentTemplateFilterInput
    "Filters for nodes where any of the related nodes match this filter"
    any: ComponentTemplateFilterInput
    "Filters for nodes where none of the related nodes match this filter"
    none: ComponentTemplateFilterInput
}

"Defines the order of a ComponentTemplate list"
input ComponentTemplateOrder {
    "The direction to order by, defaults to ASC"
    direction: OrderDirection = ASC
    "The field to order by, defaults to ID"
    field: ComponentTemplateOrderField = ID
}

"Filter used to filter ComponentVersion"
input ComponentVersionFilterInput {
    "Filter by affectingIssues"
    affectingIssues: IssueListFilterInput
    "Filter by aggregatedIssues"
    aggregatedIssues: AggregatedIssueListFilterInput
    "Connects all subformulas via and"
    and: [ComponentVersionFilterInput!]
    "Filters for nodes where the related node match this filter"
    component: ComponentFilterInput
    "Filter by description"
    description: StringFilterInput
    "Filter by id"
    id: IDFilterInput
    "Filter by includingProjects"
    includingProjects: ProjectListFilterInput
    "Filter by incomingRelations"
    incomingRelations: RelationListFilterInput
    "Filter by interfaceDefinitions"
    interfaceDefinitions: InterfaceDefinitionListFilterInput
    "Filter by intraComponentDependencySpecifications"
    intraComponentDependencySpecifications: IntraComponentDependencySpecificationListFilterInput
    "Filter by name"
    name: StringFilterInput
    "Negates the subformula"
    not: ComponentVersionFilterInput
    "Connects all subformulas via or"
    or: [ComponentVersionFilterInput!]
    "Filter by outgoingRelations"
    outgoingRelations: RelationListFilterInput
    "Filters for RelationPartners which are part of a Project's component graph"
    partOfProject: ID
    "Filters for AffectedByIssues which are related to a Trackable"
    relatedTo: ID
    "Filters for nodes where the related node match this filter"
    template: ComponentVersionTemplateFilterInput
    "Filter for templated fields with matching key and values. Entries are joined by AND"
    templatedFields: [JSONFieldInput]
    "Filter by version"
    version: StringFilterInput
}

"Input to create a ComponentVersion"
input ComponentVersionInput {
    "The description of the NamedNode"
    description: String!
    "The name of the NamedNode, must not be blank"
    name: String!
    "Initial values for all templatedFields"
    templatedFields: [JSONFieldInput!]!
    "The version of the created ComponentVersion"
    version: String!
}

"Used to filter by a connection-based property. Fields are joined by AND"
input ComponentVersionListFilterInput {
    "Filters for nodes where all of the related nodes match this filter"
    all: ComponentVersionFilterInput
    "Filters for nodes where any of the related nodes match this filter"
    any: ComponentVersionFilterInput
    "Filters for nodes where none of the related nodes match this filter"
    none: ComponentVersionFilterInput
}

"Defines the order of a ComponentVersion list"
input ComponentVersionOrder {
    "The direction to order by, defaults to ASC"
    direction: OrderDirection = ASC
    "The field to order by, defaults to ID"
    field: ComponentVersionOrderField = ID
}

"Filter used to filter ComponentVersionTemplate"
input ComponentVersionTemplateFilterInput {
    "Connects all subformulas via and"
    and: [ComponentVersionTemplateFilterInput!]
    "Filter by description"
    description: StringFilterInput
    "Filter by id"
    id: IDFilterInput
    "Filter by name"
    name: StringFilterInput
    "Negates the subformula"
    not: ComponentVersionTemplateFilterInput
    "Connects all subformulas via or"
    or: [ComponentVersionTemplateFilterInput!]
}

"Input for the createArtefact mutation"
input CreateArtefactInput {
    "The initial file of the Artefact"
    file: URL!
    "The initial value of the from field of the Artefact"
    from: Int
    "The template of the created Artefact"
    template: ID!
    "Initial values for all templatedFields"
    templatedFields: [JSONFieldInput!]!
    "The initial value of the to field of the Artefact"
    to: Int
    "ID of the Trackable the created Artefact is part of"
    trackable: ID!
    "Initial version of the Artefact"
    version: String
}

"Input for the createArtefactTemplate mutation"
input CreateArtefactTemplateInput {
    "The description of the NamedNode"
    description: String!
    "IDs of Templates the created template extends. Must be templates of the same type."
    extends: [ID!]
    "The name of the NamedNode, must not be blank"
    name: String!
    """
    Additional initial templateFieldSpecifications, should be a JSON schema JSON.
    Must be disjoint with templateFieldSpecifications of templates this template extends.

    """
    templateFieldSpecifications: [JSONFieldInput!]
}

"Input for the createAssignment mutation"
input CreateAssignmentInput {
    "The optional type of the Assignment, must be defined by the Template of the Issue"
    assignmentType: ID
    "The id of the Issue to which the User should be assigned"
    issue: ID!
    "The id of the User to assign to the Issue"
    user: ID!
}

"Input for the createComponent mutation"
input CreateComponentInput {
    "The description of the NamedNode"
    description: String!
    "Initial InterfaceSpecifications"
    interfaceSpecifications: [InterfaceSpecificationInput!]
    "The name of the NamedNode, must not be blank"
    name: String!
    "The repositoryURL of the named node"
    repositoryURL: URL
    "The template of the created Component"
    template: ID!
    "Initial values for all templatedFields"
    templatedFields: [JSONFieldInput!]!
    "Initial versions of the Component"
    versions: [ComponentVersionInput!]
}

"Input for the createComponentPermission mutation"
input CreateComponentPermissionInput {
    "If `true`, the created BasePermission affects all users"
    allUsers: Boolean!
    "The description of the BasePermission"
    description: String!
    "The initial entries of the created ComponentPermission"
    entries: [ComponentPermissionEntry!]!
    "The name of the BasePermission, must not be blank"
    name: String!
    "The id of nodes the created permission affects."
    nodesWithPermission: [ID!]!
    "Ids of GropiusUsers this BasePermission affects"
    users: [ID!]!
}

"Input for the createComponentTemplate mutation"
input CreateComponentTemplateInput {
    "SubTemplate for all ComponentVersions of a Component with the created Template"
    componentVersionTemplate: SubTemplateInput!
    "The description of the NamedNode"
    description: String!
    "IDs of Templates the created template extends. Must be templates of the same type."
    extends: [ID!]
    "Style of the fill"
    fill: FillStyleInput
    "The name of the NamedNode, must not be blank"
    name: String!
    "The corner radius of the shape, ignored for circle/ellipse"
    shapeRadius: Float
    "The type of the shape"
    shapeType: ShapeType!
    "Style of the stroke"
    stroke: StrokeStyleInput
    """
    Additional initial templateFieldSpecifications, should be a JSON schema JSON.
    Must be disjoint with templateFieldSpecifications of templates this template extends.

    """
    templateFieldSpecifications: [JSONFieldInput!]
}

"Input for the createComponentVersion mutation"
input CreateComponentVersionInput {
    "The id of the Component the created ComponentVersion is part of"
    component: ID!
    "The description of the NamedNode"
    description: String!
    "The name of the NamedNode, must not be blank"
    name: String!
    "Initial values for all templatedFields"
    templatedFields: [JSONFieldInput!]!
    "The version of the created ComponentVersion"
    version: String!
}

"Input for the createGlobalPermission mutation"
input CreateGlobalPermissionInput {
    "If `true`, the created BasePermission affects all users"
    allUsers: Boolean!
    "The description of the BasePermission"
    description: String!
    "The initial entries of the created GlobalPermission"
    entries: [PermissionEntry!]!
    "The name of the BasePermission, must not be blank"
    name: String!
    "Ids of GropiusUsers this BasePermission affects"
    users: [ID!]!
}

"Input for the createIMS mutation"
input CreateIMSInput {
    "The description of the NamedNode"
    description: String!
    "The name of the NamedNode, must not be blank"
    name: String!
    "The template of the created IMS"
    template: ID!
    "Initial values for all templatedFields"
    templatedFields: [JSONFieldInput!]!
}

"Input for the createIMSPermission mutation"
input CreateIMSPermissionInput {
    "If `true`, the created BasePermission affects all users"
    allUsers: Boolean!
    "The description of the BasePermission"
    description: String!
    "The initial entries of the created IMSPermission"
    entries: [IMSPermissionEntry!]!
    "The name of the BasePermission, must not be blank"
    name: String!
    "The id of nodes the created permission affects."
    nodesWithPermission: [ID!]!
    "Ids of GropiusUsers this BasePermission affects"
    users: [ID!]!
}

"Input for the createIMSProject mutation"
input CreateIMSProjectInput {
    "The description of the NamedNode"
    description: String!
    "The id of the IMS the created project is part of"
    ims: ID!
    "The name of the NamedNode, must not be blank"
    name: String!
    "Initial values for all templatedFields"
    templatedFields: [JSONFieldInput!]!
    "The id of the Trackable which is synced"
    trackable: ID!
}

"Input for the createInterfacePart mutation"
input CreateInterfacePartInput {
    "The description of the NamedNode"
    description: String!
    "The id of the InterfaceSpecificationVersion the created InterfacePart is part of"
    interfaceSpecificationVersion: ID!
    "The name of the NamedNode, must not be blank"
    name: String!
    "Initial values for all templatedFields"
    templatedFields: [JSONFieldInput!]!
}

"Input for the createInterfaceSpecification mutation"
input CreateInterfaceSpecificationInput {
    "The id of the Component the created InterfaceSpecification is part of"
    component: ID!
    "The description of the NamedNode"
    description: String!
    "The name of the NamedNode, must not be blank"
    name: String!
    "The template of the created InterfaceSpecification"
    template: ID!
    "Initial values for all templatedFields"
    templatedFields: [JSONFieldInput!]!
    "Initial versions of the InterfaceSpecification"
    versions: [InterfaceSpecificationVersionInput!]
}

"Input for the createInterfaceSpecificationTemplate mutation"
input CreateInterfaceSpecificationTemplateInput {
    "The IDs of Templates of Components InterfaceSpecifications with the created template can be invisible on"
    canBeInvisibleOnComponents: [ID!]!
    "The IDs of Templates of Components InterfaceSpecifications with the created template can be visible on"
    canBeVisibleOnComponents: [ID!]!
    "The description of the NamedNode"
    description: String!
    "IDs of Templates the created template extends. Must be templates of the same type."
    extends: [ID!]
    "Style of the fill"
    fill: FillStyleInput
    "SubTemplate for all InterfacesDefinitions of a InterfaceSpecification with the created Template"
    interfaceDefinitionTemplate: NullableSubTemplateInput!
    "SubTemplate for all InterfaceParts of a InterfaceSpecification with the created Template"
    interfacePartTemplate: SubTemplateInput!
    "SubTemplate for all InterfaceSpecificationVersions of a InterfaceSpecification with the created Template"
    interfaceSpecificationVersionTemplate: SubTemplateInput!
    "SubTemplate for all Interfaces of a InterfaceSpecification with the created Template"
    interfaceTemplate: NullableSubTemplateInput!
    "The name of the NamedNode, must not be blank"
    name: String!
    "The corner radius of the shape, ignored for circle/ellipse"
    shapeRadius: Float
    "The type of the shape"
    shapeType: ShapeType!
    "Style of the stroke"
    stroke: StrokeStyleInput
    """
    Additional initial templateFieldSpecifications, should be a JSON schema JSON.
    Must be disjoint with templateFieldSpecifications of templates this template extends.

    """
    templateFieldSpecifications: [JSONFieldInput!]
}

"Input for the createInterfaceSpecificationVersion mutation"
input CreateInterfaceSpecificationVersionInput {
    "The description of the NamedNode"
    description: String!
    "The id of the InterfaceSpecification the created InterfaceSpecificationVersion is part of"
    interfaceSpecification: ID!
    "The name of the NamedNode, must not be blank"
    name: String!
    "Initial InterfaceParts"
    parts: [InterfacePartInput!]
    "Initial values for all templatedFields"
    templatedFields: [JSONFieldInput!]!
    "The version of the created InterfaceSpecificationVersion"
    version: String!
}

"Input for the createIntraComponentDependencySpecification mutation"
input CreateIntraComponentDependencySpecificationInput {
    "The id of the ComponentVersion the created IntraComponentDependencySpecification is part of"
    componentVersion: ID!
    "The description of the NamedNode"
    description: String!
    "Initial incomingParticipants, must not be empty"
    incomingParticipants: [IntraComponentDependencyParticipantInput!]!
    "The name of the NamedNode, must not be blank"
    name: String!
    "Initial outgoingParticipants, must not be empty"
    outgoingParticipants: [IntraComponentDependencyParticipantInput!]!
}

"Input for the createIssueComment mutation"
input CreateIssueCommentInput {
    "The id of the Comment the created IssueComment answers"
    answers: ID
    "Initial body of the IssueComment"
    body: String!
    "The id of the Issue the IssueComment is created on"
    issue: ID!
    "Ids of initially referenced artefacts"
    referencedArtefacts: [ID!]
}

"Input for the createIssue mutation"
input CreateIssueInput {
    "The body of the created Issue"
    body: String!
    "The id of the state of the created Issue, must be compatible with template "
    state: ID!
    "The template of the created Issue"
    template: ID!
    "Initial values for all templatedFields"
    templatedFields: [JSONFieldInput!]!
    "The title of the created Issue"
    title: String!
    "Ids of Trackables the Issue is initially on, must not be empty"
    trackables: [ID!]!
    "The id of the type of the created Issue, must be compatible with template"
    type: ID!
}

"Input for the createIssueRelation mutation"
input CreateIssueRelationInput {
    "The id of the Issue from which the IssueRelation starts"
    issue: ID!
    "The optional type of the IssueRelation, must be defined by the Template of the Issue"
    issueRelationType: ID
    "The id of the Issue where the IssueRelation ends"
    relatedIssue: ID!
}

"Input for the createIssueTemplate mutation."
input CreateIssueTemplateInput {
    "Set of all types Assignments to Issues with the created can have."
    assignmentTypes: [AssignmentTypeInput!]!
    "The description of the NamedNode"
    description: String!
    "IDs of Templates the created template extends. Must be templates of the same type."
    extends: [ID!]
    "Set of all priorities Issues with the created can have."
    issuePriorities: [IssuePriorityInput!]!
    "Set of all states Issues with the created Template can have"
    issueStates: [IssueStateInput!]!
    "Set of all types Issues with the created Template can have."
    issueTypes: [IssueTypeInput!]!
    "The name of the NamedNode, must not be blank"
    name: String!
    "Set of all types outgoing IssueRelations of Issues with the created can have"
    relationTypes: [IssueRelationTypeInput!]!
    """
    Additional initial templateFieldSpecifications, should be a JSON schema JSON.
    Must be disjoint with templateFieldSpecifications of templates this template extends.

    """
    templateFieldSpecifications: [JSONFieldInput!]
}

"Input for the createLabel mutation"
input CreateLabelInput {
    "Initial color of the Label"
    color: String!
    "The description of the NamedNode"
    description: String!
    "The name of the NamedNode, must not be blank"
    name: String!
    "IDs of Trackables the Label is added to, at least one required."
    trackables: [ID!]!
}

"Input for the createProject mutation"
input CreateProjectInput {
    "The description of the NamedNode"
    description: String!
    "The name of the NamedNode, must not be blank"
    name: String!
    "The repositoryURL of the named node"
    repositoryURL: URL
}

"Input for the createProjectPermission mutation"
input CreateProjectPermissionInput {
    "If `true`, the created BasePermission affects all users"
    allUsers: Boolean!
    "The description of the BasePermission"
    description: String!
    "The initial entries of the created ProjectPermission"
    entries: [ProjectPermissionEntry!]!
    "The name of the BasePermission, must not be blank"
    name: String!
    "The id of nodes the created permission affects."
    nodesWithPermission: [ID!]!
    "Ids of GropiusUsers this BasePermission affects"
    users: [ID!]!
}

"Input for the createRelation mutation"
input CreateRelationInput {
    "The end RelationPartner of the Relation"
    end: ID!
    "If `end` is an Interface, the parts of the Interface the created Relation includes"
    endParts: [ID!]
    "The start RelationPartner of the Relation"
    start: ID!
    "If `start` is an Interface, the parts of the Interface the created Relation includes"
    startParts: [ID!]
    "The template of the created Relation"
    template: ID!
    "Initial values for all templatedFields"
    templatedFields: [JSONFieldInput!]!
}

"Input for the createRelationTemplate mutation"
input CreateRelationTemplateInput {
    "The description of the NamedNode"
    description: String!
    "IDs of Templates the created template extends. Must be templates of the same type."
    extends: [ID!]
    "The type of the marker at the end of the relation."
    markerType: MarkerType!
    "The name of the NamedNode, must not be blank"
    name: String!
    "Defines which Relations can use the created Template, at least one RelationCondition has to match (logical OR)"
    relationConditions: [RelationConditionInput!]!
    "Style of the stroke"
    stroke: StrokeStyleInput
    """
    Additional initial templateFieldSpecifications, should be a JSON schema JSON.
    Must be disjoint with templateFieldSpecifications of templates this template extends.

    """
    templateFieldSpecifications: [JSONFieldInput!]
}

"Filter which can be used to filter for Nodes with a specific DateTime field"
input DateTimeFilterInput {
    "Matches values which are equal to the provided value"
    eq: DateTime
    "Matches values which are greater than the provided value"
    gt: DateTime
    "Matches values which are greater than or equal to the provided value"
    gte: DateTime
    "Matches values which are equal to any of the provided values"
    in: [DateTime!]
    "Matches values which are lesser than the provided value"
    lt: DateTime
    "Matches values which are lesser than or equal to the provided value"
    lte: DateTime
}

"Input for all delete mutations. Deletes the node with the specified id"
input DeleteNodeInput {
    "The id of the Node to delete"
    id: ID!
}

"Input to create a FillStyle"
input FillStyleInput {
    "The color of the fill"
    color: String!
}

"Filter which can be used to filter for Nodes with a specific Float field"
input FloatFilterInput {
    "Matches values which are equal to the provided value"
    eq: Float
    "Matches values which are greater than the provided value"
    gt: Float
    "Matches values which are greater than or equal to the provided value"
    gte: Float
    "Matches values which are equal to any of the provided values"
    in: [Float!]
    "Matches values which are lesser than the provided value"
    lt: Float
    "Matches values which are lesser than or equal to the provided value"
    lte: Float
}

"Filter used to filter GlobalPermission"
input GlobalPermissionFilterInput {
    "Filter by allUsers"
    allUsers: BooleanFilterInput
    "Connects all subformulas via and"
    and: [GlobalPermissionFilterInput!]
    "Filter by description"
    description: StringFilterInput
    "Filter by id"
    id: IDFilterInput
    "Filter by name"
    name: StringFilterInput
    "Negates the subformula"
    not: GlobalPermissionFilterInput
    "Connects all subformulas via or"
    or: [GlobalPermissionFilterInput!]
    "Filter by users"
    users: GropiusUserListFilterInput
}

"Filter used to filter GropiusUser"
input GropiusUserFilterInput {
    "Connects all subformulas via and"
    and: [GropiusUserFilterInput!]
    "Filter by assignments"
    assignments: AssignmentListFilterInput
    "Filter by canSyncOthers"
    canSyncOthers: SyncPermissionTargetListFilterInput
    "Filter by canSyncSelf"
    canSyncSelf: SyncPermissionTargetListFilterInput
    "Filter by createdNodes"
    createdNodes: AuditedNodeListFilterInput
    "Filter by displayName"
    displayName: StringFilterInput
    "Filter by email"
    email: NullableStringFilterInput
    "Filter for users with a specific permission on a node"
    hasNodePermission: NodePermissionFilterEntry
    "Filter by id"
    id: IDFilterInput
    "Filter by imsUsers"
    imsUsers: IMSUserListFilterInput
    "Negates the subformula"
    not: GropiusUserFilterInput
    "Connects all subformulas via or"
    or: [GropiusUserFilterInput!]
    "Filter by participatedIssues"
    participatedIssues: IssueListFilterInput
    "Filter by permissions"
    permissions: BasePermissionListFilterInput
    "Filter by username"
    username: NullableStringFilterInput
}

"Used to filter by a connection-based property. Fields are joined by AND"
input GropiusUserListFilterInput {
    "Filters for nodes where all of the related nodes match this filter"
    all: GropiusUserFilterInput
    "Filters for nodes where any of the related nodes match this filter"
    any: GropiusUserFilterInput
    "Filters for nodes where none of the related nodes match this filter"
    none: GropiusUserFilterInput
}

"Defines the order of a GropiusUser list"
input GropiusUserOrder {
    "The direction to order by, defaults to ASC"
    direction: OrderDirection = ASC
    "The field to order by, defaults to ID"
    field: GropiusUserOrderField = ID
}

"Filter which can be used to filter for Nodes with a specific ID field"
input IDFilterInput {
    "Matches values which are equal to the provided value"
    eq: ID
    "Matches values which are equal to any of the provided values"
    in: [ID!]
}

"Filter used to filter IMS"
input IMSFilterInput {
    "Connects all subformulas via and"
    and: [IMSFilterInput!]
    "Filter by description"
    description: StringFilterInput
    "Filter by id"
    id: IDFilterInput
    "Filter by name"
    name: StringFilterInput
    "Negates the subformula"
    not: IMSFilterInput
    "Connects all subformulas via or"
    or: [IMSFilterInput!]
    "Filter by permissions"
    permissions: IMSPermissionListFilterInput
    "Filter by projects"
    projects: IMSProjectListFilterInput
    "Filter by syncOthersAllowedBy"
    syncOthersAllowedBy: GropiusUserListFilterInput
    "Filter by syncSelfAllowedBy"
    syncSelfAllowedBy: GropiusUserListFilterInput
    "Filters for nodes where the related node match this filter"
    template: IMSTemplateFilterInput
    "Filter for templated fields with matching key and values. Entries are joined by AND"
    templatedFields: [JSONFieldInput]
    "Filter by users"
    users: IMSUserListFilterInput
}

"Filter used to filter IMSIssue"
input IMSIssueFilterInput {
    "Connects all subformulas via and"
    and: [IMSIssueFilterInput!]
    "Filter by id"
    id: IDFilterInput
    "Filters for nodes where the related node match this filter"
    imsProject: IMSProjectFilterInput
    "Filters for nodes where the related node match this filter"
    issue: IssueFilterInput
    "Negates the subformula"
    not: IMSIssueFilterInput
    "Connects all subformulas via or"
    or: [IMSIssueFilterInput!]
    "Filters for nodes where the related node match this filter"
    template: IMSIssueTemplateFilterInput
    "Filter for templated fields with matching key and values. Entries are joined by AND"
    templatedFields: [JSONFieldInput]
}

"Used to filter by a connection-based property. Fields are joined by AND"
input IMSIssueListFilterInput {
    "Filters for nodes where all of the related nodes match this filter"
    all: IMSIssueFilterInput
    "Filters for nodes where any of the related nodes match this filter"
    any: IMSIssueFilterInput
    "Filters for nodes where none of the related nodes match this filter"
    none: IMSIssueFilterInput
}

"Defines the order of a IMSIssue list"
input IMSIssueOrder {
    "The direction to order by, defaults to ASC"
    direction: OrderDirection = ASC
    "The field to order by, defaults to ID"
    field: IMSIssueOrderField = ID
}

"Filter used to filter IMSIssueTemplate"
input IMSIssueTemplateFilterInput {
    "Connects all subformulas via and"
    and: [IMSIssueTemplateFilterInput!]
    "Filter by description"
    description: StringFilterInput
    "Filter by id"
    id: IDFilterInput
    "Filter by name"
    name: StringFilterInput
    "Negates the subformula"
    not: IMSIssueTemplateFilterInput
    "Connects all subformulas via or"
    or: [IMSIssueTemplateFilterInput!]
}

"Used to filter by a connection-based property. Fields are joined by AND"
input IMSListFilterInput {
    "Filters for nodes where all of the related nodes match this filter"
    all: IMSFilterInput
    "Filters for nodes where any of the related nodes match this filter"
    any: IMSFilterInput
    "Filters for nodes where none of the related nodes match this filter"
    none: IMSFilterInput
}

"Defines the order of a IMS list"
input IMSOrder {
    "The direction to order by, defaults to ASC"
    direction: OrderDirection = ASC
    "The field to order by, defaults to ID"
    field: IMSOrderField = ID
}

"Filter used to filter IMSPermission"
input IMSPermissionFilterInput {
    "Filter by allUsers"
    allUsers: BooleanFilterInput
    "Connects all subformulas via and"
    and: [IMSPermissionFilterInput!]
    "Filter by description"
    description: StringFilterInput
    "Filter by id"
    id: IDFilterInput
    "Filter by name"
    name: StringFilterInput
    "Filter by nodesWithPermission"
    nodesWithPermission: IMSListFilterInput
    "Negates the subformula"
    not: IMSPermissionFilterInput
    "Connects all subformulas via or"
    or: [IMSPermissionFilterInput!]
    "Filter by users"
    users: GropiusUserListFilterInput
}

"Used to filter by a connection-based property. Fields are joined by AND"
input IMSPermissionListFilterInput {
    "Filters for nodes where all of the related nodes match this filter"
    all: IMSPermissionFilterInput
    "Filters for nodes where any of the related nodes match this filter"
    any: IMSPermissionFilterInput
    "Filters for nodes where none of the related nodes match this filter"
    none: IMSPermissionFilterInput
}

"Defines the order of a IMSPermission list"
input IMSPermissionOrder {
    "The direction to order by, defaults to ASC"
    direction: OrderDirection = ASC
    "The field to order by, defaults to ID"
    field: IMSPermissionOrderField = ID
}

"Filter used to filter IMSProject"
input IMSProjectFilterInput {
    "Connects all subformulas via and"
    and: [IMSProjectFilterInput!]
    "Filter by description"
    description: StringFilterInput
    "Filter by id"
    id: IDFilterInput
    "Filters for nodes where the related node match this filter"
    ims: IMSFilterInput
    "Filter by imsIssues"
    imsIssues: IMSIssueListFilterInput
    "Filter by name"
    name: StringFilterInput
    "Negates the subformula"
    not: IMSProjectFilterInput
    "Connects all subformulas via or"
    or: [IMSProjectFilterInput!]
    "Filter by syncOthersAllowedBy"
    syncOthersAllowedBy: GropiusUserListFilterInput
    "Filter by syncSelfAllowedBy"
    syncSelfAllowedBy: GropiusUserListFilterInput
    "Filters for nodes where the related node match this filter"
    template: IMSProjectTemplateFilterInput
    "Filter for templated fields with matching key and values. Entries are joined by AND"
    templatedFields: [JSONFieldInput]
    "Filters for nodes where the related node match this filter"
    trackable: TrackableFilterInput
}

"Used to filter by a connection-based property. Fields are joined by AND"
input IMSProjectListFilterInput {
    "Filters for nodes where all of the related nodes match this filter"
    all: IMSProjectFilterInput
    "Filters for nodes where any of the related nodes match this filter"
    any: IMSProjectFilterInput
    "Filters for nodes where none of the related nodes match this filter"
    none: IMSProjectFilterInput
}

"Defines the order of a IMSProject list"
input IMSProjectOrder {
    "The direction to order by, defaults to ASC"
    direction: OrderDirection = ASC
    "The field to order by, defaults to ID"
    field: IMSProjectOrderField = ID
}

"Filter used to filter IMSProjectTemplate"
input IMSProjectTemplateFilterInput {
    "Connects all subformulas via and"
    and: [IMSProjectTemplateFilterInput!]
    "Filter by description"
    description: StringFilterInput
    "Filter by id"
    id: IDFilterInput
    "Filter by name"
    name: StringFilterInput
    "Negates the subformula"
    not: IMSProjectTemplateFilterInput
    "Connects all subformulas via or"
    or: [IMSProjectTemplateFilterInput!]
}

"Filter used to filter IMSTemplate"
input IMSTemplateFilterInput {
    "Connects all subformulas via and"
    and: [IMSTemplateFilterInput!]
    "Filter by description"
    description: StringFilterInput
    "Filter by extendedBy"
    extendedBy: IMSTemplateListFilterInput
    "Filter by extends"
    extends: IMSTemplateListFilterInput
    "Filter by id"
    id: IDFilterInput
    "Filter by isDeprecated"
    isDeprecated: BooleanFilterInput
    "Filter by name"
    name: StringFilterInput
    "Negates the subformula"
    not: IMSTemplateFilterInput
    "Connects all subformulas via or"
    or: [IMSTemplateFilterInput!]
}

"Used to filter by a connection-based property. Fields are joined by AND"
input IMSTemplateListFilterInput {
    "Filters for nodes where all of the related nodes match this filter"
    all: IMSTemplateFilterInput
    "Filters for nodes where any of the related nodes match this filter"
    any: IMSTemplateFilterInput
    "Filters for nodes where none of the related nodes match this filter"
    none: IMSTemplateFilterInput
}

"Defines the order of a IMSTemplate list"
input IMSTemplateOrder {
    "The direction to order by, defaults to ASC"
    direction: OrderDirection = ASC
    "The field to order by, defaults to ID"
    field: IMSTemplateOrderField = ID
}

"Filter used to filter IMSUser"
input IMSUserFilterInput {
    "Connects all subformulas via and"
    and: [IMSUserFilterInput!]
    "Filter by assignments"
    assignments: AssignmentListFilterInput
    "Filter by createdNodes"
    createdNodes: AuditedNodeListFilterInput
    "Filter by displayName"
    displayName: StringFilterInput
    "Filter by email"
    email: NullableStringFilterInput
    "Filters for nodes where the related node match this filter"
    gropiusUser: GropiusUserFilterInput
    "Filter by id"
    id: IDFilterInput
    "Filters for nodes where the related node match this filter"
    ims: IMSFilterInput
    "Negates the subformula"
    not: IMSUserFilterInput
    "Connects all subformulas via or"
    or: [IMSUserFilterInput!]
    "Filter by participatedIssues"
    participatedIssues: IssueListFilterInput
    "Filters for nodes where the related node match this filter"
    template: IMSUserTemplateFilterInput
    "Filter for templated fields with matching key and values. Entries are joined by AND"
    templatedFields: [JSONFieldInput]
    "Filter by username"
    username: NullableStringFilterInput
}

"Used to filter by a connection-based property. Fields are joined by AND"
input IMSUserListFilterInput {
    "Filters for nodes where all of the related nodes match this filter"
    all: IMSUserFilterInput
    "Filters for nodes where any of the related nodes match this filter"
    any: IMSUserFilterInput
    "Filters for nodes where none of the related nodes match this filter"
    none: IMSUserFilterInput
}

"Defines the order of a IMSUser list"
input IMSUserOrder {
    "The direction to order by, defaults to ASC"
    direction: OrderDirection = ASC
    "The field to order by, defaults to ID"
    field: IMSUserOrderField = ID
}

"Filter used to filter IMSUserTemplate"
input IMSUserTemplateFilterInput {
    "Connects all subformulas via and"
    and: [IMSUserTemplateFilterInput!]
    "Filter by description"
    description: StringFilterInput
    "Filter by id"
    id: IDFilterInput
    "Filter by name"
    name: StringFilterInput
    "Negates the subformula"
    not: IMSUserTemplateFilterInput
    "Connects all subformulas via or"
    or: [IMSUserTemplateFilterInput!]
}

"Filter which can be used to filter for Nodes with a specific Int field"
input IntFilterInput {
    "Matches values which are equal to the provided value"
    eq: Int
    "Matches values which are greater than the provided value"
    gt: Int
    "Matches values which are greater than or equal to the provided value"
    gte: Int
    "Matches values which are equal to any of the provided values"
    in: [Int!]
    "Matches values which are lesser than the provided value"
    lt: Int
    "Matches values which are lesser than or equal to the provided value"
    lte: Int
}

"Filter used to filter InterfaceDefinition"
input InterfaceDefinitionFilterInput {
    "Connects all subformulas via and"
    and: [InterfaceDefinitionFilterInput!]
    "Filters for nodes where the related node match this filter"
    componentVersion: ComponentVersionFilterInput
    "Filter by id"
    id: IDFilterInput
    "Filters for nodes where the related node match this filter"
    interfaceSpecificationVersion: InterfaceSpecificationVersionFilterInput
    "Filter by invisibleDerivedBy"
    invisibleDerivedBy: RelationListFilterInput
    "Filter by invisibleSelfDefined"
    invisibleSelfDefined: BooleanFilterInput
    "Negates the subformula"
    not: InterfaceDefinitionFilterInput
    "Connects all subformulas via or"
    or: [InterfaceDefinitionFilterInput!]
    "Filters for nodes where the related node match this filter"
    template: InterfaceDefinitionTemplateFilterInput
    "Filter for templated fields with matching key and values. Entries are joined by AND"
    templatedFields: [JSONFieldInput]
    "Filter by visibleDerivedBy"
    visibleDerivedBy: RelationListFilterInput
    "Filters for nodes where the related node match this filter"
    visibleInterface: InterfaceFilterInput
    "Filter by visibleSelfDefined"
    visibleSelfDefined: BooleanFilterInput
}

"Used to filter by a connection-based property. Fields are joined by AND"
input InterfaceDefinitionListFilterInput {
    "Filters for nodes where all of the related nodes match this filter"
    all: InterfaceDefinitionFilterInput
    "Filters for nodes where any of the related nodes match this filter"
    any: InterfaceDefinitionFilterInput
    "Filters for nodes where none of the related nodes match this filter"
    none: InterfaceDefinitionFilterInput
}

"Defines the order of a InterfaceDefinition list"
input InterfaceDefinitionOrder {
    "The direction to order by, defaults to ASC"
    direction: OrderDirection = ASC
    "The field to order by, defaults to ID"
    field: InterfaceDefinitionOrderField = ID
}

"Filter used to filter InterfaceDefinitionTemplate"
input InterfaceDefinitionTemplateFilterInput {
    "Connects all subformulas via and"
    and: [InterfaceDefinitionTemplateFilterInput!]
    "Filter by description"
    description: StringFilterInput
    "Filter by id"
    id: IDFilterInput
    "Filter by name"
    name: StringFilterInput
    "Negates the subformula"
    not: InterfaceDefinitionTemplateFilterInput
    "Connects all subformulas via or"
    or: [InterfaceDefinitionTemplateFilterInput!]
}

"Filter used to filter Interface"
input InterfaceFilterInput {
    "Filter by affectingIssues"
    affectingIssues: IssueListFilterInput
    "Filter by aggregatedIssues"
    aggregatedIssues: AggregatedIssueListFilterInput
    "Connects all subformulas via and"
    and: [InterfaceFilterInput!]
    "Filter by description"
    description: StringFilterInput
    "Filter by id"
    id: IDFilterInput
    "Filter by incomingRelations"
    incomingRelations: RelationListFilterInput
    "Filters for nodes where the related node match this filter"
    interfaceDefinition: InterfaceDefinitionFilterInput
    "Filter by intraComponentDependencyParticipants"
    intraComponentDependencyParticipants: IntraComponentDependencyParticipantListFilterInput
    "Filter by name"
    name: StringFilterInput
    "Negates the subformula"
    not: InterfaceFilterInput
    "Connects all subformulas via or"
    or: [InterfaceFilterInput!]
    "Filter by outgoingRelations"
    outgoingRelations: RelationListFilterInput
    "Filters for RelationPartners which are part of a Project's component graph"
    partOfProject: ID
    "Filters for AffectedByIssues which are related to a Trackable"
    relatedTo: ID
    "Filters for nodes where the related node match this filter"
    template: InterfaceTemplateFilterInput
    "Filter for templated fields with matching key and values. Entries are joined by AND"
    templatedFields: [JSONFieldInput]
}

"Defines the order of a Interface list"
input InterfaceOrder {
    "The direction to order by, defaults to ASC"
    direction: OrderDirection = ASC
    "The field to order by, defaults to ID"
    field: InterfaceOrderField = ID
}

"Filter used to filter InterfacePart"
input InterfacePartFilterInput {
    "Filter by affectingIssues"
    affectingIssues: IssueListFilterInput
    "Connects all subformulas via and"
    and: [InterfacePartFilterInput!]
    "Filter by description"
    description: StringFilterInput
    "Filter by id"
    id: IDFilterInput
    "Filter by includingIncomingRelations"
    includingIncomingRelations: RelationListFilterInput
    "Filter by includingIntraComponentDependencyParticipants"
    includingIntraComponentDependencyParticipants: IntraComponentDependencyParticipantListFilterInput
    "Filter by includingOutgoingRelations"
    includingOutgoingRelations: RelationListFilterInput
    "Filter by name"
    name: StringFilterInput
    "Negates the subformula"
    not: InterfacePartFilterInput
    "Connects all subformulas via or"
    or: [InterfacePartFilterInput!]
    "Filters for nodes where the related node match this filter"
    partOf: InterfaceSpecificationVersionFilterInput
    "Filters for AffectedByIssues which are related to a Trackable"
    relatedTo: ID
    "Filters for nodes where the related node match this filter"
    template: InterfacePartTemplateFilterInput
    "Filter for templated fields with matching key and values. Entries are joined by AND"
    templatedFields: [JSONFieldInput]
}

"Input to create an InterfacePart"
input InterfacePartInput {
    "The description of the NamedNode"
    description: String!
    "The name of the NamedNode, must not be blank"
    name: String!
    "Initial values for all templatedFields"
    templatedFields: [JSONFieldInput!]!
}

"Used to filter by a connection-based property. Fields are joined by AND"
input InterfacePartListFilterInput {
    "Filters for nodes where all of the related nodes match this filter"
    all: InterfacePartFilterInput
    "Filters for nodes where any of the related nodes match this filter"
    any: InterfacePartFilterInput
    "Filters for nodes where none of the related nodes match this filter"
    none: InterfacePartFilterInput
}

"Defines the order of a InterfacePart list"
input InterfacePartOrder {
    "The direction to order by, defaults to ASC"
    direction: OrderDirection = ASC
    "The field to order by, defaults to ID"
    field: InterfacePartOrderField = ID
}

"Filter used to filter InterfacePartTemplate"
input InterfacePartTemplateFilterInput {
    "Connects all subformulas via and"
    and: [InterfacePartTemplateFilterInput!]
    "Filter by description"
    description: StringFilterInput
    "Filter by id"
    id: IDFilterInput
    "Filter by name"
    name: StringFilterInput
    "Negates the subformula"
    not: InterfacePartTemplateFilterInput
    "Connects all subformulas via or"
    or: [InterfacePartTemplateFilterInput!]
}

"Filter used to filter InterfaceSpecificationDerivationCondition"
input InterfaceSpecificationDerivationConditionFilterInput {
    "Connects all subformulas via and"
    and: [InterfaceSpecificationDerivationConditionFilterInput!]
    "Filter by derivableInterfaceSpecifications"
    derivableInterfaceSpecifications: InterfaceSpecificationTemplateListFilterInput
    "Filter by derivesInvisibleDerived"
    derivesInvisibleDerived: BooleanFilterInput
    "Filter by derivesInvisibleSelfDefined"
    derivesInvisibleSelfDefined: BooleanFilterInput
    "Filter by derivesVisibleDerived"
    derivesVisibleDerived: BooleanFilterInput
    "Filter by derivesVisibleSelfDefined"
    derivesVisibleSelfDefined: BooleanFilterInput
    "Filter by id"
    id: IDFilterInput
    "Filter by isInvisibleDerived"
    isInvisibleDerived: BooleanFilterInput
    "Filter by isVisibleDerived"
    isVisibleDerived: BooleanFilterInput
    "Negates the subformula"
    not: InterfaceSpecificationDerivationConditionFilterInput
    "Connects all subformulas via or"
    or: [InterfaceSpecificationDerivationConditionFilterInput!]
    "Filters for nodes where the related node match this filter"
    partOf: RelationConditionFilterInput
}

"Input to create a InterfaceSpecificationDerivationCondition"
input InterfaceSpecificationDerivationConditionInput {
    "The ids of the InterfaceSpecifications this can derive"
    derivableInterfaceSpecifications: [ID!]!
    "If true, invisible derived InterfaceSpecifications are derived"
    derivesInvisibleDerived: Boolean!
    "If true, invisible self-defined InterfaceSpecifications are derived"
    derivesInvisibleSelfDefined: Boolean!
    "If true, visible derived InterfaceSpecifications are derived"
    derivesVisibleDerived: Boolean!
    "If true, visible self-defined InterfaceSpecifications are derived"
    derivesVisibleSelfDefined: Boolean!
    "If true InterfaceSpecifications are invisible derived"
    isInvisibleDerived: Boolean!
    "If true InterfaceSpecifications are visible derived"
    isVisibleDerived: Boolean!
}

"Used to filter by a connection-based property. Fields are joined by AND"
input InterfaceSpecificationDerivationConditionListFilterInput {
    "Filters for nodes where all of the related nodes match this filter"
    all: InterfaceSpecificationDerivationConditionFilterInput
    "Filters for nodes where any of the related nodes match this filter"
    any: InterfaceSpecificationDerivationConditionFilterInput
    "Filters for nodes where none of the related nodes match this filter"
    none: InterfaceSpecificationDerivationConditionFilterInput
}

"Defines the order of a InterfaceSpecificationDerivationCondition list"
input InterfaceSpecificationDerivationConditionOrder {
    "The direction to order by, defaults to ASC"
    direction: OrderDirection = ASC
    "The field to order by, defaults to ID"
    field: InterfaceSpecificationDerivationConditionOrderField = ID
}

"Filter used to filter InterfaceSpecification"
input InterfaceSpecificationFilterInput {
    "Filter by affectingIssues"
    affectingIssues: IssueListFilterInput
    "Connects all subformulas via and"
    and: [InterfaceSpecificationFilterInput!]
    "Filters for nodes where the related node match this filter"
    component: ComponentFilterInput
    "Filter by description"
    description: StringFilterInput
    "Filter by id"
    id: IDFilterInput
    "Filter by name"
    name: StringFilterInput
    "Negates the subformula"
    not: InterfaceSpecificationFilterInput
    "Connects all subformulas via or"
    or: [InterfaceSpecificationFilterInput!]
    "Filters for AffectedByIssues which are related to a Trackable"
    relatedTo: ID
    "Filters for nodes where the related node match this filter"
    template: InterfaceSpecificationTemplateFilterInput
    "Filter for templated fields with matching key and values. Entries are joined by AND"
    templatedFields: [JSONFieldInput]
    "Filter by versions"
    versions: InterfaceSpecificationVersionListFilterInput
}

"Input to create an InterfaceSpecification"
input InterfaceSpecificationInput {
    "The description of the NamedNode"
    description: String!
    "The name of the NamedNode, must not be blank"
    name: String!
    "The template of the created InterfaceSpecification"
    template: ID!
    "Initial values for all templatedFields"
    templatedFields: [JSONFieldInput!]!
    "Initial versions of the InterfaceSpecification"
    versions: [InterfaceSpecificationVersionInput!]
}

"Used to filter by a connection-based property. Fields are joined by AND"
input InterfaceSpecificationListFilterInput {
    "Filters for nodes where all of the related nodes match this filter"
    all: InterfaceSpecificationFilterInput
    "Filters for nodes where any of the related nodes match this filter"
    any: InterfaceSpecificationFilterInput
    "Filters for nodes where none of the related nodes match this filter"
    none: InterfaceSpecificationFilterInput
}

"Defines the order of a InterfaceSpecification list"
input InterfaceSpecificationOrder {
    "The direction to order by, defaults to ASC"
    direction: OrderDirection = ASC
    "The field to order by, defaults to ID"
    field: InterfaceSpecificationOrderField = ID
}

"Filter used to filter InterfaceSpecificationTemplate"
input InterfaceSpecificationTemplateFilterInput {
    "Connects all subformulas via and"
    and: [InterfaceSpecificationTemplateFilterInput!]
    "Filter by canBeInvisibleOnComponents"
    canBeInvisibleOnComponents: ComponentTemplateListFilterInput
    "Filter by canBeVisibleOnComponents"
    canBeVisibleOnComponents: ComponentTemplateListFilterInput
    "Filter by derivableBy"
    derivableBy: InterfaceSpecificationDerivationConditionListFilterInput
    "Filter by description"
    description: StringFilterInput
    "Filter by extendedBy"
    extendedBy: InterfaceSpecificationTemplateListFilterInput
    "Filter by extends"
    extends: InterfaceSpecificationTemplateListFilterInput
    "Filter by id"
    id: IDFilterInput
    "Filter by isDeprecated"
    isDeprecated: BooleanFilterInput
    "Filter by name"
    name: StringFilterInput
    "Negates the subformula"
    not: InterfaceSpecificationTemplateFilterInput
    "Connects all subformulas via or"
    or: [InterfaceSpecificationTemplateFilterInput!]
    "Filter by possibleEndOfRelations"
    possibleEndOfRelations: RelationConditionListFilterInput
    "Filter by possibleStartOfRelations"
    possibleStartOfRelations: RelationConditionListFilterInput
}

"Used to filter by a connection-based property. Fields are joined by AND"
input InterfaceSpecificationTemplateListFilterInput {
    "Filters for nodes where all of the related nodes match this filter"
    all: InterfaceSpecificationTemplateFilterInput
    "Filters for nodes where any of the related nodes match this filter"
    any: InterfaceSpecificationTemplateFilterInput
    "Filters for nodes where none of the related nodes match this filter"
    none: InterfaceSpecificationTemplateFilterInput
}

"Defines the order of a InterfaceSpecificationTemplate list"
input InterfaceSpecificationTemplateOrder {
    "The direction to order by, defaults to ASC"
    direction: OrderDirection = ASC
    "The field to order by, defaults to ID"
    field: InterfaceSpecificationTemplateOrderField = ID
}

"Filter used to filter InterfaceSpecificationVersion"
input InterfaceSpecificationVersionFilterInput {
    "Filter by affectingIssues"
    affectingIssues: IssueListFilterInput
    "Connects all subformulas via and"
    and: [InterfaceSpecificationVersionFilterInput!]
    "Filter by description"
    description: StringFilterInput
    "Filter by id"
    id: IDFilterInput
    "Filter by interfaceDefinitions"
    interfaceDefinitions: InterfaceDefinitionListFilterInput
    "Filters for nodes where the related node match this filter"
    interfaceSpecification: InterfaceSpecificationFilterInput
    "Filter by name"
    name: StringFilterInput
    "Negates the subformula"
    not: InterfaceSpecificationVersionFilterInput
    "Connects all subformulas via or"
    or: [InterfaceSpecificationVersionFilterInput!]
    "Filter by parts"
    parts: InterfacePartListFilterInput
    "Filters for AffectedByIssues which are related to a Trackable"
    relatedTo: ID
    "Filters for nodes where the related node match this filter"
    template: InterfaceSpecificationVersionTemplateFilterInput
    "Filter for templated fields with matching key and values. Entries are joined by AND"
    templatedFields: [JSONFieldInput]
    "Filter by version"
    version: StringFilterInput
}

"Input to create an InterfaceSpecificationVersion"
input InterfaceSpecificationVersionInput {
    "The description of the NamedNode"
    description: String!
    "The name of the NamedNode, must not be blank"
    name: String!
    "Initial InterfaceParts"
    parts: [InterfacePartInput!]
    "Initial values for all templatedFields"
    templatedFields: [JSONFieldInput!]!
    "The version of the created InterfaceSpecificationVersion"
    version: String!
}

"Used to filter by a connection-based property. Fields are joined by AND"
input InterfaceSpecificationVersionListFilterInput {
    "Filters for nodes where all of the related nodes match this filter"
    all: InterfaceSpecificationVersionFilterInput
    "Filters for nodes where any of the related nodes match this filter"
    any: InterfaceSpecificationVersionFilterInput
    "Filters for nodes where none of the related nodes match this filter"
    none: InterfaceSpecificationVersionFilterInput
}

"Defines the order of a InterfaceSpecificationVersion list"
input InterfaceSpecificationVersionOrder {
    "The direction to order by, defaults to ASC"
    direction: OrderDirection = ASC
    "The field to order by, defaults to ID"
    field: InterfaceSpecificationVersionOrderField = ID
}

"Filter used to filter InterfaceSpecificationVersionTemplate"
input InterfaceSpecificationVersionTemplateFilterInput {
    "Connects all subformulas via and"
    and: [InterfaceSpecificationVersionTemplateFilterInput!]
    "Filter by description"
    description: StringFilterInput
    "Filter by id"
    id: IDFilterInput
    "Filter by name"
    name: StringFilterInput
    "Negates the subformula"
    not: InterfaceSpecificationVersionTemplateFilterInput
    "Connects all subformulas via or"
    or: [InterfaceSpecificationVersionTemplateFilterInput!]
}

"Filter used to filter InterfaceTemplate"
input InterfaceTemplateFilterInput {
    "Connects all subformulas via and"
    and: [InterfaceTemplateFilterInput!]
    "Filter by description"
    description: StringFilterInput
    "Filter by id"
    id: IDFilterInput
    "Filter by name"
    name: StringFilterInput
    "Negates the subformula"
    not: InterfaceTemplateFilterInput
    "Connects all subformulas via or"
    or: [InterfaceTemplateFilterInput!]
}

"Filter used to filter IntraComponentDependencyParticipant"
input IntraComponentDependencyParticipantFilterInput {
    "Connects all subformulas via and"
    and: [IntraComponentDependencyParticipantFilterInput!]
    "Filter by id"
    id: IDFilterInput
    "Filter by includedParts"
    includedParts: InterfacePartListFilterInput
    "Filters for nodes where the related node match this filter"
    interface: InterfaceFilterInput
    "Negates the subformula"
    not: IntraComponentDependencyParticipantFilterInput
    "Connects all subformulas via or"
    or: [IntraComponentDependencyParticipantFilterInput!]
    "Filters for nodes where the related node match this filter"
    usedAsIncomingAt: IntraComponentDependencySpecificationFilterInput
    "Filters for nodes where the related node match this filter"
    usedAsOutgoingAt: IntraComponentDependencySpecificationFilterInput
}

"Input to create a IntraComponentDependencyParticipant"
input IntraComponentDependencyParticipantInput {
    "The ids of includedParts, must all be activeParts on the InterfaceSpecificationVersion associated with `interface`"
    includedParts: [ID!]
    """
    The id of the Interface, must be an Interface on the ComponentVersion the
    IntraComponentDependencySpecification this is part of refers to

    """
    interface: ID!
}

"Used to filter by a connection-based property. Fields are joined by AND"
input IntraComponentDependencyParticipantListFilterInput {
    "Filters for nodes where all of the related nodes match this filter"
    all: IntraComponentDependencyParticipantFilterInput
    "Filters for nodes where any of the related nodes match this filter"
    any: IntraComponentDependencyParticipantFilterInput
    "Filters for nodes where none of the related nodes match this filter"
    none: IntraComponentDependencyParticipantFilterInput
}

"Defines the order of a IntraComponentDependencyParticipant list"
input IntraComponentDependencyParticipantOrder {
    "The direction to order by, defaults to ASC"
    direction: OrderDirection = ASC
    "The field to order by, defaults to ID"
    field: IntraComponentDependencyParticipantOrderField = ID
}

"Filter used to filter IntraComponentDependencySpecification"
input IntraComponentDependencySpecificationFilterInput {
    "Connects all subformulas via and"
    and: [IntraComponentDependencySpecificationFilterInput!]
    "Filters for nodes where the related node match this filter"
    componentVersion: ComponentVersionFilterInput
    "Filter by description"
    description: StringFilterInput
    "Filter by id"
    id: IDFilterInput
    "Filter by incomingParticipants"
    incomingParticipants: IntraComponentDependencyParticipantListFilterInput
    "Filter by name"
    name: StringFilterInput
    "Negates the subformula"
    not: IntraComponentDependencySpecificationFilterInput
    "Connects all subformulas via or"
    or: [IntraComponentDependencySpecificationFilterInput!]
    "Filter by outgoingParticipants"
    outgoingParticipants: IntraComponentDependencyParticipantListFilterInput
}

"Used to filter by a connection-based property. Fields are joined by AND"
input IntraComponentDependencySpecificationListFilterInput {
    "Filters for nodes where all of the related nodes match this filter"
    all: IntraComponentDependencySpecificationFilterInput
    "Filters for nodes where any of the related nodes match this filter"
    any: IntraComponentDependencySpecificationFilterInput
    "Filters for nodes where none of the related nodes match this filter"
    none: IntraComponentDependencySpecificationFilterInput
}

"Defines the order of a IntraComponentDependencySpecification list"
input IntraComponentDependencySpecificationOrder {
    "The direction to order by, defaults to ASC"
    direction: OrderDirection = ASC
    "The field to order by, defaults to ID"
    field: IntraComponentDependencySpecificationOrderField = ID
}

"Filter used to filter IssueComment"
input IssueCommentFilterInput {
    "Connects all subformulas via and"
    and: [IssueCommentFilterInput!]
    "Filter by answeredBy"
    answeredBy: IssueCommentListFilterInput
    "Filters for nodes where the related node match this filter"
    answers: CommentFilterInput
    "Filter by bodyLastEditedAt"
    bodyLastEditedAt: DateTimeFilterInput
    "Filters for nodes where the related node match this filter"
    bodyLastEditedBy: UserFilterInput
    "Filter by createdAt"
    createdAt: DateTimeFilterInput
    "Filters for nodes where the related node match this filter"
    createdBy: UserFilterInput
    "Filter by id"
    id: IDFilterInput
    "Filter by isCommentDeleted"
    isCommentDeleted: BooleanFilterInput
    "Filters for nodes where the related node match this filter"
    issue: IssueFilterInput
    "Filter by lastModifiedAt"
    lastModifiedAt: DateTimeFilterInput
    "Filters for nodes where the related node match this filter"
    lastModifiedBy: UserFilterInput
    "Negates the subformula"
    not: IssueCommentFilterInput
    "Connects all subformulas via or"
    or: [IssueCommentFilterInput!]
    "Filters for nodes where the related node match this filter"
    parentItem: ParentTimelineItemFilterInput
    "Filter by referencedArtefacts"
    referencedArtefacts: ArtefactListFilterInput
    "Filter for specific timeline items. Entries are joined by OR"
    timelineItemTypes: [TimelineItemType!]
}

"Used to filter by a connection-based property. Fields are joined by AND"
input IssueCommentListFilterInput {
    "Filters for nodes where all of the related nodes match this filter"
    all: IssueCommentFilterInput
    "Filters for nodes where any of the related nodes match this filter"
    any: IssueCommentFilterInput
    "Filters for nodes where none of the related nodes match this filter"
    none: IssueCommentFilterInput
}

"Defines the order of a IssueComment list"
input IssueCommentOrder {
    "The direction to order by, defaults to ASC"
    direction: OrderDirection = ASC
    "The field to order by, defaults to ID"
    field: IssueCommentOrderField = ID
}

"Filter used to filter Issue"
input IssueFilterInput {
    "Filter by affects"
    affects: AffectedByIssueListFilterInput
    "Filter by aggregatedBy"
    aggregatedBy: AggregatedIssueListFilterInput
    "Connects all subformulas via and"
    and: [IssueFilterInput!]
    "Filter by artefacts"
    artefacts: ArtefactListFilterInput
    "Filter by assignments"
    assignments: AssignmentListFilterInput
    "Filters for nodes where the related node match this filter"
    body: BodyFilterInput
    "Filter by createdAt"
    createdAt: DateTimeFilterInput
    "Filters for nodes where the related node match this filter"
    createdBy: UserFilterInput
    "Filter by dueDate"
    dueDate: NullableDateTimeFilterInput
    "Filter by estimatedTime"
    estimatedTime: NullableDurationFilterInputFilterInput
    "Filter by id"
    id: IDFilterInput
    "Filter by imsIssues"
    imsIssues: IMSIssueListFilterInput
    "Filter by incomingRelations"
    incomingRelations: IssueRelationListFilterInput
    "Filter by issueComments"
    issueComments: IssueCommentListFilterInput
    "Filter by labels"
    labels: LabelListFilterInput
    "Filter by lastModifiedAt"
    lastModifiedAt: DateTimeFilterInput
    "Filters for nodes where the related node match this filter"
    lastModifiedBy: UserFilterInput
    "Filter by lastUpdatedAt"
    lastUpdatedAt: DateTimeFilterInput
    "Negates the subformula"
    not: IssueFilterInput
    "Connects all subformulas via or"
    or: [IssueFilterInput!]
    "Filter by outgoingRelations"
    outgoingRelations: IssueRelationListFilterInput
    "Filter by participants"
    participants: UserListFilterInput
    "Filter by pinnedOn"
    pinnedOn: TrackableListFilterInput
    "Filters for nodes where the related node match this filter"
    priority: IssuePriorityFilterInput
    "Filter by spentTime"
    spentTime: NullableDurationFilterInputFilterInput
    "Filter by startDate"
    startDate: NullableDateTimeFilterInput
    "Filters for nodes where the related node match this filter"
    state: IssueStateFilterInput
    "Filters for nodes where the related node match this filter"
    template: IssueTemplateFilterInput
    "Filter for templated fields with matching key and values. Entries are joined by AND"
    templatedFields: [JSONFieldInput]
    "Filter by timelineItems"
    timelineItems: TimelineItemListFilterInput
    "Filter by title"
    title: StringFilterInput
    "Filter by trackables"
    trackables: TrackableListFilterInput
    "Filters for nodes where the related node match this filter"
    type: IssueTypeFilterInput
}

"Used to filter by a connection-based property. Fields are joined by AND"
input IssueListFilterInput {
    "Filters for nodes where all of the related nodes match this filter"
    all: IssueFilterInput
    "Filters for nodes where any of the related nodes match this filter"
    any: IssueFilterInput
    "Filters for nodes where none of the related nodes match this filter"
    none: IssueFilterInput
}

"Defines the order of a Issue list"
input IssueOrder {
    "The direction to order by, defaults to ASC"
    direction: OrderDirection = ASC
    "The field to order by, defaults to ID"
    field: IssueOrderField = ID
}

"Filter used to filter IssuePriority"
input IssuePriorityFilterInput {
    "Connects all subformulas via and"
    and: [IssuePriorityFilterInput!]
    "Filter by description"
    description: StringFilterInput
    "Filter by id"
    id: IDFilterInput
    "Filter by name"
    name: StringFilterInput
    "Negates the subformula"
    not: IssuePriorityFilterInput
    "Connects all subformulas via or"
    or: [IssuePriorityFilterInput!]
    "Filter by partOf"
    partOf: IssueTemplateListFilterInput
    "Filter by prioritizedIssues"
    prioritizedIssues: IssueListFilterInput
    "Filter by value"
    value: FloatFilterInput
}

"Input to create an IssuePriority"
input IssuePriorityInput {
    "The description of the NamedNode"
    description: String!
    "The name of the NamedNode, must not be blank"
    name: String!
    "The value of the created IssuePriority, used to compare/order different IssuePriorities"
    value: Float!
}

"Used to filter by a connection-based property. Fields are joined by AND"
input IssuePriorityListFilterInput {
    "Filters for nodes where all of the related nodes match this filter"
    all: IssuePriorityFilterInput
    "Filters for nodes where any of the related nodes match this filter"
    any: IssuePriorityFilterInput
    "Filters for nodes where none of the related nodes match this filter"
    none: IssuePriorityFilterInput
}

"Defines the order of a IssuePriority list"
input IssuePriorityOrder {
    "The direction to order by, defaults to ASC"
    direction: OrderDirection = ASC
    "The field to order by, defaults to ID"
    field: IssuePriorityOrderField = ID
}

"Filter used to filter IssueRelation"
input IssueRelationFilterInput {
    "Filter by aggregatedBy"
    aggregatedBy: AggregatedIssueRelationListFilterInput
    "Connects all subformulas via and"
    and: [IssueRelationFilterInput!]
    "Filter by createdAt"
    createdAt: DateTimeFilterInput
    "Filters for nodes where the related node match this filter"
    createdBy: UserFilterInput
    "Filter by id"
    id: IDFilterInput
    "Filters for nodes where the related node match this filter"
    issue: IssueFilterInput
    "Filter by lastModifiedAt"
    lastModifiedAt: DateTimeFilterInput
    "Filters for nodes where the related node match this filter"
    lastModifiedBy: UserFilterInput
    "Negates the subformula"
    not: IssueRelationFilterInput
    "Connects all subformulas via or"
    or: [IssueRelationFilterInput!]
    "Filters for nodes where the related node match this filter"
    parentItem: ParentTimelineItemFilterInput
    "Filters for nodes where the related node match this filter"
    relatedIssue: IssueFilterInput
    "Filter for specific timeline items. Entries are joined by OR"
    timelineItemTypes: [TimelineItemType!]
    "Filters for nodes where the related node match this filter"
    type: IssueRelationTypeFilterInput
}

"Used to filter by a connection-based property. Fields are joined by AND"
input IssueRelationListFilterInput {
    "Filters for nodes where all of the related nodes match this filter"
    all: IssueRelationFilterInput
    "Filters for nodes where any of the related nodes match this filter"
    any: IssueRelationFilterInput
    "Filters for nodes where none of the related nodes match this filter"
    none: IssueRelationFilterInput
}

"Defines the order of a IssueRelation list"
input IssueRelationOrder {
    "The direction to order by, defaults to ASC"
    direction: OrderDirection = ASC
    "The field to order by, defaults to ID"
    field: IssueRelationOrderField = ID
}

"Filter used to filter IssueRelationType"
input IssueRelationTypeFilterInput {
    "Connects all subformulas via and"
    and: [IssueRelationTypeFilterInput!]
    "Filter by description"
    description: StringFilterInput
    "Filter by id"
    id: IDFilterInput
    "Filter by inverseName"
    inverseName: StringFilterInput
    "Filter by name"
    name: StringFilterInput
    "Negates the subformula"
    not: IssueRelationTypeFilterInput
    "Connects all subformulas via or"
    or: [IssueRelationTypeFilterInput!]
    "Filter by partOf"
    partOf: IssueTemplateListFilterInput
    "Filter by relationsWithType"
    relationsWithType: IssueRelationListFilterInput
}

"Input to create an IssueRelationType"
input IssueRelationTypeInput {
    "The description of the NamedNode"
    description: String!
    "The inverse name of the IssueRelationType, must not be blank"
    inverseName: String!
    "The name of the NamedNode, must not be blank"
    name: String!
}

"Used to filter by a connection-based property. Fields are joined by AND"
input IssueRelationTypeListFilterInput {
    "Filters for nodes where all of the related nodes match this filter"
    all: IssueRelationTypeFilterInput
    "Filters for nodes where any of the related nodes match this filter"
    any: IssueRelationTypeFilterInput
    "Filters for nodes where none of the related nodes match this filter"
    none: IssueRelationTypeFilterInput
}

"Defines the order of a IssueRelationType list"
input IssueRelationTypeOrder {
    "The direction to order by, defaults to ASC"
    direction: OrderDirection = ASC
    "The field to order by, defaults to ID"
    field: IssueRelationTypeOrderField = ID
}

"Filter used to filter IssueState"
input IssueStateFilterInput {
    "Connects all subformulas via and"
    and: [IssueStateFilterInput!]
    "Filter by description"
    description: StringFilterInput
    "Filter by id"
    id: IDFilterInput
    "Filter by isOpen"
    isOpen: BooleanFilterInput
    "Filter by issuesWithState"
    issuesWithState: IssueListFilterInput
    "Filter by name"
    name: StringFilterInput
    "Negates the subformula"
    not: IssueStateFilterInput
    "Connects all subformulas via or"
    or: [IssueStateFilterInput!]
    "Filter by partOf"
    partOf: IssueTemplateListFilterInput
}

"Input to create an IssueState"
input IssueStateInput {
    "The description of the NamedNode"
    description: String!
    "The value for the isOpen field of the created IssueState"
    isOpen: Boolean!
    "The name of the NamedNode, must not be blank"
    name: String!
}

"Used to filter by a connection-based property. Fields are joined by AND"
input IssueStateListFilterInput {
    "Filters for nodes where all of the related nodes match this filter"
    all: IssueStateFilterInput
    "Filters for nodes where any of the related nodes match this filter"
    any: IssueStateFilterInput
    "Filters for nodes where none of the related nodes match this filter"
    none: IssueStateFilterInput
}

"Defines the order of a IssueState list"
input IssueStateOrder {
    "The direction to order by, defaults to ASC"
    direction: OrderDirection = ASC
    "The field to order by, defaults to ID"
    field: IssueStateOrderField = ID
}

"Filter used to filter IssueTemplate"
input IssueTemplateFilterInput {
    "Connects all subformulas via and"
    and: [IssueTemplateFilterInput!]
    "Filter by assignmentTypes"
    assignmentTypes: AssignmentTypeListFilterInput
    "Filter by description"
    description: StringFilterInput
    "Filter by extendedBy"
    extendedBy: IssueTemplateListFilterInput
    "Filter by extends"
    extends: IssueTemplateListFilterInput
    "Filter by id"
    id: IDFilterInput
    "Filter by isDeprecated"
    isDeprecated: BooleanFilterInput
    "Filter by issuePriorities"
    issuePriorities: IssuePriorityListFilterInput
    "Filter by issueStates"
    issueStates: IssueStateListFilterInput
    "Filter by issueTypes"
    issueTypes: IssueTypeListFilterInput
    "Filter by name"
    name: StringFilterInput
    "Negates the subformula"
    not: IssueTemplateFilterInput
    "Connects all subformulas via or"
    or: [IssueTemplateFilterInput!]
    "Filter by relationTypes"
    relationTypes: IssueRelationTypeListFilterInput
}

"Used to filter by a connection-based property. Fields are joined by AND"
input IssueTemplateListFilterInput {
    "Filters for nodes where all of the related nodes match this filter"
    all: IssueTemplateFilterInput
    "Filters for nodes where any of the related nodes match this filter"
    any: IssueTemplateFilterInput
    "Filters for nodes where none of the related nodes match this filter"
    none: IssueTemplateFilterInput
}

"Defines the order of a IssueTemplate list"
input IssueTemplateOrder {
    "The direction to order by, defaults to ASC"
    direction: OrderDirection = ASC
    "The field to order by, defaults to ID"
    field: IssueTemplateOrderField = ID
}

"Filter used to filter IssueType"
input IssueTypeFilterInput {
    "Connects all subformulas via and"
    and: [IssueTypeFilterInput!]
    "Filter by description"
    description: StringFilterInput
    "Filter by id"
    id: IDFilterInput
    "Filter by issuesWithType"
    issuesWithType: IssueListFilterInput
    "Filter by name"
    name: StringFilterInput
    "Negates the subformula"
    not: IssueTypeFilterInput
    "Connects all subformulas via or"
    or: [IssueTypeFilterInput!]
    "Filter by partOf"
    partOf: IssueTemplateListFilterInput
}

"Input to create an IssueType"
input IssueTypeInput {
    "The description of the NamedNode"
    description: String!
    "A path that is used as the icon for issues. Used with a 0 0 100 100 viewBox. No stroke, only fill."
    iconPath: String!
    "The name of the NamedNode, must not be blank"
    name: String!
}

"Used to filter by a connection-based property. Fields are joined by AND"
input IssueTypeListFilterInput {
    "Filters for nodes where all of the related nodes match this filter"
    all: IssueTypeFilterInput
    "Filters for nodes where any of the related nodes match this filter"
    any: IssueTypeFilterInput
    "Filters for nodes where none of the related nodes match this filter"
    none: IssueTypeFilterInput
}

"Defines the order of a IssueType list"
input IssueTypeOrder {
    "The direction to order by, defaults to ASC"
    direction: OrderDirection = ASC
    "The field to order by, defaults to ID"
    field: IssueTypeOrderField = ID
}

"Input set update the value of a JSON field, like an extension field or a templated field."
input JSONFieldInput {
    "The name of the field"
    name: String!
    "The new value of the field"
    value: JSON
}

"Filter used to filter Label"
input LabelFilterInput {
    "Connects all subformulas via and"
    and: [LabelFilterInput!]
    "Filter by color"
    color: StringFilterInput
    "Filter by createdAt"
    createdAt: DateTimeFilterInput
    "Filters for nodes where the related node match this filter"
    createdBy: UserFilterInput
    "Filter by description"
    description: StringFilterInput
    "Filter by id"
    id: IDFilterInput
    "Filter by issues"
    issues: IssueListFilterInput
    "Filter by lastModifiedAt"
    lastModifiedAt: DateTimeFilterInput
    "Filters for nodes where the related node match this filter"
    lastModifiedBy: UserFilterInput
    "Filter by name"
    name: StringFilterInput
    "Negates the subformula"
    not: LabelFilterInput
    "Connects all subformulas via or"
    or: [LabelFilterInput!]
    "Filter by trackables"
    trackables: TrackableListFilterInput
}

"Used to filter by a connection-based property. Fields are joined by AND"
input LabelListFilterInput {
    "Filters for nodes where all of the related nodes match this filter"
    all: LabelFilterInput
    "Filters for nodes where any of the related nodes match this filter"
    any: LabelFilterInput
    "Filters for nodes where none of the related nodes match this filter"
    none: LabelFilterInput
}

"Defines the order of a Label list"
input LabelOrder {
    "The direction to order by, defaults to ASC"
    direction: OrderDirection = ASC
    "The field to order by, defaults to ID"
    field: LabelOrderField = ID
}

input NodePermissionFilterEntry {
    "The node where the user must have the permission"
    node: ID!
    "The permission the user must have on the node"
    permission: AllPermissionEntry!
}

"Filter which can be used to filter for Nodes with a specific DateTime field"
input NullableDateTimeFilterInput {
    "Matches values which are equal to the provided value"
    eq: DateTime
    "Matches values which are greater than the provided value"
    gt: DateTime
    "Matches values which are greater than or equal to the provided value"
    gte: DateTime
    "Matches values which are equal to any of the provided values"
    in: [DateTime!]
    "If true, matches only null values, if false, matches only non-null values"
    isNull: Boolean
    "Matches values which are lesser than the provided value"
    lt: DateTime
    "Matches values which are lesser than or equal to the provided value"
    lte: DateTime
}

"Filter which can be used to filter for Nodes with a specific Duration field"
input NullableDurationFilterInputFilterInput {
    "Matches values which are equal to the provided value"
    eq: Duration
    "Matches values which are greater than the provided value"
    gt: Duration
    "Matches values which are greater than or equal to the provided value"
    gte: Duration
    "Matches values which are equal to any of the provided values"
    in: [Duration!]
    "If true, matches only null values, if false, matches only non-null values"
    isNull: Boolean
    "Matches values which are lesser than the provided value"
    lt: Duration
    "Matches values which are lesser than or equal to the provided value"
    lte: Duration
}

"Filter which can be used to filter for Nodes with a specific Int field"
input NullableIntFilterInput {
    "Matches values which are equal to the provided value"
    eq: Int
    "Matches values which are greater than the provided value"
    gt: Int
    "Matches values which are greater than or equal to the provided value"
    gte: Int
    "Matches values which are equal to any of the provided values"
    in: [Int!]
    "If true, matches only null values, if false, matches only non-null values"
    isNull: Boolean
    "Matches values which are lesser than the provided value"
    lt: Int
    "Matches values which are lesser than or equal to the provided value"
    lte: Int
}

"Filter which can be used to filter for Nodes with a specific String field"
input NullableStringFilterInput {
    "Matches Strings which contain the provided value"
    contains: String
    "Matches Strings which end with the provided value"
    endsWith: String
    "Matches values which are equal to the provided value"
    eq: String
    "Matches values which are greater than the provided value"
    gt: String
    "Matches values which are greater than or equal to the provided value"
    gte: String
    "Matches values which are equal to any of the provided values"
    in: [String!]
    "If true, matches only null values, if false, matches only non-null values"
    isNull: Boolean
    "Matches values which are lesser than the provided value"
    lt: String
    "Matches values which are lesser than or equal to the provided value"
    lte: String
    "Matches Strings using the provided RegEx"
    matches: String
    "Matches Strings which start with the provided value"
    startsWith: String
}

"Input to create a SubTemplate, where all templatedFieldSpecifications must allow null as value"
input NullableSubTemplateInput {
    "The description of the NamedNode"
    description: String!
    "The name of the NamedNode, must not be blank"
    name: String!
    """
    Additional initial templateFieldSpecifications, should be a JSON schema JSON.
    Must be disjoint with templateFieldSpecifications of templates this template extends.

    """
    templateFieldSpecifications: [JSONFieldInput!]
}

"Filter used to filter ParentTimelineItem"
input ParentTimelineItemFilterInput {
    "Connects all subformulas via and"
    and: [ParentTimelineItemFilterInput!]
    "Filter by childItems"
    childItems: TimelineItemListFilterInput
    "Filter by createdAt"
    createdAt: DateTimeFilterInput
    "Filters for nodes where the related node match this filter"
    createdBy: UserFilterInput
    "Filter by id"
    id: IDFilterInput
    "Filters for nodes where the related node match this filter"
    issue: IssueFilterInput
    "Filter by lastModifiedAt"
    lastModifiedAt: DateTimeFilterInput
    "Filters for nodes where the related node match this filter"
    lastModifiedBy: UserFilterInput
    "Negates the subformula"
    not: ParentTimelineItemFilterInput
    "Connects all subformulas via or"
    or: [ParentTimelineItemFilterInput!]
    "Filters for nodes where the related node match this filter"
    parentItem: ParentTimelineItemFilterInput
    "Filter for specific timeline items. Entries are joined by OR"
    timelineItemTypes: [TimelineItemType!]
}

"Filter used to filter Project"
input ProjectFilterInput {
    "Filter by affectingIssues"
    affectingIssues: IssueListFilterInput
    "Connects all subformulas via and"
    and: [ProjectFilterInput!]
    "Filter by artefacts"
    artefacts: ArtefactListFilterInput
    "Filter by components"
    components: ComponentVersionListFilterInput
    "Filter by description"
    description: StringFilterInput
    "Filter by id"
    id: IDFilterInput
    "Filter by issues"
    issues: IssueListFilterInput
    "Filter by labels"
    labels: LabelListFilterInput
    "Filter by name"
    name: StringFilterInput
    "Negates the subformula"
    not: ProjectFilterInput
    "Connects all subformulas via or"
    or: [ProjectFilterInput!]
    "Filter by permissions"
    permissions: ProjectPermissionListFilterInput
    "Filter by pinnedIssues"
    pinnedIssues: IssueListFilterInput
    "Filters for AffectedByIssues which are related to a Trackable"
    relatedTo: ID
    "Filter by repositoryURL"
    repositoryURL: NullableStringFilterInput
    "Filter by syncsTo"
    syncsTo: IMSProjectListFilterInput
}

"Used to filter by a connection-based property. Fields are joined by AND"
input ProjectListFilterInput {
    "Filters for nodes where all of the related nodes match this filter"
    all: ProjectFilterInput
    "Filters for nodes where any of the related nodes match this filter"
    any: ProjectFilterInput
    "Filters for nodes where none of the related nodes match this filter"
    none: ProjectFilterInput
}

"Defines the order of a Project list"
input ProjectOrder {
    "The direction to order by, defaults to ASC"
    direction: OrderDirection = ASC
    "The field to order by, defaults to ID"
    field: ProjectOrderField = ID
}

"Filter used to filter ProjectPermission"
input ProjectPermissionFilterInput {
    "Filter by allUsers"
    allUsers: BooleanFilterInput
    "Connects all subformulas via and"
    and: [ProjectPermissionFilterInput!]
    "Filter by description"
    description: StringFilterInput
    "Filter by id"
    id: IDFilterInput
    "Filter by name"
    name: StringFilterInput
    "Filter by nodesWithPermission"
    nodesWithPermission: ProjectListFilterInput
    "Negates the subformula"
    not: ProjectPermissionFilterInput
    "Connects all subformulas via or"
    or: [ProjectPermissionFilterInput!]
    "Filter by users"
    users: GropiusUserListFilterInput
}

"Used to filter by a connection-based property. Fields are joined by AND"
input ProjectPermissionListFilterInput {
    "Filters for nodes where all of the related nodes match this filter"
    all: ProjectPermissionFilterInput
    "Filters for nodes where any of the related nodes match this filter"
    any: ProjectPermissionFilterInput
    "Filters for nodes where none of the related nodes match this filter"
    none: ProjectPermissionFilterInput
}

"Defines the order of a ProjectPermission list"
input ProjectPermissionOrder {
    "The direction to order by, defaults to ASC"
    direction: OrderDirection = ASC
    "The field to order by, defaults to ID"
    field: ProjectPermissionOrderField = ID
}

"Filter used to filter RelationCondition"
input RelationConditionFilterInput {
    "Connects all subformulas via and"
    and: [RelationConditionFilterInput!]
    "Filter by from"
    from: RelationPartnerTemplateListFilterInput
    "Filter by id"
    id: IDFilterInput
    "Filter by interfaceSpecificationDerivationConditions"
    interfaceSpecificationDerivationConditions: InterfaceSpecificationDerivationConditionListFilterInput
    "Negates the subformula"
    not: RelationConditionFilterInput
    "Connects all subformulas via or"
    or: [RelationConditionFilterInput!]
    "Filter by partOf"
    partOf: RelationTemplateListFilterInput
    "Filter by to"
    to: RelationPartnerTemplateListFilterInput
}

"Input to create a RelationCondition"
input RelationConditionInput {
    "IDs of Templates of allowed start RelationPartners"
    from: [ID!]!
    "Defines which InterfaceSpecifications are derived via the relation"
    interfaceSpecificationDerivationConditions: [InterfaceSpecificationDerivationConditionInput!]!
    "IDs of Templates of allowed end RelationPartners"
    to: [ID!]!
}

"Used to filter by a connection-based property. Fields are joined by AND"
input RelationConditionListFilterInput {
    "Filters for nodes where all of the related nodes match this filter"
    all: RelationConditionFilterInput
    "Filters for nodes where any of the related nodes match this filter"
    any: RelationConditionFilterInput
    "Filters for nodes where none of the related nodes match this filter"
    none: RelationConditionFilterInput
}

"Defines the order of a RelationCondition list"
input RelationConditionOrder {
    "The direction to order by, defaults to ASC"
    direction: OrderDirection = ASC
    "The field to order by, defaults to ID"
    field: RelationConditionOrderField = ID
}

"Filter used to filter Relation"
input RelationFilterInput {
    "Connects all subformulas via and"
    and: [RelationFilterInput!]
    "Filter by derivesInvisible"
    derivesInvisible: InterfaceDefinitionListFilterInput
    "Filter by derivesVisible"
    derivesVisible: InterfaceDefinitionListFilterInput
    "Filters for nodes where the related node match this filter"
    end: RelationPartnerFilterInput
    "Filter by endParts"
    endParts: InterfacePartListFilterInput
    "Filter by id"
    id: IDFilterInput
    "Negates the subformula"
    not: RelationFilterInput
    "Connects all subformulas via or"
    or: [RelationFilterInput!]
    "Filters for nodes where the related node match this filter"
    start: RelationPartnerFilterInput
    "Filter by startParts"
    startParts: InterfacePartListFilterInput
    "Filters for nodes where the related node match this filter"
    template: RelationTemplateFilterInput
    "Filter for templated fields with matching key and values. Entries are joined by AND"
    templatedFields: [JSONFieldInput]
}

"Used to filter by a connection-based property. Fields are joined by AND"
input RelationListFilterInput {
    "Filters for nodes where all of the related nodes match this filter"
    all: RelationFilterInput
    "Filters for nodes where any of the related nodes match this filter"
    any: RelationFilterInput
    "Filters for nodes where none of the related nodes match this filter"
    none: RelationFilterInput
}

"Defines the order of a Relation list"
input RelationOrder {
    "The direction to order by, defaults to ASC"
    direction: OrderDirection = ASC
    "The field to order by, defaults to ID"
    field: RelationOrderField = ID
}

"Filter used to filter RelationPartner"
input RelationPartnerFilterInput {
    "Filter by affectingIssues"
    affectingIssues: IssueListFilterInput
    "Filter by aggregatedIssues"
    aggregatedIssues: AggregatedIssueListFilterInput
    "Connects all subformulas via and"
    and: [RelationPartnerFilterInput!]
    "Filter by description"
    description: StringFilterInput
    "Filter by id"
    id: IDFilterInput
    "Filter by incomingRelations"
    incomingRelations: RelationListFilterInput
    "Filter by name"
    name: StringFilterInput
    "Negates the subformula"
    not: RelationPartnerFilterInput
    "Connects all subformulas via or"
    or: [RelationPartnerFilterInput!]
    "Filter by outgoingRelations"
    outgoingRelations: RelationListFilterInput
    "Filters for RelationPartners which are part of a Project's component graph"
    partOfProject: ID
    "Filters for AffectedByIssues which are related to a Trackable"
    relatedTo: ID
    "Filter for templated fields with matching key and values. Entries are joined by AND"
    templatedFields: [JSONFieldInput]
}

"Filter used to filter RelationPartnerTemplate"
input RelationPartnerTemplateFilterInput {
    "Connects all subformulas via and"
    and: [RelationPartnerTemplateFilterInput!]
    "Filter by description"
    description: StringFilterInput
    "Filter by id"
    id: IDFilterInput
    "Filter by isDeprecated"
    isDeprecated: BooleanFilterInput
    "Filter by name"
    name: StringFilterInput
    "Negates the subformula"
    not: RelationPartnerTemplateFilterInput
    "Connects all subformulas via or"
    or: [RelationPartnerTemplateFilterInput!]
    "Filter by possibleEndOfRelations"
    possibleEndOfRelations: RelationConditionListFilterInput
    "Filter by possibleStartOfRelations"
    possibleStartOfRelations: RelationConditionListFilterInput
}

"Used to filter by a connection-based property. Fields are joined by AND"
input RelationPartnerTemplateListFilterInput {
    "Filters for nodes where all of the related nodes match this filter"
    all: RelationPartnerTemplateFilterInput
    "Filters for nodes where any of the related nodes match this filter"
    any: RelationPartnerTemplateFilterInput
    "Filters for nodes where none of the related nodes match this filter"
    none: RelationPartnerTemplateFilterInput
}

"Defines the order of a RelationPartnerTemplate list"
input RelationPartnerTemplateOrder {
    "The direction to order by, defaults to ASC"
    direction: OrderDirection = ASC
    "The field to order by, defaults to ID"
    field: RelationPartnerTemplateOrderField = ID
}

"Filter used to filter RelationTemplate"
input RelationTemplateFilterInput {
    "Connects all subformulas via and"
    and: [RelationTemplateFilterInput!]
    "Filter by description"
    description: StringFilterInput
    "Filter by extendedBy"
    extendedBy: RelationTemplateListFilterInput
    "Filter by extends"
    extends: RelationTemplateListFilterInput
    "Filter by id"
    id: IDFilterInput
    "Filter by isDeprecated"
    isDeprecated: BooleanFilterInput
    "Filter by name"
    name: StringFilterInput
    "Negates the subformula"
    not: RelationTemplateFilterInput
    "Connects all subformulas via or"
    or: [RelationTemplateFilterInput!]
    "Filter by relationConditions"
    relationConditions: RelationConditionListFilterInput
}

"Used to filter by a connection-based property. Fields are joined by AND"
input RelationTemplateListFilterInput {
    "Filters for nodes where all of the related nodes match this filter"
    all: RelationTemplateFilterInput
    "Filters for nodes where any of the related nodes match this filter"
    any: RelationTemplateFilterInput
    "Filters for nodes where none of the related nodes match this filter"
    none: RelationTemplateFilterInput
}

"Defines the order of a RelationTemplate list"
input RelationTemplateOrder {
    "The direction to order by, defaults to ASC"
    direction: OrderDirection = ASC
    "The field to order by, defaults to ID"
    field: RelationTemplateOrderField = ID
}

"Input for the removeAffectedEntityFromIssue mutation"
input RemoveAffectedEntityFromIssueInput {
    "The id of the AffectedByIssue which is no longer affected by the Issue"
    affectedEntity: ID!
    "The id of the Issue which no longer affects the entity"
    issue: ID!
}

"Input for the removeArtefactFromIssue mutation"
input RemoveArtefactFromIssueInput {
    "The id of the Artefact to remove"
    artefact: ID!
    "The id of the Issue where to remove the Artefact"
    issue: ID!
}

"Input for the removeAssignment mutations"
input RemoveAssignmentInput {
    "The id of the Assignment to remove"
    assignment: ID!
}

"Input for the removeComponentVersionFromProject mutation"
input RemoveComponentVersionFromProjectInput {
    "The id of the ComponentVersion to remove"
    componentVersion: ID!
    "The id of the Project from which the ComponentVersion is removed"
    project: ID!
}

"Input for the removeInterfaceSpecificationVersionfromComponentVersion mutation"
input RemoveInterfaceSpecificationVersionFromComponentVersionInput {
    "The id of the ComponentVersion to remove the InterfaceSpecificationVersion from."
    componentVersion: ID!
    "The id of the InterfaceSpecificationVersion to remove. Must be part of the same Component as `componentVersion`"
    interfaceSpecificationVersion: ID!
    "If `true`, interfaceSpecificationVersion will be no longer invisible on componentVersion"
    invisible: Boolean!
    "If `true`, interfaceSpecificationVersion will be no longer visible on componentVersion"
    visible: Boolean!
}

"Input for the removeIssueFromPinnedIssues mutation"
input RemoveIssueFromPinnedIssuesInput {
    "The id of the Issue to unpin"
    issue: ID!
    "The id of the Trackable where the Issue should be unpinned"
    trackable: ID!
}

"Input for the removeIssueFromTrackable mutation"
input RemoveIssueFromTrackableInput {
    "The id of the Issue to remove from the Trackable"
    issue: ID!
    "The id of the Trackable where to remove the Issue"
    trackable: ID!
}

"Input for the removeIssueRelation mutations"
input RemoveIssueRelationInput {
    "The id of the IssueRelation to remove"
    issueRelation: ID!
}

"Input for the removeLabelFromIssue mutation"
input RemoveLabelFromIssueInput {
    "The id of the Issue where to remove the Label"
    issue: ID!
    "The id of the Label to remove"
    label: ID!
}

"Input for the removeLabelFromTrackable mutation"
input RemoveLabelFromTrackableInput {
    "The id of the Label to remove"
    label: ID!
    "The id of the Trackable where to remove the Label"
    trackable: ID!
}

"Filter which can be used to filter for Nodes with a specific String field"
input StringFilterInput {
    "Matches Strings which contain the provided value"
    contains: String
    "Matches Strings which end with the provided value"
    endsWith: String
    "Matches values which are equal to the provided value"
    eq: String
    "Matches values which are greater than the provided value"
    gt: String
    "Matches values which are greater than or equal to the provided value"
    gte: String
    "Matches values which are equal to any of the provided values"
    in: [String!]
    "Matches values which are lesser than the provided value"
    lt: String
    "Matches values which are lesser than or equal to the provided value"
    lte: String
    "Matches Strings using the provided RegEx"
    matches: String
    "Matches Strings which start with the provided value"
    startsWith: String
}

"Input to create a StrokeStyle"
input StrokeStyleInput {
    "The color of the stroke"
    color: String
    "The dash pattern of the stroke"
    dash: [Float!]
}

"Input to create a SubTemplate"
input SubTemplateInput {
    "The description of the NamedNode"
    description: String!
    "The name of the NamedNode, must not be blank"
    name: String!
    """
    Additional initial templateFieldSpecifications, should be a JSON schema JSON.
    Must be disjoint with templateFieldSpecifications of templates this template extends.

    """
    templateFieldSpecifications: [JSONFieldInput!]
}

"Filter used to filter SyncPermissionTarget"
input SyncPermissionTargetFilterInput {
    "Connects all subformulas via and"
    and: [SyncPermissionTargetFilterInput!]
    "Filter by description"
    description: StringFilterInput
    "Filter by id"
    id: IDFilterInput
    "Filter by name"
    name: StringFilterInput
    "Negates the subformula"
    not: SyncPermissionTargetFilterInput
    "Connects all subformulas via or"
    or: [SyncPermissionTargetFilterInput!]
    "Filter by syncOthersAllowedBy"
    syncOthersAllowedBy: GropiusUserListFilterInput
    "Filter by syncSelfAllowedBy"
    syncSelfAllowedBy: GropiusUserListFilterInput
}

"Used to filter by a connection-based property. Fields are joined by AND"
input SyncPermissionTargetListFilterInput {
    "Filters for nodes where all of the related nodes match this filter"
    all: SyncPermissionTargetFilterInput
    "Filters for nodes where any of the related nodes match this filter"
    any: SyncPermissionTargetFilterInput
    "Filters for nodes where none of the related nodes match this filter"
    none: SyncPermissionTargetFilterInput
}

"Defines the order of a SyncPermissionTarget list"
input SyncPermissionTargetOrder {
    "The direction to order by, defaults to ASC"
    direction: OrderDirection = ASC
    "The field to order by, defaults to ID"
    field: SyncPermissionTargetOrderField = ID
}

"Filter used to filter TimelineItem"
input TimelineItemFilterInput {
    "Connects all subformulas via and"
    and: [TimelineItemFilterInput!]
    "Filter by createdAt"
    createdAt: DateTimeFilterInput
    "Filters for nodes where the related node match this filter"
    createdBy: UserFilterInput
    "Filter by id"
    id: IDFilterInput
    "Filters for nodes where the related node match this filter"
    issue: IssueFilterInput
    "Filter by lastModifiedAt"
    lastModifiedAt: DateTimeFilterInput
    "Filters for nodes where the related node match this filter"
    lastModifiedBy: UserFilterInput
    "Negates the subformula"
    not: TimelineItemFilterInput
    "Connects all subformulas via or"
    or: [TimelineItemFilterInput!]
    "Filters for nodes where the related node match this filter"
    parentItem: ParentTimelineItemFilterInput
    "Filter for specific timeline items. Entries are joined by OR"
    timelineItemTypes: [TimelineItemType!]
}

"Used to filter by a connection-based property. Fields are joined by AND"
input TimelineItemListFilterInput {
    "Filters for nodes where all of the related nodes match this filter"
    all: TimelineItemFilterInput
    "Filters for nodes where any of the related nodes match this filter"
    any: TimelineItemFilterInput
    "Filters for nodes where none of the related nodes match this filter"
    none: TimelineItemFilterInput
}

"Defines the order of a TimelineItem list"
input TimelineItemOrder {
    "The direction to order by, defaults to ASC"
    direction: OrderDirection = ASC
    "The field to order by, defaults to ID"
    field: TimelineItemOrderField = ID
}

"Filter used to filter Trackable"
input TrackableFilterInput {
    "Filter by affectingIssues"
    affectingIssues: IssueListFilterInput
    "Connects all subformulas via and"
    and: [TrackableFilterInput!]
    "Filter by artefacts"
    artefacts: ArtefactListFilterInput
    "Filter by description"
    description: StringFilterInput
    "Filter by id"
    id: IDFilterInput
    "Filter by issues"
    issues: IssueListFilterInput
    "Filter by labels"
    labels: LabelListFilterInput
    "Filter by name"
    name: StringFilterInput
    "Negates the subformula"
    not: TrackableFilterInput
    "Connects all subformulas via or"
    or: [TrackableFilterInput!]
    "Filter by pinnedIssues"
    pinnedIssues: IssueListFilterInput
    "Filters for AffectedByIssues which are related to a Trackable"
    relatedTo: ID
    "Filter by repositoryURL"
    repositoryURL: NullableStringFilterInput
    "Filter by syncsTo"
    syncsTo: IMSProjectListFilterInput
}

"Used to filter by a connection-based property. Fields are joined by AND"
input TrackableListFilterInput {
    "Filters for nodes where all of the related nodes match this filter"
    all: TrackableFilterInput
    "Filters for nodes where any of the related nodes match this filter"
    any: TrackableFilterInput
    "Filters for nodes where none of the related nodes match this filter"
    none: TrackableFilterInput
}

"Defines the order of a Trackable list"
input TrackableOrder {
    "The direction to order by, defaults to ASC"
    direction: OrderDirection = ASC
    "The field to order by, defaults to ID"
    field: TrackableOrderField = ID
}

"Input to map an old type to a new type"
input TypeMappingInput {
    "The new type, null representing no type"
    newType: ID
    "The old type, null representing no type"
    oldType: ID!
}

"Input for the updateArtefact mutation"
input UpdateArtefactInput {
    "The new file of the Artefact"
    file: URL
    "The new value of the from field of the Artefact"
    from: Int
    "The id of the node to update"
    id: ID!
    """
    If provided, the id of the new template for the Artefact
    Use `templatedFields` to update fields so that they conform with the new specifications.
    No longer needed fields are automatically removed.

    """
    template: ID
    "Values for templatedFields to update"
    templatedFields: [JSONFieldInput!]
    "The new value of the to field of the Artefact"
    to: Int
    "New version of the Artefact"
    version: String
}

"Input for the updateBody mutation"
input UpdateBodyInput {
    "The body of the Comment"
    body: String
    "The id of the node to update"
    id: ID!
}

"Input for the updateComponent mutation"
input UpdateComponentInput {
    "Ids of permissions to add, must be disjoint with removedPermissions."
    addedPermissions: [ID!]
    """
    Values for templatedFields of ComponentVersions to update.
    Only evaluated if `template` is provided!
    Affect all ComponentVersions of the updated Component

    """
    componentVersionTemplatedFields: [JSONFieldInput!]
    "The description of the NamedNode"
    description: String
    "The id of the node to update"
    id: ID!
    "The new name of the NamedNode, must not be empty"
    name: String
    """
    Ids of permissions to remove, must be disjoint with addedPermissions.
    There must always be at least one permissions granting ADMIN to some GropiusUser left.

    """
    removedPermissions: [ID!]
    "The repositoryURL of the named node"
    repositoryURL: URL
    """
    If provided, the id of the new template for the Component
    Use `templatedFields` to update fields so that they conform with the new specifications.
    Use `componentVersionTemplatedFields` to update the `templatedFields` of ALL ComponentVersions
    No longer needed fields are automatically removed.

    """
    template: ID
    "Values for templatedFields to update"
    templatedFields: [JSONFieldInput!]
}

"Input for the updateComponentPermission mutation"
input UpdateComponentPermissionInput {
    "Permission entries to add, must be disjoint with removedEntries"
    addedEntries: [ComponentPermissionEntry!]
    "Ids of affected users to add"
    addedUsers: [ID!]
    "The new value for allUsers"
    allUsers: Boolean
    "The description of the NamedNode"
    description: String
    "The id of the node to update"
    id: ID!
    "The new name of the NamedNode, must not be empty"
    name: String
    "Permission entries to remove, must be disjoint with addedEntries"
    removedEntries: [ComponentPermissionEntry!]
    "Ids of affected users to remove"
    removedUsers: [ID!]
}

"Input for the updateComponentVersion mutation"
input UpdateComponentVersionInput {
    "The description of the NamedNode"
    description: String
    "The id of the node to update"
    id: ID!
    "The new name of the NamedNode, must not be empty"
    name: String
    "Values for templatedFields to update"
    templatedFields: [JSONFieldInput!]
    "New version of the ComponentVersion"
    version: String
}

"Input for the updateGlobalPermission mutation"
input UpdateGlobalPermissionInput {
    "Permission entries to add, must be disjoint with removedEntries"
    addedEntries: [PermissionEntry!]
    "Ids of affected users to add"
    addedUsers: [ID!]
    "The new value for allUsers"
    allUsers: Boolean
    "The description of the NamedNode"
    description: String
    "The id of the node to update"
    id: ID!
    "The new name of the NamedNode, must not be empty"
    name: String
    "Permission entries to remove, must be disjoint with addedEntries"
    removedEntries: [PermissionEntry!]
    "Ids of affected users to remove"
    removedUsers: [ID!]
}

"Input for the updateGropiusUserMutation"
input UpdateGropiusUserInput {
    "The new avatar of the user"
    avatar: URL
    "The new displayName of the User to update"
    displayName: String
    "The new email of the User to update"
    email: String
    "The id of the node to update"
    id: ID!
    "The new value for isAdmin of the GropiusUser to update"
    isAdmin: Boolean
}

"Input for the updateIMS mutation"
input UpdateIMSInput {
    "Ids of permissions to add, must be disjoint with removedPermissions."
    addedPermissions: [ID!]
    "The description of the NamedNode"
    description: String
    "The id of the node to update"
    id: ID!
    "The new name of the NamedNode, must not be empty"
    name: String
    """
    Ids of permissions to remove, must be disjoint with addedPermissions.
    There must always be at least one permissions granting ADMIN to some GropiusUser left.

    """
    removedPermissions: [ID!]
    "Values for templatedFields to update"
    templatedFields: [JSONFieldInput!]
}

"Input for the updateImsPermission mutation"
input UpdateIMSPermissionInput {
    "Permission entries to add, must be disjoint with removedEntries"
    addedEntries: [IMSPermissionEntry!]
    "Ids of affected users to add"
    addedUsers: [ID!]
    "The new value for allUsers"
    allUsers: Boolean
    "The description of the NamedNode"
    description: String
    "The id of the node to update"
    id: ID!
    "The new name of the NamedNode, must not be empty"
    name: String
    "Permission entries to remove, must be disjoint with addedEntries"
    removedEntries: [IMSPermissionEntry!]
    "Ids of affected users to remove"
    removedUsers: [ID!]
}

"Input for the updateIMSProject mutation"
input UpdateIMSProjectInput {
    "The description of the NamedNode"
    description: String
    "The id of the node to update"
    id: ID!
    "The new name of the NamedNode, must not be empty"
    name: String
    "Values for templatedFields to update"
    templatedFields: [JSONFieldInput!]
}

"Input for the updateInterfaceDefinition mutation"
input UpdateInterfaceDefinitionInput {
    "The id of the node to update"
    id: ID!
    "Values for templatedFields to update"
    templatedFields: [JSONFieldInput!]
}

"Input for the updateInterface mutation"
input UpdateInterfaceInput {
    "The description of the NamedNode"
    description: String
    "The id of the node to update"
    id: ID!
    "The new name of the NamedNode, must not be empty"
    name: String
    "Values for templatedFields to update"
    templatedFields: [JSONFieldInput!]
}

"Input for the updateInterfacePart mutation"
input UpdateInterfacePartInput {
    "The description of the NamedNode"
    description: String
    "The id of the node to update"
    id: ID!
    "The new name of the NamedNode, must not be empty"
    name: String
    "Values for templatedFields to update"
    templatedFields: [JSONFieldInput!]
}

"Input for the updateInterfaceSpecification mutation"
input UpdateInterfaceSpecificationInput {
    "The description of the NamedNode"
    description: String
    "The id of the node to update"
    id: ID!
    """
    Values for templatedFields of InterfaceDefinitions to update.
    Only evaluated if `template` is provided!
    Affect all InterfaceDefinitions of the updated InterfaceSpecification

    """
    interfaceDefinitionTemplatedFields: [JSONFieldInput!]
    """
    Values for templatedFields of InterfaceParts to update.
    Only evaluated if `template` is provided!
    Affect all InterfaceParts of the updated InterfaceSpecification

    """
    interfacePartTemplatedFields: [JSONFieldInput!]
    """
    Values for templatedFields of InterfaceSpecificationVersions to update.
    Only evaluated if `template` is provided!
    Affect all InterfaceSpecificationVersions of the updated InterfaceSpecification

    """
    interfaceSpecificationVersionTemplatedFields: [JSONFieldInput!]
    """
    Values for templatedFields of Interfaces to update.
    Only evaluated if `template` is provided!
    Affect all Interfaces of the updated InterfaceSpecification

    """
    interfaceTemplatedFields: [JSONFieldInput!]
    "The new name of the NamedNode, must not be empty"
    name: String
    """
    If provided, the id of the new template for the Component
    Use `templatedFields` to update fields so that they conform with the new specifications.
    No longer needed fields are automatically removed.

    """
    template: ID
    "Values for templatedFields to update"
    templatedFields: [JSONFieldInput!]
}

"Input for the updateInterfaceSpecificationVersion mutation"
input UpdateInterfaceSpecificationVersionInput {
    "The description of the NamedNode"
    description: String
    "The id of the node to update"
    id: ID!
    "The new name of the NamedNode, must not be empty"
    name: String
    "Values for templatedFields to update"
    templatedFields: [JSONFieldInput!]
    "New version of the InterfaceSpecificationVersion"
    version: String
}

"Input for the updateIntraComponentDependencySpecification mutation"
input UpdateIntraComponentDependencySpecificationInput {
    "Added incomingParticipants"
    addedIncomingParticipants: [IntraComponentDependencyParticipantInput!]
    "Added outgoingParticipants"
    addedOutgoingParticipants: [IntraComponentDependencyParticipantInput!]
    "The description of the NamedNode"
    description: String
    "The id of the node to update"
    id: ID!
    "The new name of the NamedNode, must not be empty"
    name: String
    "Ids of incomingParticipants to remove / delete"
    removedIncomingParticipants: [ID!]
    "Ids of outgoingParticipants to remove / delete"
    removedOutgoingParticipants: [ID!]
}

"Input for the updateIssueComment mutation"
input UpdateIssueCommentInput {
    "Ids of Artefacts which should be added to `referencedArtefacts`"
    addedReferencedArtefacts: [ID!]
    "The body of the Comment"
    body: String
    "The id of the node to update"
    id: ID!
    "Ids of Artefacts which should be removed from `referencedArtefacts`"
    removedReferencedArtefacts: [ID!]
}

"Input for the updateLabel mutation"
input UpdateLabelInput {
    "The new color of the Label"
    color: String
    "The description of the NamedNode"
    description: String
    "The id of the node to update"
    id: ID!
    "The new name of the NamedNode, must not be empty"
    name: String
}

"Input for the updateProject mutation"
input UpdateProjectInput {
    "Ids of permissions to add, must be disjoint with removedPermissions."
    addedPermissions: [ID!]
    "The description of the NamedNode"
    description: String
    "The id of the node to update"
    id: ID!
    "The new name of the NamedNode, must not be empty"
    name: String
    """
    Ids of permissions to remove, must be disjoint with addedPermissions.
    There must always be at least one permissions granting ADMIN to some GropiusUser left.

    """
    removedPermissions: [ID!]
    "The repositoryURL of the named node"
    repositoryURL: URL
}

"Input for the updateProjectPermission mutation"
input UpdateProjectPermissionInput {
    "Permission entries to add, must be disjoint with removedEntries"
    addedEntries: [ProjectPermissionEntry!]
    "Ids of affected users to add"
    addedUsers: [ID!]
    "The new value for allUsers"
    allUsers: Boolean
    "The description of the NamedNode"
    description: String
    "The id of the node to update"
    id: ID!
    "The new name of the NamedNode, must not be empty"
    name: String
    "Permission entries to remove, must be disjoint with addedEntries"
    removedEntries: [ProjectPermissionEntry!]
    "Ids of affected users to remove"
    removedUsers: [ID!]
}

"Input for the updateRelation mutation"
input UpdateRelationInput {
    "Ids of InterfaceParts of the `end` Interface to add to `endParts`"
    addedEndParts: [ID!]
    "Ids of InterfaceParts of the `start` Interface to add to `startParts`"
    addedStartParts: [ID!]
    "The id of the node to update"
    id: ID!
    "Ids of InterfaceParts of the `end` Interface to remove from `endParts`"
    removedEndParts: [ID!]
    "Ids of InterfaceParts of the `start` Interface to remove from `startParts`"
    removedStartParts: [ID!]
    """
    If provided, the id of the new template for the Component
    Use `templatedFields` to update fields so that they conform with the new specifications.
    No longer needed fields are automatically removed.
    Caution: the chosen Template must be compatible with the Templates of the start and end of the Relation.

    """
    template: ID
    "Values for templatedFields to update"
    templatedFields: [JSONFieldInput!]
}

"Input for the updateSyncPermissions mutation"
input UpdateSyncPermissionsInput {
    "Whether the sync service is allowed to sync content of other users"
    canSyncOthers: Boolean!
    "Whether the sync service is allowed to sync content of the user"
    canSyncSelf: Boolean!
    "The SyncPermissionTarget to update the sync permissions for the current user"
    id: ID!
}

"Input for the updateTemplateDeprecationStatus mutation"
input UpdateTemplateDeprecationStatusInput {
    "The id of the node to update"
    id: ID!
    "The new deprecation status of the template"
    isDeprecated: Boolean!
}

"Filter used to filter User"
input UserFilterInput {
    "Connects all subformulas via and"
    and: [UserFilterInput!]
    "Filter by assignments"
    assignments: AssignmentListFilterInput
    "Filter by createdNodes"
    createdNodes: AuditedNodeListFilterInput
    "Filter by displayName"
    displayName: StringFilterInput
    "Filter by email"
    email: NullableStringFilterInput
    "Filter by id"
    id: IDFilterInput
    "Negates the subformula"
    not: UserFilterInput
    "Connects all subformulas via or"
    or: [UserFilterInput!]
    "Filter by participatedIssues"
    participatedIssues: IssueListFilterInput
    "Filter by username"
    username: NullableStringFilterInput
}

"Used to filter by a connection-based property. Fields are joined by AND"
input UserListFilterInput {
    "Filters for nodes where all of the related nodes match this filter"
    all: UserFilterInput
    "Filters for nodes where any of the related nodes match this filter"
    any: UserFilterInput
    "Filters for nodes where none of the related nodes match this filter"
    none: UserFilterInput
}

"Defines the order of a User list"
input UserOrder {
    "The direction to order by, defaults to ASC"
    direction: OrderDirection = ASC
    "The field to order by, defaults to ID"
    field: UserOrderField = ID
}
